<!DOCTYPE html>
<html lang="nl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Friday-night-hawk-s Timer</title>
    <link rel="icon" href="FNH logo.jpg" type="image/jpeg">
    <link rel="apple-touch-icon" href="FNH logo.jpg">
    <!-- script src="workout_data.js"></script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script>
        // FIX: Ensure jsPDF is available globally for autotable
        window.jsPDF = window.jspdf.jsPDF;
    </script>
    <style>
        :root {
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --app-height: 100dvh;

            /* Premium Sport Palette */
            --bg-main: #000000;
            --bg-secondary: #0a0a0a;

            /* Glassmorphism */
            --bg-card: rgba(28, 28, 30, 0.65);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-blur: 25px;

            /* Accents */
            --accent-primary: #30D158;
            /* Neon Green */
            --accent-secondary: #0A84FF;
            /* Electric Blue */
            --accent-danger: #FF453A;
            --accent-warm: #FF9F0A;

            /* Text */
            --text-primary: #FFFFFF;
            --text-secondary: #98989d;
            --text-tertiary: #636366;

            /* Properties */
            --radius-card: 24px;
            --radius-btn: 18px;
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;

            /* Shadows */
            --glow-primary: 0 0 20px rgba(48, 209, 88, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-main);
            color: var(--text-primary);
            font-family: var(--font-main);
            text-align: center;
            margin: 0;
            padding: 0;
            overflow: hidden;
            /* Prevent scrolling */
            height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none;
            transition: background-color 0.3s ease;
        }

        /* --- HOURGLASS BACKGROUND --- */
        #hourglass-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: #000;
            /* Start black */
            pointer-events: none;
        }

        #hourglass-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background-color: #30D158;
            /* Default green */
            transition: height 1s linear, background-color 0.5s ease;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
            /* Soft top edge */
        }

        .container {
            padding: calc(10px + var(--safe-top)) 10px calc(10px + var(--safe-bottom)) 10px;
            height: 100%;
            width: 100%;
            max-width: 100%;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* --- INTRO BANNER --- */
        .intro-banner {
            background: linear-gradient(135deg, rgba(44, 44, 46, 0.8) 0%, rgba(28, 28, 30, 0.9) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-card);
            padding: 24px;
            margin-top: 10px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-card);
        }

        .intro-title {
            font-size: 14px;
            font-weight: 900;
            color: var(--accent-primary);
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 1px;
        }

        .intro-text {
            font-size: 13px;
            color: #ccc;
            line-height: 1.4;
        }

        /* --- LOGO & HEADER --- */
        .logo-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        .app-logo {
            width: 120px;
            height: auto;
            border-radius: 50%;
            border: 2px solid #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #222;
            flex-wrap: wrap;
            gap: 10px;
        }

        .app-header {
            font-size: clamp(14px, 4vw, 18px);
            font-weight: 900;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: -0.5px;
            text-align: left;
        }

        .version-tag {
            font-size: 11px;
            color: #30D158;
            background: #1c1c1e;
            padding: 2px 5px;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 5px;
            font-weight: bold;
            border: 1px solid #333;
        }

        .header-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .btn-header {
            border: none;
            border-radius: 20px;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: opacity 0.2s;
        }

        .btn-header:active {
            opacity: 0.6;
        }

        .btn-save {
            background: #0A84FF;
            color: white;
        }

        .btn-reset {
            background: #333;
            color: #ccc;
            border: 1px solid #444;
        }

        .btn-share-app {
            background: #BF5AF2;
            color: white;
        }

        .btn-dumbbell {
            background: #FF9F0A;
            /* Warm accent color */
            color: white;
        }

        /* --- MATERIAL SELECTOR MODAL --- */
        #material-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.85);
            /* Darker backdrop */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        #material-modal.active {
            display: flex;
        }

        .material-content {
            background: #1c1c1e;
            width: 100%;
            max-width: 600px;
            height: 90vh;
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .material-header {
            padding: 20px;
            background: #2c2c2e;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .material-title {
            font-size: 18px;
            font-weight: 800;
            color: #fff;
            text-transform: uppercase;
        }

        .btn-close-modal {
            background: transparent;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
        }

        .material-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Section 1: Material Toggles */
        .material-filters {
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            border-bottom: 1px solid #333;
            max-height: 150px;
            overflow-y: auto;
            background: #151516;
        }

        .material-tag {
            padding: 6px 12px;
            border-radius: 20px;
            background: #333;
            color: #ccc;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid transparent;
            transition: all 0.2s;
        }

        .material-tag.selected {
            background: #30D158;
            color: #000;
            box-shadow: 0 0 10px rgba(48, 209, 88, 0.3);
        }

        /* Split View: List & Preview */
        .material-split-view {
            flex: 1;
            display: flex;
            overflow: hidden;
            /* Prevent body scroll */
        }

        /* Left: List */
        .exercise-list-col {
            flex: 1;
            overflow-y: auto;
            border-right: 1px solid #333;
            padding: 10px;
        }

        .exercise-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #2c2c2e;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .exercise-item:hover,
        .exercise-item.active {
            background: #3a3a3c;
            border: 1px solid #555;
        }

        .ex-list-thumb {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            object-fit: cover;
            background: #000;
        }

        .ex-list-info {
            flex: 1;
            min-width: 0;
        }

        .ex-list-name {
            font-size: 13px;
            font-weight: 700;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ex-list-cat {
            font-size: 11px;
            color: #888;
        }

        /* Right: Preview (Sticky-ish) */
        .exercise-preview-col {
            flex: 1.2;
            background: #000;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #222;
        }

        .preview-image {
            width: 100%;
            aspect-ratio: 16/9;
            background: #222;
            border-radius: 12px;
            margin-bottom: 15px;
            object-fit: cover;
            border: 1px solid #333;
        }

        .preview-title {
            font-size: 16px;
            font-weight: 900;
            color: #30D158;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .preview-meta {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 15px;
            font-style: italic;
        }

        .preview-desc {
            font-size: 13px;
            color: #ddd;
            line-height: 1.5;
            background: #1c1c1e;
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #333;
        }

        /* Mobile Responsive for Split View */
        @media (max-width: 600px) {
            .material-split-view {
                flex-direction: column;
            }

            .exercise-list-col {
                height: 40%;
                border-right: none;
                border-bottom: 1px solid #333;
            }

            .exercise-preview-col {
                height: 60%;
                flex: none;
            }
        }

        /* --- GRID SYSTEMS --- */
        .compact-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            width: 100%;
            margin-bottom: 10px;
        }

        .bonus-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1.5fr;
            gap: 5px;
            width: 100%;
            margin-bottom: 8px;
            align-items: end;
        }

        .half-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            width: 100%;
            margin-bottom: 15px;
        }

        .select-group {
            display: flex;
            flex-direction: column;
            min-width: 0;
            justify-content: space-between;
        }

        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 4px;
            text-align: left;
            white-space: normal;
            font-weight: 600;
            line-height: 1.3;
        }

        /* --- CARDS & INPUTS --- */
        .card-group {
            background: var(--bg-card);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: var(--radius-card);
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        select.compact-select,
        input[type="time"],
        input[type="text"],
        input[type="number"],
        .text-input-trigger,
        select.text-input {
            width: 100%;
            padding: 16px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-primary);
            font-size: 17px;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            appearance: none;
            -webkit-appearance: none;
            text-align: center;
        }

        select.compact-select:focus,
        input:focus {
            background: rgba(0, 0, 0, 0.5);
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 4px rgba(48, 209, 88, 0.1);
            outline: none;
            transform: scale(1.01);
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        /* --- TOGGLES (Segmented Control) --- */
        .toggle-container {
            display: flex;
            background: #2C2C2E;
            border-radius: 99px;
            /* Pill shape */
            padding: 4px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .toggle-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: 600;
            border-radius: 99px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-btn.active {
            background: #636366;
            /* Lighter grey for active state in dark mode */
            background: var(--text-primary);
            color: #000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* --- BONUS ROW ALIGNMENT --- */
        .bonus-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .bonus-row input {
            flex: 2;
            /* Check wide name */
            min-width: 0;
        }

        .bonus-row select:nth-of-type(1) {
            flex: 1;
            /* Duration: Keep consistent width */
            min-width: 80px;
            /* Force minimum width */
        }

        .bonus-row select:nth-of-type(2) {
            flex: 2;
            /* Frequency: Wide */
            min-width: 0;
        }

        /* --- SECTIONS (Cards) --- */
        .speech-options,
        .resume-options,
        .extra-options {
            background: var(--bg-card);
            border-radius: var(--radius-card);
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            text-align: left;
        }

        .resume-options,
        .extra-options {
            border-color: rgba(255, 255, 255, 0.05);
            margin-top: 15px;
            margin-bottom: 20px;
        }

        .category-header {
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 12px;
            font-weight: 900;
            color: #30D158;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }

        .category-header:first-child {
            margin-top: 0;
        }

        .switch-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
        }

        .switch-label {
            font-size: 14px;
            color: #fff;
            flex: 1;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
            flex-shrink: 0;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            transition: .4s;
            border-radius: 30px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: #30D158;
        }

        input:checked+.slider:before {
            transform: translateX(16px);
        }

        /* Custom Text Input (Read only trigger) */
        .text-input-trigger {
            width: 100%;
            background: #2a2a2c;
            border: 1px solid #444;
            color: #ccc;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 15px;
            margin-top: 5px;
            white-space: pre-wrap;
            overflow: visible;
            min-height: 80px;
            line-height: 1.4;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .text-input-trigger:active {
            background: #3a3a3c;
        }

        /* Custom Text Input (Real select for coach) */
        select.text-input {
            width: 100%;
            background: #2a2a2c;
            border: 1px solid #444;
            color: #ccc;
            padding: 8px;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 10px;
            margin-top: 2px;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right .7em top 50%;
            background-size: .65em auto;
        }

        /* --- COLLAPSIBLE (Resume only) --- */
        .collapsible-header {
            background: #2c2c2e;
            padding: 10px;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .collapsible-header:hover {
            background: #3a3a3c;
        }

        .collapsible-content {
            padding: 10px;
            background: #151516;
            border-radius: 6px;
            margin-top: 5px;
        }

        .collapsible-content.hidden {
            display: none;
        }

        .arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .open .arrow {
            transform: rotate(180deg);
        }


        /* --- BUTTONS --- */
        button.action-btn {
            width: 100%;
            padding: 20px;
            font-size: 20px;
            font-weight: 800;
            border: none;
            border-radius: var(--radius-btn);
            cursor: pointer;
            margin-top: 15px;
            margin-bottom: 30px;
            flex-shrink: 0;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            position: relative;
            overflow: hidden;
        }

        button.action-btn:active {
            transform: scale(0.96);
        }

        button.action-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.15), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }

        button.action-btn:hover::after {
            opacity: 1;
        }

        .btn-start {
            background: linear-gradient(135deg, #32d74b 0%, #28cd41 100%);
            color: #000;
            box-shadow: 0 8px 25px rgba(40, 205, 65, 0.4);
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn-start:hover {
            box-shadow: 0 12px 30px rgba(40, 205, 65, 0.5);
            transform: translateY(-2px);
        }

        .btn-view-schedule {
            display: none !important;
        }



        /* Updated Control Buttons */
        /* Updated Control Buttons */
        .controls-container {
            background: rgba(28, 28, 30, 0.6) !important;
            /* Glass effect */
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 25px !important;
            margin-bottom: 0 !important;
            gap: 20px !important;
        }

        .btn-control {
            flex: 1;
            height: 80px;
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: #fff;
            border-radius: 24px;
            /* More rounded */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.25, 1, 0.5, 1);
        }

        .btn-control:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        .btn-control.paused {
            background: rgba(255, 159, 10, 0.2);
            color: var(--accent-warm);
            border: 1px solid var(--accent-warm);
        }

        .btn-stop {
            color: var(--accent-danger);
            background: rgba(255, 69, 58, 0.15);
        }

        .btn-skip {
            font-size: 24px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 60px;
            /* Fixed width for small buttons */
            flex: 0 0 60px;
        }

        /* LIVE SCHEDULE TABLE */
        /* LIVE SCHEDULE TABLE (Timeline Style) */
        #live-schedule-container {
            width: 100%;
            background: var(--bg-main);
            /* Match body */
            margin-top: 0;
            padding: 20px 0 80px 0;
            border-top: none;
        }

        .live-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 8px;
            /* Gap between rows */
            padding: 0 15px;
        }

        .live-table th {
            text-transform: uppercase;
            font-size: 10px;
            color: var(--text-secondary);
            letter-spacing: 1px;
            padding-bottom: 10px;
            background: var(--bg-main);
        }

        .live-table td {
            padding: 16px;
            background: var(--bg-card);
            color: var(--text-primary);
            border: none;
        }

        .live-table tr td:first-child {
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
        }

        .live-table tr td:last-child {
            border-top-right-radius: 16px;
            border-bottom-right-radius: 16px;
        }

        .live-table tr.active-row td {
            background: #2C2C2E;
            color: #fff;
            box-shadow: 0 0 0 2px var(--accent-primary);
            /* Ring border */
        }

        .live-table tr.active-row td {
            border: none !important;
        }

        .live-table tr.active-row td:first-child {
            border-left: none;
        }

        /* Remove old border */

        .live-table tr.future-row td {
            opacity: 0.5;
            background: #111;
        }

        .live-table tr.past-row td {
            opacity: 0.2;
        }

        /* Audio Debug Log */
        #audio-debug-log {
            display: none;
            /* Hidden via user request */
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 320px;
            height: 150px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #444;
            border-radius: 8px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 8px;
            overflow-y: auto;
            z-index: 10000;
            pointer-events: none;
            /* display: flex; */
            flex-direction: column-reverse;
            /* Newest items at bottom */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
        }

        #audio-debug-log div {
            border-bottom: 1px solid #222;
            padding: 2px 0;
            white-space: pre-wrap;
        }

        /* Audio Debug Log */



        .live-table tr {
            cursor: pointer;
            transition: background 0.2s;
        }

        .live-table tr:active {
            background: #333;
        }


        /* High Z-Index for Modals */
        .modal-overlay,
        #exercise-selector-modal {
            z-index: 9999 !important;
            position: fixed;
            /* Ensure fixed positioning */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            /* Proper backdrop */
        }

        /* --- INFO BOX --- */
        .info-bar {
            background: #111;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid #333;
            flex-shrink: 0;
            margin-top: 5px;
            position: relative;
        }

        .btn-force-edit {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: #333;
            border: 1px solid #555;
            color: white;
            font-size: 12px;
            padding: 5px 10px;
            border-radius: 6px;
            cursor: pointer;
        }

        .exercise-click-target {
            padding: 8px 10px;
            border: 1px solid #333;
            border-radius: 6px;
            cursor: pointer;
            background: #222;
            color: #fff;
            min-height: 44px;
            /* Touch friendly */
            display: flex;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1);
            transition: background 0.1s;
        }

        .exercise-click-target:active {
            background: #444;
            transform: scale(0.98);
        }

        /* --- LISTS --- */
        .schedule-list-wrapper {
            flex: 1;
            text-align: left;
            background: #000;
            border-top: 1px solid #222;
            overflow-y: auto;
            min-height: 100px;
        }

        .schedule-item {
            padding: 10px;
            border-bottom: 1px solid #1a1a1a;
            color: #555;
            display: flex;
            align-items: center;
            font-size: 14px;
        }

        .schedule-item.active {
            color: #fff;
            background: #1c1c1e;
            border-left: 4px solid #30D158;
        }

        .col-time {
            width: 110px;
            font-family: monospace;
            color: #888;
            font-size: 12px;
            flex-shrink: 0;
        }

        .col-desc {
            flex: 1;
            padding: 0 8px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .col-dur {
            width: 40px;
            text-align: right;
            font-weight: bold;
            flex-shrink: 0;
        }

        /* --- TIMER SCREEN (GYM MODE) --- */
        #timer-screen {
            display: none;
            /* Scroll Fix v1.14: Restore full height container for scrolling */
            height: 100%;
            width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            flex-direction: column;
            padding-bottom: 20px;
        }

        /* PROGRESS RINGS */
        .timer-ring-container {
            position: relative;
            width: 80vw;
            max-width: 350px;
            aspect-ratio: 1;
            margin: 0 auto 10px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timer-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            /* Start at top */
            pointer-events: none;
        }

        /* --- EXERCISE SELECTOR MODAL --- */
        #exercise-selector-modal .modal-content {
            max-width: 500px;
            width: 95vw;
            height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 0;
            background: #1c1c1e;
            border: 1px solid #333;
        }

        .ex-modal-header {
            padding: 15px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ex-modal-body {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .ex-search-container {
            padding: 10px;
            background: #111;
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #ex-search-input {
            width: 100%;
            padding: 12px;
            background: #2c2c2e;
            border: none;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
        }

        .ex-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .ex-list-item {
            padding: 15px;
            border-bottom: 1px solid #2c2c2e;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ex-list-item:hover {
            background: #2c2c2e;
        }

        .ex-cat-tag {
            font-size: 10px;
            padding: 3px 6px;
            border-radius: 4px;
            background: #333;
            color: #aaa;
            margin-right: 10px;
        }

        .ex-detail-view {
            display: none;
            flex-direction: column;
            height: 100%;
            padding: 20px;
        }

        .ex-detail-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #30D158;
        }

        .ex-detail-meta {
            font-size: 13px;
            color: #888;
            margin-bottom: 15px;
        }

        .ex-detail-desc {
            font-size: 14px;
            line-height: 1.5;
            color: #ccc;
            margin-bottom: 20px;
            background: #222;
            padding: 10px;
            border-radius: 8px;
        }

        .ex-video-btn {
            background: #FF3B30;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            cursor: pointer;
            text-decoration: none;
            margin-bottom: 20px;
        }

        .ex-scope-section {
            margin-top: auto;
            border-top: 1px solid #333;
            padding-top: 15px;
        }

        .ex-scope-title {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 10px;
            display: block;
        }

        .ex-scope-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .scope-radio {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #2c2c2e;
            border-radius: 8px;
            cursor: pointer;
        }

        .scope-radio input {
            margin-right: 10px;
            accent-color: #30D158;
            transform: scale(1.2);
        }

        .scope-label-main {
            font-weight: bold;
            color: white;
            font-size: 14px;
        }

        .scope-label-sub {
            font-size: 11px;
            color: #888;
            display: block;
        }

        /* Ring Styles */
        .ring-bg-outer {
            fill: none;
            stroke: rgba(255, 255, 255, 0.05);
            stroke-width: 4;
        }

        .ring-val-outer {
            fill: none;
            stroke: var(--accent-secondary);
            stroke-width: 4;
            stroke-linecap: round;
            filter: drop-shadow(0 0 8px rgba(10, 132, 255, 0.5));
            /* Glow */
            transition: stroke-dashoffset 0.5s linear;
        }

        .ring-bg-inner {
            fill: none;
            stroke: rgba(255, 255, 255, 0.05);
            stroke-width: 8;
        }

        .ring-val-inner {
            fill: none;
            stroke: #BF5AF2;
            stroke-width: 8;
            stroke-linecap: round;
            filter: drop-shadow(0 0 10px rgba(191, 90, 242, 0.6));
            /* Glow */
            transition: stroke-dashoffset 0.2s linear;
        }

        /* Text inside ring */
        .gym-big-time {
            font-size: 28vw;
            font-weight: bold;
            font-variant-numeric: tabular-nums;
            line-height: 0.9;
            letter-spacing: -5px;
            text-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 2;
            pointer-events: none;
            margin: 0;
        }

        @media (min-width: 600px) {
            .gym-big-time {
                font-size: 140px;
            }
        }

        /* COUNTDOWN GLOW FIX (User Request) */
        #countdown {
            color: #ffffff !important;
            animation: epic-pulse 1s infinite ease-in-out;
            /* 60 BPM */
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            /* Neon Cyan base */
        }

        /* THE MAIN DISPLAY ZONE */
        .display-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            padding: 10px;
            position: relative;
        }

        .gym-phase-title {
            font-size: 8vw;
            /* Normal size for long text */
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 5px;
            opacity: 0.8;
            line-height: 1;
            position: relative;
            z-index: 1;
            pointer-events: none;
            transition: font-size 0.3s;
            /* Layout Fix: Reserve space for huge text */
            min-height: 14vw;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }

        .gym-phase-title.huge-text {
            font-size: 13vw;
        }

        .gym-phase-title.long-text {
            font-size: 5vw;
        }



        /* NEW STATS GRID STRUCTURE */
        .stats-wrapper {
            width: 95%;
            max-width: 600px;
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            position: relative;
            z-index: 50;
            pointer-events: none;
        }

        .stats-row-1 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .stats-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            /* CRITICAL: Re-enable clicks on the boxes */
            position: relative;
        }

        /* --- EDITABLE STYLES --- */
        .stat-box.editable {
            border: 2px solid #30D158;
            position: relative;
            z-index: 60;
        }

        .stat-box.editable:active {
            transform: scale(0.98);
            background: rgba(48, 209, 88, 0.2);
        }

        .edit-icon {
            position: absolute;
            top: 4px;
            right: 4px;
            font-size: 10px;
            color: #30D158;
        }

        .stat-label {
            font-size: 2.5vw;
            text-transform: uppercase;
            opacity: 0.8;
            font-weight: bold;
            margin-bottom: 2px;
            color: #ddd;
        }

        .stat-value {
            font-size: 6vw;
            /* Bigger as requested */
            font-weight: 900;
            font-variant-numeric: tabular-nums;
        }

        /* Fallback for very small or very large screens */
        @media (min-width: 600px) {
            .stat-label {
                font-size: 14px;
            }

            .stat-value {
                font-size: 36px;
            }

            .gym-phase-title {
                font-size: 40px;
            }

            .gym-phase-title.huge-text {
                font-size: 80px;
            }

            /* .gym-big-time {
                font-size: 180px;
            } */
        }

        .gym-next-info {
            font-size: 3vw;
            opacity: 0.7;
            margin-top: 20px;
            position: relative;
            z-index: 1;
            pointer-events: none;
        }

        .controls-container {
            flex: 0 0 100px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            width: 100%;
            background: rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 100;
            /* Highest priority */
            pointer-events: auto;
            gap: 15px;
            /* Spacing between big buttons */
        }

        /* --- PHASE COLORS (Backgrounds) --- */
        /* --- PRE-WORKOUT EPIC EFFECTS --- */
        @keyframes epic-pulse {
            0% {
                transform: scale(1);
                text-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
                /* Cyan */
            }

            50% {
                transform: scale(1.02);
                text-shadow: 0 0 40px rgba(0, 255, 255, 0.6), 0 0 10px rgba(0, 255, 255, 0.8);
                /* Cyan Intense */
            }

            100% {
                transform: scale(1);
                text-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
                /* Cyan */
            }
        }

        .epic-timer {
            animation: epic-pulse 1s infinite ease-in-out;
            /* 60 BPM */
            font-variant-numeric: tabular-nums;
        }

        .epic-overlay {
            background: radial-gradient(circle at center, #222 0%, #000 100%) !important;
        }

        body.mode-work {
            background-color: #30D158;
            color: black;
        }

        body.mode-work .progress-fill {
            background: black;
        }

        body.mode-work .stat-box {
            background: rgba(0, 0, 0, 0.15);
            border-color: rgba(0, 0, 0, 0.2);
        }

        body.mode-work .stat-box.editable {
            border-color: #000;
        }

        body.mode-work .edit-icon {
            color: #000;
        }

        body.mode-work .stat-label {
            color: rgba(0, 0, 0, 0.6);
        }

        body.mode-rest {
            background-color: #FF9F0A;
            color: black;
        }

        body.mode-rest .progress-fill {
            background: black;
        }

        body.mode-rest .stat-box {
            background: rgba(0, 0, 0, 0.15);
            border-color: rgba(0, 0, 0, 0.2);
        }

        body.mode-rest .stat-box.editable {
            border-color: #000;
        }

        body.mode-rest .edit-icon {
            color: #000;
        }

        body.mode-rest .stat-label {
            color: rgba(0, 0, 0, 0.6);
        }

        body.mode-switch {
            background-color: #BF5AF2;
            color: white;
        }

        body.mode-long {
            background-color: #0A84FF;
            color: white;
        }

        body.mode-prep {
            background-color: #1c1c1e;
            color: white;
        }

        body.mode-finish {
            background-color: #FFD60A;
            color: black;
        }

        body.mode-pause {
            background-color: #333;
            color: white;
        }

        /* --- MODALS --- */
        /* --- MODALS --- */
        #pause-modal,
        #calc-modal,
        #speech-edit-modal,
        #edit-scope-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-glass);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--bg-card);
            padding: 25px;
            border-radius: var(--radius-card);
            width: 90%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            color: var(--text-primary);
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* SPEECH MODAL FIX */
        #speech-edit-modal .modal-content {
            width: 98%;
            max-width: 98%;
            padding: 15px;
        }



        .modal-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin-top: 10px;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            text-align: left;
            position: relative;
        }

        .modal-btn .btn-subtext {
            display: block;
            font-size: 11px;
            font-weight: normal;
            opacity: 0.7;
            margin-top: 2px;
        }

        .calc-input {
            width: 80px;
            font-size: 24px;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            border: 1px solid #555;
            background: #222;
            color: white;
            margin-bottom: 15px;
        }

        .option-desc {
            font-size: 13px;
            color: #ccc;
            margin-top: 2px;
            font-weight: normal;
        }

        /* SPEECH EDIT TEXTAREA */
        #speech-edit-area {
            width: 100%;
            min-height: 350px;
            background: #222;
            border: 1px solid #555;
            color: white;
            font-size: 16px;
            padding: 15px;
            border-radius: 8px;
            resize: none;
            margin-bottom: 15px;
            font-family: inherit;
            box-sizing: border-box;
        }

        .hidden {
            display: none !important;
        }

        .active-card {
            border: 2px solid #30D158 !important;
            box-shadow: 0 0 25px rgba(48, 209, 88, 0.4);
            background: rgba(48, 209, 88, 0.08) !important;
            transform: scale(1.02);
            transition: all 0.5s ease;
            z-index: 5;
        }

        /* SAFETY: Prevent Timer Screen leaks if markup is broken */
        #setup-screen #timer-screen,
        #setup-screen .controls-container,
        #setup-screen #pause-modal {
            display: none !important;
        }

        /* TRANSPARENT INPUT STYLES */
        .transparent-input {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            z-index: 20;
            cursor: pointer;
            border: none;
            padding: 0;
            margin: 0;
            appearance: none;
        }

        /* --- GENERATOR MODAL STYLES --- */
        #generator-modal .modal-content {
            max-width: 500px;
            width: 95%;
            padding: 0;
            display: flex;
            flex-direction: column;
            background: #1c1c1e;
            height: 85vh;
        }

        .gen-section {
            padding: 15px;
            border-bottom: 1px solid #333;
        }

        .gen-section-title {
            font-size: 13px;
            font-weight: 900;
            color: #BF5AF2;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .gen-checkbox-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
        }

        .gen-checkbox-item {
            background: #2c2c2e;
            padding: 8px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            font-size: 12px;
            color: #ccc;
            cursor: pointer;
            user-select: none;
        }

        .gen-checkbox-item input {
            margin-right: 8px;
            accent-color: #BF5AF2;
        }

        .gen-radio-group {
            display: flex;
            background: #2c2c2e;
            border-radius: 8px;
            padding: 4px;
            margin-bottom: 5px;
        }

        .gen-radio-opt {
            flex: 1;
            text-align: center;
            padding: 8px;
            font-size: 12px;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .gen-radio-opt.active {
            background: #BF5AF2;
            color: white;
            font-weight: bold;
        }

        .gen-btn-generate {
            background: linear-gradient(135deg, #BF5AF2, #5E5CE6);
            color: white;
            border: none;
            padding: 15px;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 12px;
            margin: 15px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(191, 90, 242, 0.4);
        }

        /* --- SMART EXERCISE MENU --- */
        .exercise-menu-container {
            flex: 0 0 40px;
            position: relative;
        }

        .exercise-menu-trigger {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #2C2C2E;
            border: 1px solid #3A3A3C;
            border-radius: 8px;
            color: #30D158;
            font-size: 18px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .exercise-menu-trigger:active {
            background: #3A3A3C;
        }

        .exercise-dropdown {
            display: none;
            position: absolute;
            top: 110%;
            left: 0;
            width: 280px;
            /* Wider than trigger */
            max-height: 250px;
            overflow-y: auto;
            background: #1c1c1e;
            border: 1px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        .exercise-dropdown.active {
            display: block;
        }

        .menu-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #333;
            cursor: pointer;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:hover {
            background: #2c2c2e;
        }

        .menu-item img {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            margin-right: 10px;
            background: #000;
        }

        .menu-item-info {
            flex: 1;
        }

        .menu-item-name {
            color: white;
            font-size: 13px;
            font-weight: bold;
        }

        .menu-item-meta {
            color: #888;
            font-size: 11px;
        }
    </style>
</head>

<body>
    <!-- Hourglass Background -->
    <div id="hourglass-bg">
        <div id="hourglass-fill"></div>
    </div>

    <div id="setup-screen" class="container">

        <div class="logo-container">
            <img src="FNH logo.jpg" alt="FNH Logo" class="app-logo" onclick="applyFNHPreset()" style="cursor: pointer;">
        </div>

        <div class="header-row">
            <div class="app-header">
                FNH Timer <span class="version-tag"></span>
            </div>
            <div class="header-buttons">
                <button class="btn-header btn-reset" onclick="resetToDefaults()"> Reset</button>
                <button class="btn-header" style="background:#ddd; color:#000;" onclick="openPrintMenu()">
                    Cards</button>
                <button class="btn-header btn-dumbbell" onclick="openMaterialModal()"><span></span></button>
                <button class="btn-header btn-reset" style="background:#FF9F0A; color:white;"
                    onclick="applyTabataPreset()"> Tabata</button>
                <button class="btn-header btn-save" onclick="shareSettings()"> Save</button>
                <button class="btn-header btn-share-app" onclick="shareApp()"> Delen</button>
            </div>
        </div>

        <div style="font-size:12px; color:#666; text-transform:uppercase; margin-bottom:5px;">TIJDSINSTELLINGEN</div>

        <div class="compact-row">
            <div class="select-group">
                <label>Starttijd</label>
                <input type="time" id="startTimeValue" class="highlight-input"
                    onchange="syncTime('starttime'); saveToLocal();">
            </div>
            <div class="select-group">
                <label>Duur (min)</label>
                <input type="text" id="totalMin" class="highlight-input" readonly
                    style="text-align:center; cursor:default; caret-color:transparent;" value="--">
            </div>
            <div class="select-group">
                <label>Eindtijd</label>
                <input type="time" id="endTimeValue" class="highlight-input"
                    onchange="syncTime('endtime'); saveToLocal();">
            </div>
        </div>

        <div class="category-header">Opbouw Training</div>
        <div id="rounds-container" style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px;">
            <!-- Dynamic Rounds will be rendered here -->
        </div>

        <button class="action-btn" onclick="addRound()"
            style="font-size: 16px; padding: 15px; background: #333; border: 1px dashed #555;">
            + Ronde Toevoegen
        </button>

        <!-- Hidden inputs to prevent JS errors until fully refactored -->
        <div style="display:none;">
            <input id="rounds" value="1">
            <input id="exercises" value="1">
            <input id="sets" value="1">
            <input id="roundRestSec" value="60">
            <input id="exerciseRestSec" value="15">
            <input id="restSec" value="30">
        </div>

        <!-- Legacy 'Work Time per Set' bar removed as per request -->

        <button class="action-btn btn-start" id="btn-start-app" onclick="startWorkout()">START TRAINING</button>





        <div class="resume-options" style="display:none;">
            <div class="collapsible-header resume-header open" onclick="toggleSection('sec-resume')">
                <div>Beginnen vanaf moment in training</div>
                <span class="arrow"></span>
            </div>
            <div id="sec-resume" class="collapsible-content">
                <div style="font-size:12px; color:#aaa; margin-bottom:8px;">Vul hieronder in waar je wilt starten.</div>

                <div class="compact-row">
                    <div class="select-group">
                        <label>Ronde</label>
                        <select id="start-round" class="compact-select"
                            onchange="saveToLocal(); calculateRealTime();"></select>
                    </div>
                    <div class="select-group">
                        <label>Oefening</label>
                        <select id="start-ex" class="compact-select"
                            onchange="saveToLocal(); calculateRealTime();"></select>
                    </div>
                    <div class="select-group">
                        <label>Set</label>
                        <select id="start-set" class="compact-select"
                            onchange="saveToLocal(); calculateRealTime();"></select>
                    </div>
                </div>

            </div>
        </div>



        <div style="text-align:left; padding:5px 0; font-size:12px; color:#666; margin-top:20px;">VOORBEELD SCHEMA
            (VANAF NU):</div>
        <div id="preview-list" class="schedule-list-wrapper">
        </div>

        <div class="intro-banner">
            <div class="intro-title"> Welcome to the Friday Night Hawks!</div>
            <div class="intro-text">
                De legendarische triathlon: <b>Spinning   Bootcamp   Zwemmen </b>.
                <br>Iedere vrijdagavond om 19:45. We sluiten af met <b>bitterballen</b> & gezelligheid! 
            </div>
        </div>

    </div>

    <div id="timer-screen" style="display:none !important;">




        <div class="display-zone">
            <div class="gym-phase-title" id="gym-phase-title">KLAARMAKEN</div>

            <div class="timer-ring-container">
                <svg class="timer-svg" viewBox="0 0 100 100">
                    <!-- Outer Ring (Total) -->
                    <circle class="ring-bg-outer" cx="50" cy="50" r="48"></circle>
                    <circle class="ring-val-outer" id="ring-total" cx="50" cy="50" r="48" stroke-dasharray="301.6"
                        stroke-dashoffset="0"></circle>

                    <!-- Inner Ring (Step) -->
                    <circle class="ring-bg-inner" cx="50" cy="50" r="40"></circle>
                    <circle class="ring-val-inner" id="ring-step" cx="50" cy="50" r="40" stroke-dasharray="251.3"
                        stroke-dashoffset="0"></circle>
                </svg>
                <div class="gym-big-time" id="countdown">10</div>
                <div id="circle-remaining"
                    style="position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%); font-size: 16px; color: #888; font-weight: bold;">
                    --m</div>
                <!-- NEW PERCENTAGE DISPLAY -->
                <div id="ring-percent"
                    style="position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%); font-size: 14px; color: #555; font-weight: bold;">
                    0%
                </div>
            </div>

            <div class="stats-wrapper" id="gym-stats-container">
                <div class="stats-row-1">
                    <div class="stat-box editable">
                        <select id="jump-round" class="transparent-input" onchange="handleJump()"></select>
                        <div class="edit-icon"></div>
                        <div class="stat-label">Ronde</div>
                        <div class="stat-value" id="val-round">-</div>
                    </div>
                    <div class="stat-box editable">
                        <select id="jump-exercise" class="transparent-input" onchange="handleJump()"></select>
                        <div class="edit-icon"></div>
                        <div class="stat-label">Oefening</div>
                        <div class="stat-value" id="val-exercise">-</div>
                    </div>
                    <div class="stat-box editable">
                        <select id="jump-set" class="transparent-input" onchange="handleJump()"></select>
                        <div class="edit-icon"></div>
                        <div class="stat-label">Set</div>
                        <div class="stat-value" id="val-set">-</div>
                    </div>
                </div>
                <div class="stats-row-2">
                    <div class="stat-box editable" onclick="openLiveEndAdjustment()" style="cursor:pointer;">
                        <div class="edit-icon"></div>
                        <div class="stat-label">Einde</div>
                        <div class="stat-value" id="val-endtime">--:--</div>
                    </div>
                    <div class="stat-box editable" onclick="openLiveWorkAdjustment()" style="cursor:pointer;">
                        <div class="edit-icon"></div>
                        <div class="stat-label">Werktijd</div>
                        <div class="stat-value" id="val-worktime">--s</div>
                    </div>
                </div>

                <div class="stats-row-3" style="display:flex; justify-content:space-between; margin-top:10px; gap:8px;">
                    <div class="stat-box editable" onclick="openLiveRestAdjustment('rest')"
                        style="cursor:pointer; flex:1;">
                        <div class="edit-icon"></div>
                        <div class="stat-label">Rust</div>
                        <div class="stat-value" id="val-rest">--s</div>
                    </div>
                    <div class="stat-box editable" onclick="openLiveRestAdjustment('rest-exercise')"
                        style="cursor:pointer; flex:1;">
                        <div class="edit-icon"></div>
                        <div class="stat-label">Wissel</div>
                        <div class="stat-value" id="val-switch">--s</div>
                    </div>
                    <div class="stat-box editable" onclick="openLiveRestAdjustment('rest-long')"
                        style="cursor:pointer; flex:1;">
                        <div class="edit-icon"></div>
                        <div class="stat-label">Pauze Ronde</div>
                        <div class="stat-value" id="val-pause-round">--s</div>
                    </div>
                </div>
            </div>

            <div class="gym-next-info" id="gym-next-info">Hierna: Rust</div>
            <!-- NOW PLAYING (Relocated) -->
            <div id="gym-now-playing"
                style="font-size:13px; color:#888; margin-top:5px; height:18px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
            </div>
        </div>

        <div class="controls-container">
            <button class="btn-control btn-skip" onclick="handlePrevClick()"></button>
            <button class="btn-control btn-pause" id="btn-pause" onclick="handlePauseClick()"></button>
            <button class="btn-control btn-skip" onclick="handleNextClick()"></button>
            <button class="btn-control btn-stop" onclick="confirmStop()"></button>
        </div>

        <button onclick="toggleLiveEdit()" class="action-btn"
            style="margin-top:20px; background:#333; font-size:14px; padding:10px;">
             Bewerk Schema (Training loopt door)
        </button>

        <div id="live-schedule-container">
            <table class="live-table" id="live-table">
                <thead>
                    <tr>
                        <th style="width:60px;">Tijd</th>
                        <th>Activiteit</th>
                        <th style="width:50px; text-align:right;">Duur</th>
                    </tr>
                </thead>
                <tbody id="live-table-body"></tbody>
            </table>
        </div>
    </div>

    <div id="pause-modal" style="display:none;">
        <div class="modal-content">
            <h2 id="pause-modal-title" style="margin-top:0;">PAUZE VOORBIJ</h2>
            <p id="pause-msg-p" style="color:#aaa; font-size:13px; margin-bottom:15px;">Je hebt <span
                    id="pause-duration-display" style="color:white; font-weight:bold;">0s</span> gepauzeerd.</p>



            <button class="modal-btn"
                style="background: linear-gradient(135deg, #32d74b 0%, #28cd41 100%); color: #000; font-weight: 800; border: none; box-shadow: 0 5px 15px rgba(50, 215, 75, 0.4);"
                onclick="resolvePause('push')">
                 Eindtijd verzetten
                <span class="btn-subtext" id="btn-text-push" style="color: rgba(0,0,0,0.6); font-weight:600;">...</span>
                <div style="font-size: 11px; font-weight: normal; opacity: 0.8; margin-top: 2px;">Werk- en rusttijden
                    blijven intact</div>
            </button>

            <button class="modal-btn" id="btn-catch-work" style="background: #0A84FF; color: white;"
                onclick="resolvePause('work')">
                 Inhalen via Werktijd
                <span class="btn-subtext" id="btn-text-work">...</span>
            </button>

            <button class="modal-btn" id="btn-catch-rest" style="background: #FF9F0A; color: black;"
                onclick="resolvePause('rest')">
                 Inhalen via Rust (Set)
                <span class="btn-subtext" id="btn-text-rest">...</span>
            </button>

            <button class="modal-btn" id="btn-catch-switch" style="background: #BF5AF2; color: white;"
                onclick="resolvePause('switch')">
                 Inhalen via Wissels
                <span class="btn-subtext" id="btn-text-switch">...</span>
            </button>

            <button class="modal-btn" id="btn-catch-round" style="background: #0A84FF; color: white;"
                onclick="resolvePause('round')">
                 Inhalen via Ronde Rust
                <span class="btn-subtext" id="btn-text-round">...</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelPause()">
                 Annuleren (Terug)
            </button>
        </div>
    </div>



    <div id="speech-edit-modal">
        <div class="modal-content">
            <h3 style="margin-top:0;">Spraak aanpassen</h3>
            <div style="font-size:12px; color:#aaa; margin-bottom:10px;">Gebruik | voor variatie</div>
            <textarea id="speech-edit-area"></textarea>
            <button class="modal-btn" style="background: #30D158; color: black;" onclick="saveSpeechEdit()">
                Opslaan</button>
            <button class="modal-btn" style="background: #333; color: white; margin-top:10px;"
                onclick="closeSpeechEdit()">Annuleren</button>
        </div>
    </div>

    <div id="live-end-adjust-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
            <h2 style="margin-top:0;">Eindtijd Verzetten</h2>
            <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de eindtijd aan en kies hoe het verschil
                verdeeld wordt over de <b>resterende</b> oefeningen.</p>

            <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                <div style="font-size:12px; color:#888;">Nieuwe Eindtijd</div>
                <input type="time" id="live-adjust-input"
                    style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:100%; font-family: 'Outfit', sans-serif;"
                    onchange="calcLiveEndDiff()">
                <div id="live-adjust-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0m 0s</div>
            </div>

            <button class="modal-btn" id="btn-live-work" style="background: #0A84FF; color: white;"
                onclick="applyLiveEndAdjustment('work')">
                 Verdeel over Werk
                <span class="btn-subtext" id="sub-live-work">Effect: +/- 0s per set</span>
            </button>

            <button class="modal-btn" id="btn-live-rest" style="background: #FF9F0A; color: black;"
                onclick="applyLiveEndAdjustment('rest')">
                 Verdeel over Rust
                <span class="btn-subtext" id="sub-live-rest">Effect: +/- 0s per set</span>
            </button>

            <button class="modal-btn" id="btn-live-switch" style="background: #BF5AF2; color: white;"
                onclick="applyLiveEndAdjustment('switch')">
                 Verdeel over Wissels
                <span class="btn-subtext" id="sub-live-switch">Effect: +/- 0s per wissel</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelLiveAdjustment()">
                 Annuleren
            </button>
        </div>
    </div>

    <div id="live-work-adjust-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
            <h2 style="margin-top:0;">Werktijd Aanpassen</h2>
            <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de tijd per set aan en kies hoe het verschil
                verrekend wordt.</p>

            <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                <div style="font-size:12px; color:#888;">Nieuwe Werktijd</div>
                <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveWorkInput(-5)">-5</button>
                    <input type="number" id="live-work-input" value="45"
                        style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:80px; font-family: 'Outfit', sans-serif;"
                        onchange="calcLiveWorkDiff()">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveWorkInput(5)">+5</button>
                </div>
                <div id="live-work-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0s per set</div>
            </div>

            <button class="modal-btn" id="btn-work-push" style="background: #0A84FF; color: white;"
                onclick="applyLiveWorkAdjustment('push')">
                 Verzet Eindtijd
                <span class="btn-subtext" id="sub-work-push">Eindtijd schuift op met Xm</span>
            </button>

            <button class="modal-btn" id="btn-work-rest" style="background: #FF9F0A; color: black;"
                onclick="applyLiveWorkAdjustment('rest')">
                 Compenseer met Rust
                <span class="btn-subtext" id="sub-work-rest">Rust wordt X seconden</span>
            </button>

            <button class="modal-btn" id="btn-work-switch" style="background: #BF5AF2; color: white;"
                onclick="applyLiveWorkAdjustment('switch')">
                 Compenseer met Wissels
                <span class="btn-subtext" id="sub-work-switch">Wissel wordt X seconden</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelLiveWorkAdjustment()">
                 Annuleren
            </button>
        </div>
    </div>

    <div id="live-rest-adjust-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="width:90%; max-width:400px; text-align:center;">
            <h2 style="margin-top:0;"><span id="live-rest-type-label">Rust</span> Aanpassen</h2>
            <p style="color:#aaa; font-size:13px; margin-bottom:15px;">Pas de tijd aan en kies hoe het verschil
                verrekend wordt.</p>

            <div style="background:#2c2c2e; padding:15px; border-radius:10px; margin-bottom:20px;">
                <div style="font-size:12px; color:#888;">Nieuwe Tijd</div>
                <div style="display:flex; align-items:center; justify-content:center; gap:10px;">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveRestInput(-5)">-5</button>
                    <input type="number" id="live-rest-input" value="10"
                        style="font-size:32px; background:transparent; border:none; color:white; font-weight:bold; text-align:center; width:80px; font-family: 'Outfit', sans-serif;"
                        onchange="calcLiveRestDiff()">
                    <button class="modal-btn" style="width:40px; height:40px; padding:0; background:#444;"
                        onclick="adjustLiveRestInput(5)">+5</button>
                </div>
                <div id="live-rest-diff" style="margin-top:5px; font-weight:bold; color:#0A84FF;">+0s per keer</div>
            </div>

            <button class="modal-btn" id="btn-rest-push" style="background: #0A84FF; color: white;"
                onclick="applyLiveRestAdjustment('push')">
                 Verzet Eindtijd
                <span class="btn-subtext" id="sub-rest-push">Eindtijd schuift op met Xm</span>
            </button>

            <button class="modal-btn" id="btn-rest-work" style="background: #FF9F0A; color: black;"
                onclick="applyLiveRestAdjustment('work')">
                 Compenseer met Werk
                <span class="btn-subtext" id="sub-rest-work">Werk wordt X seconden</span>
            </button>

            <button class="modal-btn" style="background: #333; color: #888; margin-top:15px; border:1px solid #444;"
                onclick="cancelLiveRestAdjustment()">
                 Annuleren
            </button>
        </div>
    </div>



    <div id="exercise-selector-modal" class="modal-overlay"
        style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content"
            style="max-width:400px; padding:0; overflow:hidden; display:flex; flex-direction:column; height:80vh; max-height:600px; width:95%;">

            <!-- Header -->
            <div
                style="padding:15px; background:#1c1c1e; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; flex-shrink:0;">
                <h3 id="ex-modal-title" style="margin:0; font-size:16px; color:white;">Kies Oefening</h3>
                <div style="font-size:24px; cursor:pointer; padding:5px;" onclick="closeExerciseSelector()"></div>
            </div>

            <!-- Hidden Inputs (Needed for Logic) -->
            <input type="hidden" id="edit-round-idx">
            <input type="hidden" id="edit-ex-idx">
            <input type="hidden" id="edit-set-idx">
            <input type="hidden" id="edit-new-val">

            <!-- List View -->
            <div id="ex-list-view" style="flex:1; display:flex; flex-direction:column; overflow:hidden;">

                <!-- Filters -->
                <div
                    style="padding:10px 10px 0 10px; background:#000; flex-shrink:0; display:flex; flex-direction:column; gap:10px;">
                    <select id="filter-category"
                        style="width:100%; padding:8px; border-radius:6px; background:#333; color:white; border:none; font-size:14px;"
                        onchange="filterExercises()">
                        <option value="">Alle Categorien</option>
                    </select>
                    <select id="filter-material"
                        style="width:100%; padding:8px; border-radius:6px; background:#333; color:white; border:none; font-size:14px;"
                        onchange="filterExercises()">
                        <option value="">Alle Materialen</option>
                    </select>
                </div>

                <div style="padding:10px; background:#000; flex-shrink:0;">
                    <input type="text" id="ex-search-input" placeholder="Zoek oefening..."
                        style="width:100%; padding:12px; border-radius:8px; border:none; background:#333; color:white; font-size:16px;"
                        onkeyup="filterExercises()">
                </div>
                <ul id="ex-list-ul"
                    style="list-style:none; padding:0; margin:0; overflow-y:auto; flex:1; -webkit-overflow-scrolling: touch;">
                    <!-- JS Populated -->
                </ul>
            </div>



            <!-- Setup Screen -->
            <!-- Detail View -->
            <div id="ex-detail-view"
                style="display:none; flex:1; flex-direction:column; padding:20px; overflow-y:auto; background:#111;">
                <h2 id="detail-tit" style="margin-top:0; color:white;">Oefening</h2>
                <span id="detail-meta"
                    style="color:#30D158; font-size:14px; margin-bottom:10px; display:inline-block; border:1px solid #30D158; padding:2px 6px; border-radius:4px;">Type</span>

                <div style="background:#222; padding:15px; border-radius:8px; margin: 15px 0;">
                    <p id="detail-desc" style="color:#ccc; font-size:14px; line-height:1.4; margin:0;">Instructies...
                    </p>
                </div>

                <a id="detail-vid-btn" href="#" target="_blank" class="modal-btn"
                    style="text-decoration:none; display:flex; justify-content:center; align-items:center; margin-bottom:20px; flex-shrink:0; padding:0; background:transparent; border:none; position:relative;">
                    <img id="detail-vid-thumb"
                        style="width:100%; border-radius:8px; display:none; object-fit:cover; aspect-ratio:16/9; border:1px solid #333;" />
                    <span id="detail-vid-fallback"
                        style="background:#5856D6; color:white; width:100%; padding:15px; border-radius:12px; text-align:center;">
                        Bekijk Video</span>
                </a>



                <div style="background:#222; padding:15px; border-radius:8px; margin-bottom:20px; flex-shrink:0;">
                    <div style="font-size:12px; color:#888; margin-bottom:10px; text-transform:uppercase;">Wijziging
                        toepassen op:</div>

                    <label style="display:flex; align-items:center; margin-bottom:15px; cursor:pointer;">
                        <input type="radio" name="scope_sel" value="all_rounds" checked
                            style="margin-right:15px; transform:scale(1.2);">
                        <div>
                            <div style="font-weight:bold; color:white;">Totaal (Alle Rondes)</div>
                            <div style="font-size:11px; color:#aaa;">Vervang deze oefening in het hele schema</div>
                        </div>
                    </label>

                    <label style="display:flex; align-items:center; margin-bottom:15px; cursor:pointer;">
                        <input type="radio" name="scope_sel" value="set_all_rounds"
                            style="margin-right:15px; transform:scale(1.2);">
                        <div>
                            <div style="font-weight:bold; color:white;">Alleen Set <span id="scope-set-force">1</span>
                                (Alle Rondes)</div>
                            <div style="font-size:11px; color:#aaa;">Bijv. alleen de 1e set van elke ronde</div>
                        </div>
                    </label>

                    <label style="display:flex; align-items:center; cursor:pointer;">
                        <input type="radio" name="scope_sel" value="single"
                            style="margin-right:15px; transform:scale(1.2);">
                        <div>
                            <div style="font-weight:bold; color:white;">Alleen DIT blokje</div>
                            <div style="font-size:11px; color:#aaa;">Eenmalige wijziging voor dit moment</div>
                        </div>
                    </label>
                </div>

                <div style="display:flex; gap:10px; margin-top:auto;">
                    <button class="modal-btn" style="background:#333; flex:1;" onclick="backToExList()">Terug</button>
                    <button class="modal-btn" style="background:#30D158; color:black; flex:1;"
                        onclick="confirmExerciseSelection()">Bevestigen</button>
                </div>
            </div>

        </div>
    </div>



    <!-- Validation Modal -->
    <div id="validation-modal" class="modal" style="display:none;">
        <div class="modal-content">
            <h3>Audio Bestanden Controleren</h3>
            <p id="validation-status">Bezig met controleren...</p>
            <ul id="validation-list"
                style="text-align:left; font-size:12px; color:#ff453a; max-height:200px; overflow-y:auto; margin:10px 0;">
            </ul>
            <div class="modal-buttons">
                <button class="btn-primary"
                    onclick="document.getElementById('validation-modal').style.display='none'">OK</button>
            </div>
        </div>
    </div>


    <!-- Audio Debug Log -->


    <input type="time" id="hidden-endtime-input" onchange="handleNewEndTime(this.value)" style="display:none;">

    <!-- Material Selector Modal -->
    <div id="material-modal">
        <div class="material-content">
            <div class="material-header">
                <button class="btn-close-modal" onclick="closeMaterialModal()"></button>
                <div class="material-title">Kies Materiaal & Oefening</div>
            </div>

            <div class="material-body">
                <!-- Section 1: Materials -->
                <div class="material-filters" id="material-filters">
                    <!-- JS Populated -->
                </div>

                <!-- Split View -->
                <div class="material-split-view">
                    <!-- List -->
                    <div class="exercise-list-col">
                        <div id="material-ex-list">
                            <!-- JS Populated -->
                        </div>
                    </div>

                    <!-- Preview -->
                    <div class="exercise-preview-col">
                        <div id="preview-content">
                            <img id="prev-img" class="preview-image" src="" style="display:none;">
                            <div id="prev-title" class="preview-title">Selecteer een oefening</div>
                            <div id="prev-meta" class="preview-meta">...</div>
                            <div id="prev-desc" class="preview-desc">Klik op een filter of oefening om details te zien.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Print Station Cards Modal -->
    <div id="print-modal" class="modal"
        style="display:none; z-index:10001; justify-content:center; align-items:center;">
        <div class="modal-content"
            style="max-width:400px; text-align:left; background:#1c1c1e; border-radius:24px; padding:25px; border:1px solid #333;">
            <h3 style="margin-top:0; color:#30D158; text-transform:uppercase;">Station Cards Printen </h3>

            <label style="color:#aaa; font-size:12px; font-weight:bold; margin-top:15px; display:block;">Ronde
                Selectie:</label>
            <select id="print-round-select" class="text-input"
                style="width:100%; margin-bottom:15px; background:#111; color:white; border:1px solid #333; padding:10px; border-radius:8px;">
                <!-- Populated by JS -->
            </select>

            <label style="color:#aaa; font-size:12px; font-weight:bold; display:block;">Sets Modus:</label>
            <select id="print-set-mode" class="text-input"
                style="width:100%; margin-bottom:25px; background:#111; color:white; border:1px solid #333; padding:10px; border-radius:8px;">
                <option value="first">Alleen Eerste Set (1 kaart p/oef)</option>
                <option value="all">Alle Sets (Meerdere kaarten)</option>
            </select>

            <button class="modal-btn" style="background:#30D158; color:black; text-align:center; font-weight:900;"
                onclick="startPrintJob()">
                Genereren (PDF Downloaden)
            </button>
            <button class="modal-btn"
                style="background:transparent; border:1px solid #333; color:#aaa; margin-top:10px; text-align:center;"
                onclick="document.getElementById('print-modal').style.display='none'">
                Annuleren
            </button>
        </div>
    </div>





    <script>
        const APP_VERSION = "1.32.46"; // Restored & Incremented
        // GLOBAL START TIME REFERENCE
        // We use this to calculate sync when returning from "Edit Mode"
        let globalWorkoutStartVal = null; // Date.now() timestamp
        let isWorkoutActive = false;

        // --- v1.16: SIMPLIFIED AUDIO (MP3 ONLY) ---
        // --- VARIABELEN ---
        let audioMode = 'speech';
        let speechPlaylists = {};
        let editingSpeechKey = null;
        let customNames = {};
        let customDetails = {}; // Stores per-exercise overrides (img, check #, etc.)
        let customWorkTimes = {}; // Format: { "rX-eY-sZ": seconds }
        let roundExercises = {}; // Format: { roundIndex: { exerciseIndex: { setIndex: exerciseName } } }
        let failedAudioKeys = new Set(); // Cache for missing MP3s

        // CONTAINERS
        // HARDE FALLBACK DEFAULTS (Zodat de app altijd werkt)
        const appDefaults = {
            rounds: 2, exercises: 6, sets: 2,
            restSec: 20, exerciseRestSec: 30, roundRestSec: 90,
            totalMin: 30,
            coachPreset: 'tabataman', // Default to MP3
            bonuses: [
                { name: "Bonus 1", duration: 0, freq: "start_round" },
                { name: "Bonus 2", duration: 0, freq: "start_round" },
                { name: "Bonus 3", duration: 0, freq: "start_round" }
            ]
        };

        const coachPresets = {
            'tabataman': {
                use_mp3: true,
                variants: {
                    'prep_countdown': 1, // Only 1 found
                    'finish': 1,
                    'mile_end': 1, 'mile_half': 1, 'mile_lastround': 1, 'mile_start': 1,
                    'prep_intro': 1,
                    'rest_round_15s': 1, 'rest_round_start': 1,
                    'rest_set_start': 1, 'rest_set_tips': 1,
                    'rest_switch_10s': 1, 'rest_switch_start': 1,
                    'work_start': 4, // Found 4 variants!
                    'work_halfway': 1,
                    'work_30s': 1, 'work_10s': 1
                }
            },
            'eva': {
                use_mp3: true,
                variants: {
                    'prep_countdown': 1,
                    'finish': 1,
                    'mile_end': 1, 'mile_half': 1, 'mile_start': 1,
                    'prep_intro': 1,
                    'rest_round_15s': 1, 'rest_round_start': 1,
                    'rest_set_start': 1, 'rest_set_tips': 1,
                    'rest_switch_10s': 1, 'rest_switch_start': 1,
                    'work_start': 4,
                    'work_halfway': 1,
                    'work_30s': 1, 'work_10s': 1
                }
            }
        };


        let currentCoachName = "Tabataman (Standaard)";

        let speechSettings = {}; // This will now only hold the current coach's settings (use_mp3: true)

        // UI Config (still used for validation and structure, but not for TTS text)
        const uiConfig = [
            { header: "Voorbereiding" },
            { id: "prep_intro", label: "Introductie tekst", type: "text" },
            { id: "prep_countdown", label: "Aftellen (3, 2, 1)", type: "bool" },
            { header: "Tijdens Oefening (Werken)" },
            { id: "work_start", label: "Start commando", type: "text" },
            { id: "work_halfway", label: "Melding halverwege", type: "text" },
            { id: "work_30s", label: "Nog 30 seconden", type: "text" },
            { id: "work_10s", label: "Nog 10 seconden", type: "text" },

            { header: "Tijdens Rust (Set)" },
            { id: "rest_set_start", label: "Rust commando", type: "text" },
            { id: "rest_set_tips", label: "Willekeurige tips (ademhaling/drinken)", type: "bool" },
            { header: "Tijdens Rust (Wissel)" },
            { id: "rest_switch_start", label: "Wissel commando", type: "text" },
            { id: "rest_switch_info", label: "Noem volgende oefening nummer", type: "bool" },
            { id: "rest_switch_10s", label: "Waarschuwing 10s voor einde", type: "text" },
            { header: "Tijdens Rust (Ronde)" },
            { id: "rest_round_start", label: "Grote pauze commando", type: "text" },
            { id: "rest_round_info", label: "Noem volgende ronde nummer", type: "bool" },
            { id: "rest_round_15s", label: "Waarschuwing 15s voor einde", type: "text" },
            { header: "Mijlpalen & Einde" },
            { id: "mile_start", label: "25% (Goede start)", type: "text" },
            { id: "mile_half", label: "50% (Helft)", type: "text" },
            { id: "mile_end", label: "75% (Eindsprint)", type: "text" },
            { id: "work_start_lastround", label: "Start laatste oefening", type: "text" },
            { id: "finish", label: "Einde training", type: "text" }
        ];

        // GLOBAL STATE
        // AUDIO_VARIANTS moved to coachPresets
        let audioPlaylists = {}; // Stores the shuffled queue per key: { 'prep_countdown': [2, 4, 1, 3] }

        let WORKOUT_DB = []; // Will be loaded from JSON
        let schedule = [];
        let milestonesTriggered = { m25: false, m50: false, m75: false };
        let workTimeSec = 0, restTimeSec = 0, exerciseRestSec = 0, roundRestSec = 0;
        let currentIndex = 0;
        let timerInterval;
        let isPaused = false;
        window.lastStepChangeTime = 0; // SAFETY: Initialize global anchor

        // Load Database
        // Cache-busting: append timestamp
        // Check for local file protocol
        if (window.location.protocol === 'file:') {
            alert(" LET OP: Je opent de app lokaal (file://).\n\nVanwege beveiliging in browsers kan de database NIET geladen worden.\nGebruik de online versie of een lokale webserver.");
        }

        // Load Database
        // Cache-busting: append timestamp
        fetch('workoutdatabase.json?v=' + new Date().getTime())
            .then(response => response.json())
            .then(data => {
                WORKOUT_DB = data;
                console.log("Workout Database Loaded:", WORKOUT_DB.length, "items");
            })
            .catch(err => console.error("Failed to load workout database:", err));
        let pauseStartTime = 0;
        let workoutStartTime, targetEndTimeDate;
        let totalWorkSetsGlobal = 0;
        let audioCtx;
        let currentPauseDuration = 0;

        // HELPER: Get Bonus Data
        function getBonusData(i) {
            return {
                name: document.getElementById(`bonus${i}-name`).value || `Bonus ${i}`,
                min: parseInt(document.getElementById(`bonus${i}-duration`).value) || 0,
                freq: document.getElementById(`bonus${i}-freq`).value,
                id: i
            };
        }

        // HELPER: Detect iOS
        function isIOS() {
            return (
                /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                (navigator.userAgent.includes("Mac") && "ontouchend" in document)
            );
        }

        if (isIOS()) {
            console.log("Dit is een iOS apparaat (iPhone of iPad)");
        }

        function applyVersionToUI() {
            // Update Title
            document.title = `Friday-night-hawk-s Timer v${APP_VERSION}`;
            // Update all elements with class "version-tag"
            document.querySelectorAll('.version-tag').forEach(el => {
                el.innerText = `v${APP_VERSION}`;
            });
        }

        // --- ROBUSTE FUNCTIE OM DATA TE LADEN ---
        // --- ROBUSTE FUNCTIE OM DATA TE LADEN ---
        async function initApp() {
            const select = document.getElementById('coach-preset-live'); // UPDATED: Target Live Select
            if (select) {
                select.innerHTML = '<option value="loading" disabled selected>Laden...</option>';

                const addOption = (id, name) => {
                    if (!select.querySelector(`option[value="${id}"]`)) {
                        const opt = document.createElement('option');
                        opt.value = id; opt.text = name;
                        select.appendChild(opt);
                    }
                };

                // 1. Init Defaults (Skipped external fetch, usage hardcoded)

                // 2. Probeer Coaches
                for (const coachId in coachPresets) {
                    let displayName = coachId.charAt(0).toUpperCase() + coachId.slice(1);
                    if (coachId === 'tabataman') displayName = 'TabataMan (Actief)';
                    if (coachId === 'eva') displayName = 'Eva (Nederlands Energiek)';
                    // Generic fallback name fix
                    if (coachId === 'default') displayName = "Standaard (Tabataman)";
                    if (coachId === 'drill_sergeant') displayName = "Drill Sergeant (Intens)";
                    if (coachId === 'zen_master') displayName = "Zen Master (Rust)";

                    addOption(coachId, displayName);
                }

                // Clean up dropdown UI
                const loadingOpt = select.querySelector('option[value="loading"]');
                if (loadingOpt) loadingOpt.remove();
            }

            // 3. PAS NU DE WAARDEN TOE
            finalizeInit();
        }

        function updateBonusVisibility() {
            // Bonus UI removed. Function kept empty for compatibility if called elsewhere.
        }

        function finalizeInit() {
            const select = document.getElementById('coach-preset-live'); // UPDATED

            // Selecteer standaard uit defaults, of fallback op eerste in lijst
            let targetPreset = appDefaults.coachPreset || 'tabataman';

            // If the target preset doesn't exist (shouldn't happen with hardcoded presets),
            // or if the select value isn't set, default to 'tabataman'.
            if (select && (!coachPresets[targetPreset] || !select.querySelector(`option[value="${targetPreset}"]`))) {
                targetPreset = 'tabataman';
            }

            if (select) select.value = targetPreset;
            if (!speechSettings || Object.keys(speechSettings).length === 0) {
                speechSettings = JSON.parse(JSON.stringify(coachPresets[targetPreset]));
            }

            loadFromLocal();
            checkForSharedSettings();

            // Generate Toggles
            renderAudioToggles();

            // Zet inputs op basis van defaults (als ze nog niet zijn overschreven door local)
            // Let op: loadFromLocal overschrijft dit weer als er iets is opgeslagen.
            // Als er NIETS is opgeslagen, willen we de defaults in de UI zien:
            if (!localStorage.getItem('fnh_settings_v8')) {
                applyDefaultsToUI();
            }

            // Sync tijd en calculatie
            if (!document.getElementById('endTimeValue').value) {
                syncTime('duration');
            }
            calculateRealTime();
            updateBonusVisibility();

            // Show mix mode on iOS
            if (isIOS()) {
                const mixC = document.getElementById('ios-mix-container');
                if (mixC) mixC.style.display = 'block';
            }
        }

        function applyDefaultsToUI() {
            const setVal = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.value = val;
            };

            setVal('rounds', appDefaults.rounds);
            setVal('exercises', appDefaults.exercises);
            setVal('sets', appDefaults.sets);
            setVal('restSec', appDefaults.restSec);
            setVal('exerciseRestSec', appDefaults.exerciseRestSec);
            setVal('roundRestSec', appDefaults.roundRestSec);
            setVal('totalMin', appDefaults.totalMin);

            const coachSel = document.getElementById('coach-preset-live');
            if (coachSel) coachSel.value = appDefaults.coachPreset;

            if (appDefaults.bonuses) {
                for (let i = 0; i < 3; i++) {
                    const b = appDefaults.bonuses[i];
                    if (b) {
                        setVal(`bonus${i + 1}-name`, b.name);
                        setVal(`bonus${i + 1}-duration`, b.duration);
                        setVal(`bonus${i + 1}-freq`, b.freq);
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            applyVersionToUI();
            populateDropdowns();

            // Start async init, maar blokkeer de UI niet
            initApp();

            document.querySelectorAll('input.param-input').forEach(i => {
                i.addEventListener('input', () => { calculateRealTime(); saveToLocal(); });
            });

            // These are now handled by the new card-group
            // document.getElementById('btn-audio-speech').onclick = () => { setAudioMode('speech'); saveToLocal(); };
            // document.getElementById('btn-audio-beep').onclick = () => { setAudioMode('beep'); saveToLocal(); };

            document.addEventListener("visibilitychange", handleVisibilityChange);
            window.applyFNHPreset = function () {
                if (!confirm("FNH Preset laden? (45m, 2 rondes, 8 oefeningen)")) return;

                document.getElementById('rounds').value = 2;
                document.getElementById('exercises').value = 8;
                document.getElementById('sets').value = 2;

                document.getElementById('restSec').value = 15;
                document.getElementById('exerciseRestSec').value = 30; // Wissel
                document.getElementById('roundRestSec').value = 90;

                document.getElementById('totalMin').value = 45;
                document.getElementById('startTimeValue').value = "19:45";

                // Coach Tabataman
                const coachSel = document.getElementById('coach-preset-live'); // UPDATED
                if (coachSel && coachSel.querySelector('option[value="tabataman"]')) {
                    coachSel.value = 'tabataman';
                }

                // Disable Bonuses
                for (let i = 1; i <= 3; i++) {
                    document.getElementById(`bonus${i}-duration`).value = 0;
                }

                // Enable Milestones (Requirements: Logo & Reset = ON)
                const mileKeys = ['mile_start', 'mile_half', 'mile_end'];
                mileKeys.forEach(k => {
                    if (!speechSettings[k]) speechSettings[k] = {};
                    speechSettings[k].enabled = true;
                });
                renderAudioToggles();
                syncTime('duration');
                calculateRealTime();
                saveToLocal();
            }

            // Initiele calculatie voor de zekerheid
            calculateRealTime();
        });

        function syncTime(source) {
            const min = parseInt(document.getElementById('totalMin').value) || 30;
            const startInput = document.getElementById('startTimeValue');
            const endInput = document.getElementById('endTimeValue');
            const now = new Date();

            const getDateFromTimeStr = (str, baseDate) => {
                if (!str) return null;
                const [h, m] = str.split(':');
                let d = new Date(baseDate.getTime());
                d.setHours(h, m, 0, 0);
                return d;
            };

            if (source === 'duration') {
                // Change Duration -> Update End Time
                let base = getDateFromTimeStr(startInput.value, now) || now;
                let target = new Date(base.getTime() + min * 60000);
                endInput.value = target.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
            }
            else if (source === 'starttime') {
                // Change Start Time -> Update End Time (Fixed Duration)
                let start = getDateFromTimeStr(startInput.value, now) || now;
                let target = new Date(start.getTime() + min * 60000);
                endInput.value = target.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
            }
            else if (source === 'endtime') {
                // Change End Time -> Update Start Time (Fixed Duration)
                let end = getDateFromTimeStr(endInput.value, now);
                if (!end) return;

                // Subtract duration to get start time
                let start = new Date(end.getTime() - min * 60000);
                startInput.value = start.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });
            }
            calculateRealTime();
        }

        function populateDropdowns() {
            const fill = (id, start, end, step = 1, suffix = "") => {
                const sel = document.getElementById(id);
                // Only populate if it's a SELECT element
                if (sel && sel.tagName === 'SELECT') {
                    sel.innerHTML = "";
                    for (let i = start; i <= end; i += step) {
                        const opt = document.createElement('option'); opt.value = i; opt.text = i + suffix; sel.appendChild(opt);
                    }
                }

                // Initial resume selections (legacy)
                const resumeSel = document.getElementById("start-" + (id === 'rounds' ? 'round' : (id === 'exercises' ? 'ex' : (id === 'sets' ? 'set' : ''))));
                if (resumeSel) {
                    resumeSel.innerHTML = "";
                    for (let i = start; i <= end; i += step) {
                        const opt2 = document.createElement('option'); opt2.value = i; opt2.text = i + suffix; resumeSel.appendChild(opt2);
                    }
                }
            };

            // Legacy global inputs are now INPUT type (hidden), so this won't run, which is correct.
            fill('rounds', 1, 10);
            fill('exercises', 1, 20);
            fill('sets', 1, 10);

            const fillTotal = (id) => {
                const sel = document.getElementById(id);
                if (!sel) return;
                sel.innerHTML = "";
                for (let i = 1; i <= 10; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "m"; sel.appendChild(opt); }
                for (let i = 15; i <= 120; i += 5) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "m"; sel.appendChild(opt); }
            };
            fillTotal('totalMin');

            const fillRest = (id) => {
                const sel = document.getElementById(id);
                // Legacy inputs might be hidden inputs now
                if (sel && sel.tagName === 'SELECT') {
                    sel.innerHTML = "";
                    for (let i = 5; i <= 60; i += 5) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "s"; sel.appendChild(opt); }
                    for (let i = 70; i <= 180; i += 10) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "s"; sel.appendChild(opt); }
                    for (let i = 210; i <= 300; i += 30) { const opt = document.createElement('option'); opt.value = i; opt.text = i + "s"; sel.appendChild(opt); }
                }
            };
            // Legacy rest inputs are also hidden inputs
            fillRest('restSec'); fillRest('exerciseRestSec'); fillRest('roundRestSec');

            // Bonus UI has been removed, so no more filling bonus dropdowns.
        }

        function handleVisibilityChange() {
            if (document.visibilityState === 'visible' && !isPaused && timerInterval) {
                // Interval logic handles catch up automatically
            }
        }

        function toggleSection(id) {
            const el = document.getElementById(id);
            const header = el.previousElementSibling;
            if (el.style.display === 'none' || el.classList.contains('hidden')) {
                el.style.display = 'block';
                el.classList.remove('hidden');
                header.classList.add('open');
            } else {
                el.style.display = 'none';
                el.classList.add('hidden');
                header.classList.remove('open');
            }
        }

        function applyCoachPreset(presetId) {
            const preset = coachPresets[presetId];
            if (!preset) return;
            speechSettings = JSON.parse(JSON.stringify(preset));
            renderAudioToggles();
            validateCoachFiles(presetId);
        }

        function handleCoachChange() {
            const val = document.getElementById('coach-preset-live').value; // UPDATED
            // Merge new coach preset but KEEP user toggle overrides if they exist? 
            // Ideally we reset to the new coach defaults, but user might want to keep "Halfway OFF".
            // For now, let's reset to defaults of the new coach to be safe.
            speechSettings = JSON.parse(JSON.stringify(coachPresets[val]));

            saveToLocal();
            renderAudioToggles(); // Re-render toggles
            validateCoachFiles(val);
        }

        // --- v1.16: RENDER AUDIO TOGGLES ---
        function renderAudioToggles() {
            const container = document.getElementById('audio-toggles-panel');
            if (!container) return;
            container.innerHTML = "";

            if (audioMode === 'beep') {
                container.innerHTML = "<div style='color:#666; font-style:italic; font-size:12px; padding:10px;'>In piepjes-modus zijn er geen spraak instellingen.</div>";
                return;
            }

            uiConfig.forEach(item => {
                if (item.header) {
                    const h = document.createElement('div'); h.className = "category-header"; h.innerText = item.header;
                    h.style.marginTop = "15px"; h.style.marginBottom = "5px"; h.style.fontSize = "11px"; h.style.color = "#888"; h.style.fontWeight = "600";
                    container.appendChild(h);
                } else {
                    const wrapper = document.createElement('div'); wrapper.className = "switch-row";

                    const label = document.createElement('span'); label.className = "switch-label"; label.innerText = item.label;
                    const switchLabel = document.createElement('label'); switchLabel.className = "switch";

                    const cb = document.createElement('input'); cb.type = "checkbox";

                    // Check logic: if key missing, assume enabled by default
                    let isEnabled = true;
                    if (speechSettings[item.id] && typeof speechSettings[item.id].enabled !== 'undefined') {
                        isEnabled = speechSettings[item.id].enabled;
                    }
                    cb.checked = isEnabled;

                    cb.onchange = () => {
                        if (!speechSettings[item.id]) speechSettings[item.id] = { enabled: true };
                        speechSettings[item.id].enabled = cb.checked;
                        saveToLocal();
                    };

                    const slider = document.createElement('span'); slider.className = "slider";
                    switchLabel.appendChild(cb); switchLabel.appendChild(slider);
                    wrapper.appendChild(label); wrapper.appendChild(switchLabel);
                    container.appendChild(wrapper);
                }
            });
        }

        async function validateCoachFiles(coachId) {
            const modal = document.getElementById('validation-modal');
            const status = document.getElementById('validation-status');
            const list = document.getElementById('validation-list');

            modal.style.display = 'flex';
            status.innerText = "Controleren op MP3 bestanden...";
            status.style.color = "#fff";
            list.innerHTML = "";

            const expectedKeys = [];
            uiConfig.forEach(item => {
                if (item.id) expectedKeys.push(item.id);
            });

            // Add manual bonus keys if we want to be thorough, but uiConfig covers most speech triggers.

            const missing = [];

            // Check in chunks to not overload (optional, but Promise.all is usually fine for ~20 files)
            const preset = coachPresets[coachId];
            const variants = preset ? (preset.variants || {}) : {};

            console.log(`[Validation] Checking ${coachId}. Variants found: ${Object.keys(variants).length}`);

            const checks = expectedKeys.map(async (key) => {
                // EXCLUDE LOGIC-ONLY KEYS (No MP3s expected)
                if (['rest_switch_info', 'rest_round_info'].includes(key)) return null;

                try {
                    let filename = `${key}.mp3`;
                    // Check for variant suffix (default to _1 for validation)
                    // Ensure we check exactly what is in variants map
                    if (variants[key] && variants[key] >= 1) {
                        filename = `${key}_1.mp3`;
                    } else {
                        // Debug if we expected a variant but found none
                        if (['work_start', 'prep_countdown'].includes(key)) {
                            console.warn(`[Validation] Warning: No variants found for ${key} in ${coachId}, defaulting to base.mp3`);
                        }
                    }

                    const path = `coaches/${coachId}/${filename}`;
                    const resp = await fetch(path, { method: 'HEAD' });
                    if (!resp.ok) return key + ` (${filename})`; // Return details
                    return null;
                } catch (e) {
                    return key; // Error means missing or network issue
                }
            });

            const results = await Promise.all(checks);
            results.forEach(res => {
                if (res) missing.push(res);
            });

            if (missing.length > 0) {
                status.innerText = `Er ontbreken ${missing.length} bestanden:`;
                status.style.color = "#ff453a";
                missing.forEach(key => {
                    const li = document.createElement('li');
                    li.innerText = `${key}.mp3`;
                    list.appendChild(li);
                });
            } else {
                status.innerText = "Alle audio bestanden zijn aanwezig! ";
                status.style.color = "#30D158";
                setTimeout(() => {
                    if (modal.style.display === 'flex') modal.style.display = 'none';
                }, 1500);
            }
        }


        // --- NEW EXERCISE SELECTOR LOGIC ---
        let currentExContext = null; // {r, e, s}
        let selectedDbItem = null;

        function openExerciseSelector(r, e, s, currentName) {
            currentExContext = { r, e, s };
            document.getElementById('exercise-selector-modal').style.display = 'flex';
            document.getElementById('scope-set-force').innerText = s;

            // Generate list
            const ul = document.getElementById('ex-list-ul');
            ul.innerHTML = "";

            // Filters Sets
            const categories = new Set();
            const materials = new Map(); // Name -> Description
            const materialCounts = new Map(); // Name -> Count

            // Add "Custom" option at top
            const customLi = document.createElement('li');
            customLi.className = "ex-list-item";
            customLi.style.borderBottom = "2px solid #333";
            customLi.innerHTML = `<span style="font-weight:bold; color:white;"> Eigen Naam Invoeren...</span>`;
            customLi.onclick = () => {
                const name = prompt("Voer naam in:", currentName);
                if (name) {
                    selectedDbItem = { exercise_name: name }; // Pseudo item
                    showExDetail(selectedDbItem);
                }
            };
            ul.appendChild(customLi);

            // Populate from DB
            if (typeof WORKOUT_DB !== 'undefined') {
                WORKOUT_DB.forEach(item => {
                    const li = document.createElement('li');
                    li.className = "ex-list-item";

                    // Metadata for filtering
                    const cat = item.category || "Other";
                    const mat = item.material_name || "None";
                    const matDesc = item.material_description || "";

                    categories.add(cat);
                    if (!materials.has(mat)) {
                        materials.set(mat, matDesc);
                    }
                    materialCounts.set(mat, (materialCounts.get(mat) || 0) + 1);

                    li.dataset.search = (item.exercise_name + " " + cat + " " + item.id).toLowerCase();
                    li.dataset.cat = cat;
                    li.dataset.mat = mat;

                    li.innerHTML = `
                        <div style="font-weight:500; color:#eee;">${item.exercise_name}</div>
                        <div class="ex-cat-tag">${cat}</div>
                    `;
                    li.onclick = () => showExDetail(item);
                    ul.appendChild(li);
                });
            } else {
                ul.innerHTML += `<li class="ex-list-item">Database niet geladen.</li>`;
            }

            // Populate Filter Dropdowns
            const catSelect = document.getElementById('filter-category');
            catSelect.innerHTML = '<option value="">Alle Categorien</option>';
            Array.from(categories).sort().forEach(c => {
                const opt = document.createElement('option');
                opt.value = c;
                opt.innerText = c;
                catSelect.appendChild(opt);
            });

            const matSelect = document.getElementById('filter-material');
            matSelect.innerHTML = '<option value="">Alle Materialen</option>';

            // Sort materials by Name
            const sortedMats = Array.from(materials.keys()).sort();

            sortedMats.forEach(m => {
                const desc = materials.get(m);
                const count = materialCounts.get(m) || 0;
                const opt = document.createElement('option');
                opt.value = m;
                // Show "Name (Count) - Description"
                let displayText = `${m} (${count})`;
                if (desc && desc.length > 1) {
                    const shortDesc = desc.length > 50 ? desc.substring(0, 47) + "..." : desc;
                    displayText += ` - ${shortDesc}`;
                }
                opt.innerText = displayText;
                matSelect.appendChild(opt);
            });

            // Show List View
            backToExList();
        }

        function filterExercises() {
            const term = document.getElementById('ex-search-input').value.toLowerCase();
            const catFilter = document.getElementById('filter-category').value;
            const matFilter = document.getElementById('filter-material').value;

            const items = document.querySelectorAll('#ex-list-ul .ex-list-item');
            items.forEach(li => {
                if (!li.dataset.search) return; // Custom item

                const matchesTerm = li.dataset.search.includes(term);
                const matchesCat = catFilter === "" || li.dataset.cat === catFilter;
                const matchesMat = matFilter === "" || li.dataset.mat === matFilter;

                if (matchesTerm && matchesCat && matchesMat) li.style.display = 'flex';
                else li.style.display = 'none';
            });
        }

        function showExDetail(item) {
            selectedDbItem = item;
            document.getElementById('ex-list-view').style.display = 'none';
            document.getElementById('ex-detail-view').style.display = 'flex';
            document.getElementById('ex-modal-title').innerText = "Bevestig";

            document.getElementById('detail-tit').innerText = item.exercise_name;
            document.getElementById('detail-meta').innerText = item.category || "Custom";
            document.getElementById('detail-desc').innerText = item.instructions || "Geen instructies.";

            const vidBtn = document.getElementById('detail-vid-btn');
            const vidThumb = document.getElementById('detail-vid-thumb');
            const vidFallback = document.getElementById('detail-vid-fallback');

            if (item.video_search_url) {
                vidBtn.style.display = 'flex';
                vidBtn.href = item.video_search_url;

                if (item.thumbnail) {
                    vidThumb.src = item.thumbnail;
                    vidThumb.style.display = 'block';
                    vidFallback.style.display = 'none';
                } else {
                    vidThumb.style.display = 'none';
                    vidFallback.style.display = 'block';
                }
            } else {
                vidBtn.style.display = 'none';
            }


        }

        function backToExList() {
            document.getElementById('ex-list-view').style.display = 'flex';
            document.getElementById('ex-detail-view').style.display = 'none';
            document.getElementById('ex-modal-title').innerText = "Kies Oefening";
        }

        function closeExerciseSelector() {
            document.getElementById('exercise-selector-modal').style.display = 'none';
        }

        function confirmExerciseSelection() {
            if (!selectedDbItem || !currentExContext) return;

            const scopeRadios = document.getElementsByName('scope_sel');
            let scope = 'all_rounds';
            for (let r of scopeRadios) if (r.checked) scope = r.value;

            // Map scope to function args
            // 'all_rounds', 'set_all_rounds', 'single'
            // NOTE: 'round_ex' removed based on UI simplification, but we can re-add if needed.

            // Set input values for hidden fields used by applyNameChange
            document.getElementById('edit-round-idx').value = currentExContext.r;
            document.getElementById('edit-ex-idx').value = currentExContext.e;
            document.getElementById('edit-set-idx').value = currentExContext.s;
            document.getElementById('edit-new-val').value = selectedDbItem.exercise_name;

            applyNameChange(scope);
            closeExerciseSelector();
        }

        // --- OLD MODAL REMOVED - Adapter for applyNameChange remains same ---
        // (Function applyNameChange is reused)

        function closeEditScopeModal() {
            document.getElementById('edit-scope-modal').style.display = 'none';
        }

        function applyNameChange(scope) {
            const r = parseInt(document.getElementById('edit-round-idx').value);
            const e = parseInt(document.getElementById('edit-ex-idx').value);
            const s = parseInt(document.getElementById('edit-set-idx').value);
            const newVal = document.getElementById('edit-new-val').value;
            const totalRounds = parseInt(document.getElementById('rounds').value);

            if (scope === 'single') {
                const key = `r${r}-e${e}-s${s}`;
                if (newVal.trim() === "") delete customNames[key];
                else customNames[key] = newVal;
            }
            else if (scope === 'round_ex') {
                const key = `r${r}-e${e}`;
                if (newVal.trim() === "") delete customNames[key];
                else customNames[key] = newVal;
                // Cleanup specific set overrides for this round
                Object.keys(customNames).forEach(k => { if (k.startsWith(`r${r}-e${e}-s`)) delete customNames[k]; });
            }
            else if (scope === 'all_rounds') {
                for (let i = 1; i <= totalRounds; i++) {
                    const key = `r${i}-e${e}`;
                    if (newVal.trim() === "") delete customNames[key];
                    else customNames[key] = newVal;
                    // Cleanup specific set overrides
                    Object.keys(customNames).forEach(k => { if (k.startsWith(`r${i}-e${e}-s`)) delete customNames[k]; });
                }
            }
            else if (scope === 'set_all_rounds') {
                for (let i = 1; i <= totalRounds; i++) {
                    const key = `r${i}-e${e}-s${s}`;
                    if (newVal.trim() === "") delete customNames[key];
                    else customNames[key] = newVal;
                }
            }

            saveToLocal();
            // document.getElementById('edit-scope-modal').style.display = 'none'; // OLD MODAL REMOVED - Fixed crash
            // showScheduleModal(); // Handled by caller
        }

        function resetToDefaults() {
            if (!confirm("Weet je zeker dat je alle instellingen wilt resetten naar standaard?")) return;

            // 1. Reset Core UI Parameters
            // applyDefaultsToUI(); // removed to prevent ReferenceError

            // 2. Reset Workout Structure (Exactly 1 round)
            workoutRounds = [
                { id: Date.now(), exercises: appDefaults.exercises, sets: appDefaults.sets, workTime: 45, restTime: 15, roundRest: 60 }
            ];
            customNames = {};
            roundExercises = {};

            // Update Rounds UI explicitly
            if (document.getElementById('rounds')) document.getElementById('rounds').value = 1;

            // 3. Reset Timing & UI Elements
            const now = new Date();
            now.setMinutes(now.getMinutes() + 2);
            const startStr = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', hour12: false });

            const startInput = document.getElementById('startTimeValue');
            if (startInput) startInput.value = startStr;

            const totalMinInput = document.getElementById('totalMin');
            if (totalMinInput) {
                totalMinInput.value = (appDefaults.totalMin || 45) + "m";
            }

            syncTime('duration'); // Updates End Time based on Start + Duration
            setAudioMode('speech');
            if (document.getElementById('coach-preset-live')) document.getElementById('coach-preset-live').value = 'eva';

            // Reset Speech Settings
            ['mile_start', 'mile_half', 'mile_end'].forEach(k => {
                if (!speechSettings[k]) speechSettings[k] = {};
                speechSettings[k].enabled = true;
            });
            renderAudioToggles();

            // 4. Persistence & UI Sync
            saveRoundsToLocal();
            saveToLocal();
            renderRoundsContainer();
            calculateRealTime();
        }

        function applyTabataPreset() {
            if (!confirm("Tabata Preset laden? (8 oefeningen, 1 ronde, 20s werk, 10s rust)")) return;

            // 1. Set Structure (Exactly 1 round)
            workoutRounds = [
                { id: Date.now(), exercises: 8, sets: 1, workTime: 20, restTime: 10, roundRest: 60, exerciseRest: 10 }
            ];
            customNames = {};
            roundExercises = {};

            // 2. Update Globals for new structure
            document.getElementById('exercises').value = 8;
            document.getElementById('sets').value = 1;
            document.getElementById('restSec').value = 10;
            document.getElementById('exerciseRestSec').value = 10;
            document.getElementById('roundRestSec').value = 60;
            document.getElementById('rounds').value = 1; // Explicitly 1 round in UI

            // 3. Persistence & UI Sync
            saveRoundsToLocal();
            saveToLocal();
            renderRoundsContainer();
            calculateRealTime();
        }


        // --- AI GENERATOR LOGIC ---
        let globalCoachAudio = new Audio();
        let audioCache = {}; // Cache for Web Audio buffers (Mix Mode)
        let iosMixMode = true; // Default ON (v1.5)
        let genLogic = { set: 'same', round: 'same' };

        // Show Mix Mode toggle only on iOS & Add Resumption Listeners
        if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
            // UI Toggle removed (Always On requested)

            // Auto-Resume AudioContext on Tab Focus/Return
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) wakeUpAudio();
            });

            // Re-unlock on any touch (ensure playback)
            document.addEventListener('touchstart', () => {
                wakeUpAudio();
            }, { passive: true });
        }

        function wakeUpAudio() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended' || audioCtx.state === 'interrupted') {
                audioCtx.resume().then(() => logAudioDebug(" Audio Resumed (WakeUp)"));
            }
            // Force silent oscillator to wake up iOS Audio Engine
            try {
                const osc = audioCtx.createOscillator();
                const g = audioCtx.createGain();
                g.gain.value = 0; // Silent
                osc.connect(g);
                g.connect(audioCtx.destination);
                osc.start(0);
                osc.stop(audioCtx.currentTime + 0.01);
            } catch (e) { /* ignore */ }
        }







        function shareApp() {
            const cleanUrl = window.location.origin + window.location.pathname;
            let text = " **FNH Timer: De enige timer die terugrekent!**\n\n";
            text += " **Jij kiest de eindtijd, de app doet de rest.**\n";
            text += "Hij berekent automatisch de werk- en rusttijden zodat je precies op tijd klaar bent. Nooit meer gokken of haasten.\n\n";
            text += " **Waarom deze app?**\n";
            text += "-  **Aftellen tot start:** Zie precies hoe lang je nog hebt voor uitleg of warming-up. De training start automatisch!\n";
            text += "-  **Trainer Logica:** Snapt bonussen, 'toetjes' en onderscheidt rust vs. wisselen.\n";
            text += "-  Pas live tijden aan (zonder rekenen)\n";
            text += "-  Muziek blijft aanstaan (Mix-mode)\n";
            text += "-  **Draait op alles:** Werkt op iOS, Android, Windows en Mac.\n";
            text += "-  **Geen installatie:** Werkt direct in je browser (Web App)!\n\n";
            text += " **Gebruik 'm hier (gratis):**";

            if (navigator.share) {
                navigator.share({
                    title: "FNH Timer ",
                    text: text,
                    url: cleanUrl
                }).catch(console.error);
            } else {
                navigator.clipboard.writeText(text + "\n" + cleanUrl).then(() => alert("Tekst en link gekopieerd!"));
            }
        }

        function shareSettings() {
            const rounds = document.getElementById('rounds').value; const exercises = document.getElementById('exercises').value; const sets = document.getElementById('sets').value;
            const restSec = document.getElementById('restSec').value; const exerciseRestSec = document.getElementById('exerciseRestSec').value; const roundRestSec = document.getElementById('roundRestSec').value;
            const totalMin = document.getElementById('totalMin').value;

            // NEW: Capture additional settings
            const startTime = document.getElementById('startTimeValue').value;
            const coach = document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : 'eva'; // UPDATED


            const params = new URLSearchParams();
            params.set('r', rounds); params.set('e', exercises); params.set('s', sets);
            params.set('rs', restSec); params.set('re', exerciseRestSec); params.set('rr', roundRestSec); params.set('tm', totalMin);

            if (startTime) params.set('st', startTime);
            if (coach) params.set('c', coach);

            // Bonus Settings (Null-checked)
            for (let i = 1; i <= 3; i++) {
                const elName = document.getElementById(`bonus${i}-name`);
                const elDur = document.getElementById(`bonus${i}-duration`);
                const elFreq = document.getElementById(`bonus${i}-freq`);
                if (elName) params.set(`b${i}n`, elName.value);
                if (elDur) params.set(`b${i}d`, elDur.value);
                if (elFreq) params.set(`b${i}f`, elFreq.value);
            }

            // Custom Names (Full Schedule)
            if (Object.keys(customNames).length > 0) {
                try {
                    const cnStr = JSON.stringify(customNames);
                    params.set('cn', encodeURIComponent(cnStr));
                } catch (e) { console.error("Error serializing customNames", e); }
            }

            for (const [key, value] of Object.entries(speechSettings)) { if (value.text) { params.set(key, value.text); } }
            const baseUrl = window.location.origin + window.location.pathname; const shareUrl = baseUrl + '?' + params.toString();
            if (navigator.share) { navigator.share({ title: 'FNH Training Settings', url: shareUrl }).catch(console.error); }
            else { navigator.clipboard.writeText(shareUrl).then(() => { alert("Link met instellingen gekopieerd!"); }); }
        }

        function checkForSharedSettings() {
            const params = new URLSearchParams(window.location.search);
            let dataUpdated = false;
            if (params.has('r')) {
                document.getElementById('rounds').value = params.get('r'); document.getElementById('exercises').value = params.get('e'); document.getElementById('sets').value = params.get('s');
                document.getElementById('restSec').value = params.get('rs'); document.getElementById('exerciseRestSec').value = params.get('re'); document.getElementById('roundRestSec').value = params.get('rr');
                document.getElementById('totalMin').value = params.get('tm'); dataUpdated = true;
            }

            // Restore new settings
            if (params.has('st')) { document.getElementById('startTimeValue').value = params.get('st'); dataUpdated = true; }

            if (params.has('c')) {
                const coachVal = params.get('c');
                const coachEl = document.getElementById('coach-preset-live'); // UPDATED
                if (coachEl && coachEl.querySelector(`option[value="${coachVal}"]`)) {
                    coachEl.value = coachVal;
                    // We must trigger this to load audio/speech settings for the coach
                    applyCoachPreset(coachVal);
                    dataUpdated = true;
                }
            }

            // Restore Bonus Settings
            for (let i = 1; i <= 3; i++) {
                if (params.has(`b${i}n`)) { document.getElementById(`bonus${i}-name`).value = params.get(`b${i}n`); dataUpdated = true; }
                if (params.has(`b${i}d`)) { document.getElementById(`bonus${i}-duration`).value = params.get(`b${i}d`); dataUpdated = true; }
                if (params.has(`b${i}f`)) { document.getElementById(`bonus${i}-freq`).value = params.get(`b${i}f`); dataUpdated = true; }
            }

            // Restore Custom Names (Full Schedule)
            if (params.has('cn')) {
                try {
                    const cnStr = decodeURIComponent(params.get('cn'));
                    const parsed = JSON.parse(cnStr);
                    // Merge or replace? Let's replace to ensure exact schedule replication
                    if (parsed) {
                        customNames = parsed;
                        dataUpdated = true;
                    }
                } catch (e) { console.error("Failed to parse custom names", e); }
            }

            let speechUpdated = false;
            for (const key in speechSettings) { if (params.has(key)) { speechSettings[key].text = params.get(key); speechUpdated = true; dataUpdated = true; } }
            if (speechUpdated) { const dropdown = document.getElementById('coach-preset-live'); if (dropdown) { dropdown.value = 'custom'; if (dropdown.querySelector('option[value="custom"]')) { dropdown.querySelector('option[value="custom"]').removeAttribute('hidden'); dropdown.querySelector('option[value="custom"]').removeAttribute('disabled'); } } } // UPDATED


            if (dataUpdated) {
                // Restore visibility of bonuses if needed
                if (typeof updateBonusVisibility === 'function') updateBonusVisibility();

                syncTime('duration');
                saveToLocal();
            }
        }

        function saveToLocal() {
            const data = {
                rounds: document.getElementById('rounds').value, exercises: document.getElementById('exercises').value, sets: document.getElementById('sets').value,
                restSec: document.getElementById('restSec').value, exerciseRestSec: document.getElementById('exerciseRestSec').value, roundRestSec: document.getElementById('roundRestSec').value,
                totalMin: document.getElementById('totalMin').value, audioMode: audioMode,
                speechSettings: speechSettings, // v1.16: Restore Save
                startTimeValue: document.getElementById('startTimeValue').value, // NEW
                speechSettings: speechSettings, // v1.16: Restore Save
                startTimeValue: document.getElementById('startTimeValue').value, // NEW
                coachPreset: document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : (appDefaults.coachPreset || 'eva'), // Save Coach Selection (Live or Default)
                startRound: document.getElementById('start-round').value, startEx: document.getElementById('start-ex').value, startSet: document.getElementById('start-set').value,
                iosMixMode: iosMixMode, // Save Mix Mode setting
                // Save Custom Names
                customNames: customNames,
                customWorkTimes: customWorkTimes, // Pro-feature: per-exercise time
                roundExercises: roundExercises // Save per-set exercise assignments
            };
            localStorage.setItem('fnh_settings_v8', JSON.stringify(data));
        }

        function loadFromLocal() {
            const saved = localStorage.getItem('fnh_settings_v8');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    document.getElementById('rounds').value = data.rounds || 2; document.getElementById('exercises').value = data.exercises || 6; document.getElementById('sets').value = data.sets || 2;
                    document.getElementById('restSec').value = data.restSec || 20; document.getElementById('exerciseRestSec').value = data.exerciseRestSec || 30; document.getElementById('roundRestSec').value = data.roundRestSec || 90;
                    document.getElementById('totalMin').value = data.totalMin || 30;
                    if (data.startTimeValue) document.getElementById('startTimeValue').value = data.startTimeValue;
                    if (data.startRound) document.getElementById('start-round').value = data.startRound;
                    if (data.startEx) document.getElementById('start-ex').value = data.startEx;
                    if (data.startSet) document.getElementById('start-set').value = data.startSet;

                    // Bonus Data Load Removed (UI Removed)

                    if (data.customNames) customNames = data.customNames;
                    if (data.customWorkTimes) customWorkTimes = data.customWorkTimes;
                    if (data.roundExercises) roundExercises = data.roundExercises;

                    // Restore Volumes
                    if (data.volMusic) {
                        try { document.getElementById('vol-music').value = data.volMusic; } catch (e) { } // Removed element
                        if (document.getElementById('vol-music-live')) document.getElementById('vol-music-live').value = data.volMusic;
                        bgMusicManager.audio.volume = parseFloat(data.volMusic);
                    }
                    if (data.volCoach) {
                        try { document.getElementById('vol-coach').value = data.volCoach; } catch (e) { } // Removed element
                        if (document.getElementById('vol-coach-live')) document.getElementById('vol-coach-live').value = data.volCoach;
                    }

                    // Restore Coach Preset
                    if (data.coachPreset) {
                        const sel = document.getElementById('coach-preset-live'); // UPDATED
                        // Only set if option exists
                        if (sel && sel.querySelector(`option[value="${data.coachPreset}"]`)) {
                            sel.value = data.coachPreset;
                        }
                    }

                    // Restore Mix Mode (Always ON now)
                    iosMixMode = true;

                    if (data.audioMode) setAudioMode(data.audioMode);
                    // v1.16: Restore speechSettings load
                    if (data.speechSettings) {
                        for (const key in speechSettings) {
                            if (data.speechSettings[key]) {
                                speechSettings[key].enabled = data.speechSettings[key].enabled;
                            }
                        }
                        // Also Add keys that might be in data but not in current preset (though standardizing via uiConfig is better)
                        for (const key in data.speechSettings) {
                            if (!speechSettings[key]) speechSettings[key] = data.speechSettings[key];
                        }

                        // FIX: Ensure critical keys exist to prevent 'undefined' errors
                        const requiredKeys = ['rest_set_tips', 'rest_switch_info', 'rest_round_info'];
                        requiredKeys.forEach(k => {
                            if (!speechSettings[k]) speechSettings[k] = { enabled: true };
                        });
                    }

                } catch (e) { console.log("Error loading settings", e); }
            }
        }

        function updatevolumes() {
            const mv = parseFloat(document.getElementById('vol-music').value);
            const cv = parseFloat(document.getElementById('vol-coach').value);

            // Music
            bgMusicManager.audio.volume = mv;
            localStorage.setItem('fnh_vol_music', mv);
        }



        function updateLiveVolumes() {
            const mv = parseFloat(document.getElementById('vol-music-live').value);
            const mr = parseFloat(document.getElementById('vol-music-rest-live').value);
            const cv = parseFloat(document.getElementById('vol-coach-live').value);



            // Update Manager
            if (bgMusicManager && bgMusicManager.updateVolumes) {
                bgMusicManager.updateVolumes(mv, mr);
            } else {
                // Fallback
                bgMusicManager.audio.volume = mv;
            }

            localStorage.setItem('fnh_vol_music', mv);
            localStorage.setItem('fnh_vol_music_rest', mr);
            localStorage.setItem('fnh_vol_coach', cv);
        }

        function setAudioMode(newMode) {
            audioMode = newMode;
            updateLiveAudioUI();
            renderAudioToggles(); // Re-render logic toggles (if visible elsewhere)
        }

        function updateLiveAudioUI() {
            const btnSpeech = document.getElementById('btn-audio-speech-live');
            const btnBeep = document.getElementById('btn-audio-beep-live');
            if (btnSpeech) btnSpeech.className = (audioMode === 'speech') ? 'toggle-btn active' : 'toggle-btn';
            if (btnBeep) btnBeep.className = (audioMode === 'beep') ? 'toggle-btn active' : 'toggle-btn';


        }

        function populateLiveCoachSelect() {
            const sel = document.getElementById('coach-preset-live');
            if (!sel || sel.options.length > 0) return; // Already populated

            sel.innerHTML = "";
            for (const [key, val] of Object.entries(coachPresets)) {
                // Determine display name
                let name = key;
                if (key === 'default') name = "Standaard (Tabataman)";
                if (key === 'tabataman') name = "Tabataman (Orgineel)";
                if (key === 'drill_sergeant') name = "Drill Sergeant (Intens)";
                if (key === 'zen_master') name = "Zen Master (Rust)";
                // Use a generic formatter if defined, else raw key

                const opt = document.createElement('option');
                opt.value = key;
                opt.innerText = name; // simplified naming logic
                if (key === 'tabataman') opt.innerText = "Tabataman (Standaard)"; // Manual override matches previous

                sel.appendChild(opt);
            }
            // Set current value
            const current = appDefaults.coachPreset || 'eva';
            // We should get the ACTUAL current, not just default. 
            // But coach logic is a bit scattered. Let's assume 'eva' if unset.
            sel.value = document.getElementById('coach-preset') ? document.getElementById('coach-preset').value : current;
        }

        function toggleVolumePanel() {
            const el = document.getElementById('active-volume-panel');
            if (el.style.display === 'none') {
                el.style.display = 'block';

                // 1. Sync Volumes
                const savedMus = localStorage.getItem('fnh_vol_music');
                const savedMusRest = localStorage.getItem('fnh_vol_music_rest');
                const savedCoach = localStorage.getItem('fnh_vol_coach');

                if (savedMus) document.getElementById('vol-music-live').value = savedMus;
                if (savedMusRest) document.getElementById('vol-music-rest-live').value = savedMusRest;
                if (savedCoach) document.getElementById('vol-coach-live').value = savedCoach;

                // Force Update Text & Manager with newly set values
                updateLiveVolumes();

                // 2. Populate Coach & Sync UI
                populateLiveCoachSelect();
                updateLiveAudioUI();
                renderAudioToggles(); // Ensure Speech Toggles are rendered

                // 3. Render Genres
                if (bgMusicManager) bgMusicManager.renderGenreToggles('audio-settings-genres');

                // 4. Sync Coach Select Value
                // Verify we have the latest stored or default
                // The 'coach-preset' element was removed, so we rely on global state or LocalStorage?
                // Coach state is in `speechSettings` but that's the CONTENT.
                // The selected preset key isn't stored in a global var explicitly other than the select value.
                // FIX: We need to ensure we know the current coach.
                // Let's grab it from localstorage or default.
                // We likely saved it? `saveToLocal` saves `coach-preset` ID value.
                // Let's add a robust retrieval.

                // For now, let's just ensure the select reflects what might be saved
                // Since we rely on applyCoachPreset to set state.

            } else {
                el.style.display = 'none';
            }
        }

        // --- DYNAMIC ROUNDS STATE ---
        let workoutRounds = [
            { id: 1, exercises: 5, sets: 3, workTime: 45, restTime: 15, roundRest: 60 }
        ];

        function renderRoundsContainer() {
            const container = document.getElementById('rounds-container');
            if (!container) return;
            container.innerHTML = "";

            workoutRounds.forEach((round, index) => {
                const roundNum = index + 1;
                const card = document.createElement('div');
                card.className = 'card-group';
                card.id = 'round-card-' + index;
                card.style.marginBottom = '10px';
                card.style.position = 'relative';

                // Header
                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.marginBottom = '10px';
                header.style.paddingRight = '90px'; // Prevent text overlapping buttons
                const defaultName = "RONDE " + roundNum;
                const roundName = round.name || defaultName;

                header.innerHTML = `
                    <div style="flex:1;">
                        <input type="text" value="${roundName}" 
                               onchange="updateRound(${index}, 'name', this.value)"
                               placeholder="${defaultName}"
                               style="background:transparent; border:none; color:#30D158; font-weight:bold; font-size:16px; width:100%; font-family:'Outfit',sans-serif;">
                    </div>
                `;
                card.appendChild(header);

                // Copy Button (+) - Positioned left of Delete
                const copyBtn = document.createElement('div');
                copyBtn.innerHTML = '+';
                copyBtn.title = "Kopieer Ronde";
                copyBtn.style.position = 'absolute';
                copyBtn.style.right = '60px'; // Spaced out
                copyBtn.style.top = '15px';
                copyBtn.style.fontSize = '24px';
                copyBtn.style.fontWeight = 'bold';
                copyBtn.style.color = '#30D158';
                copyBtn.style.cursor = 'pointer';
                copyBtn.style.lineHeight = '1';
                copyBtn.onclick = () => copyRound(index);
                card.appendChild(copyBtn);

                // Delete Button (x) - Positioned Top Right
                if (workoutRounds.length > 1) {
                    const delBtn = document.createElement('div');
                    delBtn.innerHTML = '';
                    delBtn.title = "Verwijder Ronde";
                    delBtn.style.position = 'absolute';
                    delBtn.style.right = '20px';
                    delBtn.style.top = '18px';
                    delBtn.style.fontSize = '18px';
                    delBtn.style.fontWeight = 'bold';
                    delBtn.style.color = '#FF453A';
                    delBtn.style.cursor = 'pointer';
                    delBtn.style.lineHeight = '1';
                    delBtn.onclick = () => removeRound(index);
                    card.appendChild(delBtn);
                }

                // Controls
                // Grid Container
                const grid = document.createElement('div');
                grid.style.display = 'grid';
                grid.style.gridTemplateColumns = '1fr 1fr';
                grid.style.gap = '10px';
                grid.style.marginBottom = '10px';

                // Helper to create input box
                function createBox(label, field, val, borderColor) {
                    return `
                        <div style="background:#1c1c1e; border:1px solid ${borderColor}; border-radius:12px; padding:10px; display:flex; flex-direction:column; align-items:center;">
                            <label style="font-size:10px; color:#888; text-transform:uppercase; margin-bottom:5px;">${label}</label>
                            <input type="number" class="highlight-input" 
                                value="${val}" 
                                onchange="updateRound(${index}, '${field}', this.value)" 
                                style="width:100%; text-align:center; background:transparent; border:none; color:white; font-size:20px; font-weight:bold; font-family:'Outfit',sans-serif; padding:0;">
                        </div>
                    `;
                }

                grid.innerHTML = `
                    ${createBox('Oefeningen', 'exercises', round.exercises, '#555')}
                    ${createBox('Sets', 'sets', round.sets, '#FF9F0A')}
                    ${createBox('Werk (s)', 'workTime', round.workTime, '#30D158')}
                    ${createBox('Rust (s)', 'restTime', round.restTime, '#FF453A')}
                    <div style="grid-column: span 2; display: flex; gap: 10px; align-items: center;">
                        <div style="flex: 1;">
                            ${createBox('Rust (Oefening)', 'exerciseRest', round.exerciseRest || 15, '#BF5AF2')}
                        </div>
                        <div id="round-info-${index}" style="flex: 1; font-size: 11px; color: #888; text-align: left; padding: 5px;">
                             ...
                        </div>
                    </div>
                `;
                card.appendChild(grid);

                // container.appendChild(card) moved to end of loop iteration

                // Info Footer
                // Info footer moved inside grid
                // const infoDiv = document.createElement('div'); ... removed

                container.appendChild(card);

                // Add Connector if not last round
                if (index < workoutRounds.length - 1) {
                    const connector = document.createElement('div');
                    connector.style.display = 'flex';
                    connector.style.alignItems = 'center';
                    connector.style.justifyContent = 'center';
                    connector.style.padding = '10px 0';
                    connector.innerHTML = `
                         <div style="background:#1c1c1e; border:1px solid #0A84FF; border-radius:8px; padding:10px 15px; display:flex; flex-direction:column; align-items:center; width:150px;">
                            <label style="font-size:10px; color:#0A84FF; margin-bottom:5px; text-transform:uppercase;">Pauze Tussen Ronde</label>
                            <input type="number" value="${round.roundRest}" onchange="updateRound(${index}, 'roundRest', this.value)" 
                                   style="width:100%; text-align:center; background:none; border:none; color:white; font-size:16px; font-weight:bold; font-family:'Outfit',sans-serif;">
                         </div>
                    `;
                    container.appendChild(connector);
                }
            });

            // Re-calc
            calculateRealTime();
        }


        function saveRoundsToLocal() {
            localStorage.setItem('fnh_workout_rounds', JSON.stringify(workoutRounds));
        }

        function updateRound(index, field, value) {
            if (index >= 0 && index < workoutRounds.length) {
                if (field === 'name') {
                    workoutRounds[index][field] = value;
                } else {
                    workoutRounds[index][field] = parseInt(value) || 0;
                }

                // If Work Time changes, reset custom overrides for this round to ensure propagation
                if (field === 'workTime') {
                    const rNum = index + 1;
                    const prefix = `r${rNum}-`;
                    Object.keys(customWorkTimes).forEach(k => {
                        if (k.startsWith(prefix)) delete customWorkTimes[k];
                    });
                    // Also refresh the list to remove the custom values from inputs
                    // But we are outside the render scope? calculateRealTime calls renderRoundExerciseList? 
                    // No, updateRound calls generateOrder -> renderPreview.
                    // We need to trigger re-render of inline list inputs.
                    const card = document.getElementById(`round-card-${index}`);
                    if (card && card.querySelector('.exercise-list-container')) {
                        setTimeout(() => renderRoundExerciseList(index), 50);
                    }
                }

                saveRoundsToLocal();
                calculateRealTime(); // Update total time
                generateScheduleData(false); // Update preview 
                renderPreviewList();
            }
        }

        function setCustomWorkTime(r, e, s, val) {
            const rNum = r + 1;
            const key = `r${rNum}-e${e + 1}-s${s + 1}`;
            const intVal = parseInt(val);
            const round = workoutRounds[r];
            const defaultTime = round ? round.workTime : 45;

            if (!isNaN(intVal) && intVal > 0 && intVal !== defaultTime) {
                if (s === 0) {
                    // Propagate to all sets
                    const sts = round.sets;
                    for (let i = 0; i < sts; i++) {
                        const subKey = `r${rNum}-e${e + 1}-s${i + 1}`;
                        customWorkTimes[subKey] = intVal;
                    }
                } else {
                    customWorkTimes[key] = intVal;
                }
            } else {
                // If empty or same as default, remove override
                if (s === 0) {
                    const sts = round.sets;
                    for (let i = 0; i < sts; i++) {
                        const subKey = `r${rNum}-e${e + 1}-s${i + 1}`;
                        delete customWorkTimes[subKey];
                    }
                } else {
                    delete customWorkTimes[key];
                }
            }
            saveToLocal();
            calculateRealTime();
            // Re-render to update UI (other sets might have changed)
            renderRoundExerciseList(r);
        }

        function addRound() {
            if (workoutRounds.length > 0) {
                // User Request: Use copy logic of last round
                copyRound(workoutRounds.length - 1);
            } else {
                // Fallback for empty state
                workoutRounds.push({ id: Date.now(), exercises: 5, sets: 3, workTime: 45, restTime: 15, roundRest: 60 });
                saveRoundsToLocal();
                renderRoundsContainer();
            }
        }

        function copyRound(index) {
            const source = workoutRounds[index];

            // --- 1. SHIFT EXISTING DATA DOWN ---
            const totalRounds = workoutRounds.length;
            const insertRoundNum = index + 2; // 1-based (for customNames)
            const insertIndex = index + 1;    // 0-based (for roundExercises and splice)

            // A. Shift Custom Names (rX -> rX+1)
            for (let r = totalRounds; r >= insertRoundNum; r--) {
                const oldPrefix = `r${r}-`;
                const newPrefix = `r${r + 1}-`;

                Object.keys(customNames).forEach(key => {
                    if (key.startsWith(oldPrefix)) {
                        const suffix = key.substring(oldPrefix.length);
                        customNames[newPrefix + suffix] = customNames[key];
                        delete customNames[key];
                    }
                });
            }

            // B. Shift Round Exercises (index -> index+1)
            // roundExercises uses 0-based integer keys
            for (let r = totalRounds - 1; r >= insertIndex; r--) {
                if (roundExercises && roundExercises[r]) {
                    roundExercises[r + 1] = roundExercises[r];
                    delete roundExercises[r];
                }
            }

            // --- 2. CLONE SOURCE DATA TO NEW POSITION ---
            // A. Clone Custom Names
            const sourceRoundNum = index + 1;
            const sourcePrefix = `r${sourceRoundNum}-`;
            const targetPrefix = `r${insertRoundNum}-`;

            Object.keys(customNames).forEach(key => {
                if (key.startsWith(sourcePrefix)) {
                    const suffix = key.substring(sourcePrefix.length);
                    customNames[targetPrefix + suffix] = customNames[key];
                }
            });

            // B. Clone Round Exercises
            if (roundExercises && roundExercises[index]) {
                try {
                    roundExercises[insertIndex] = JSON.parse(JSON.stringify(roundExercises[index]));
                } catch (e) { console.error("Error cloning roundExercises", e); }
            }

            // --- 3. COMMIT & RENDER ---
            const newRound = { ...source, id: Date.now() };
            workoutRounds.splice(insertIndex, 0, newRound);

            saveRoundsToLocal();
            saveToLocal(); // Persist all changes
            renderRoundsContainer();
            hydrateMissingDetails(); // Auto-fill details for the new round
        }

        function removeRound(index) {
            workoutRounds.splice(index, 1);
            saveRoundsToLocal();
            renderRoundsContainer();
        }

        // Init on load
        window.addEventListener('DOMContentLoaded', () => {
            const saved = localStorage.getItem('fnh_workout_rounds');
            if (saved) {
                try {
                    workoutRounds = JSON.parse(saved);
                } catch (e) { console.error("Error parsing rounds", e); }
            }
            renderRoundsContainer();
        });


        function calculateRealTime() {
            // New Logic: Sum up all rounds to determine End Time
            let totalSeconds = 15; // Prep time

            workoutRounds.forEach((r, rIndex) => { // Added index for custom key lookup
                const ex = r.exercises;
                const sts = r.sets;
                if (ex > 0 && sts > 0) {
                    // Detailed calculation matching generateScheduleData logic:
                    for (let e = 1; e <= ex; e++) {
                        for (let s = 1; s <= sts; s++) {
                            let workT = r.workTime;
                            const key = `r${rIndex + 1}-e${e}-s${s}`;
                            if (customWorkTimes[key]) workT = customWorkTimes[key];

                            totalSeconds += workT; // custom or default

                            // Rest logic
                            if (s < sts) totalSeconds += r.restTime;
                            else if (e < ex) totalSeconds += 15; // Switch Time hardcoded/default logic for now
                            else totalSeconds += r.roundRest; // End of Round
                        }
                    }
                }
            });

            updateRoundCardsInfo(); // Update visual info per round

            // Update End Time UI
            const startStr = document.getElementById('startTimeValue').value;
            if (startStr) {
                const [sh, sm] = startStr.split(':');
                const startDate = new Date();
                startDate.setHours(sh, sm, 0, 0);

                const endDate = new Date(startDate.getTime() + totalSeconds * 1000);
                const eh = endDate.getHours().toString().padStart(2, '0');
                const em = endDate.getMinutes().toString().padStart(2, '0');
                document.getElementById('endTimeValue').value = `${eh}:${em}`;

                // Update Total Min Display
                const totalMin = Math.round(totalSeconds / 60);
                const tmEl = document.getElementById('totalMin');
                if (tmEl) tmEl.value = totalMin + "m";

                // legacy live-calc-result update removed
            }

            // Also generate preview
            generateScheduleData(false);
            renderPreviewList();
        }

        function updateRoundCardsInfo() {
            // Get Global Start Time
            const startStr = document.getElementById('startTimeValue').value;
            let currentRefTime = new Date();
            if (startStr) {
                const [h, m] = startStr.split(':');
                currentRefTime.setHours(h, m, 0, 0);
            }

            workoutRounds.forEach((r, index) => {
                const infoEl = document.getElementById(`round-info-${index}`);
                if (!infoEl) return;

                let roundDurationSec = 0;
                const ex = r.exercises;
                const sts = r.sets;

                if (ex > 0 && sts > 0) {
                    for (let e = 1; e <= ex; e++) {
                        for (let s = 1; s <= sts; s++) {
                            let workT = r.workTime;
                            const key = `r${index + 1}-e${e}-s${s}`;
                            if (customWorkTimes[key]) workT = customWorkTimes[key];

                            roundDurationSec += workT;
                            if (s < sts) roundDurationSec += r.restTime;
                            else if (e < ex) roundDurationSec += (r.exerciseRest || 15);
                            else roundDurationSec += r.roundRest; // End Round
                        }
                    }
                }

                // Add to ref time to get finish of this round
                let startTimeOfRound = new Date(currentRefTime.getTime());
                currentRefTime.setSeconds(currentRefTime.getSeconds() + roundDurationSec);
                let endTimeOfRound = new Date(currentRefTime.getTime());

                const finishStr = currentRefTime.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

                // Format duration (minutes if > 60)
                const durMin = Math.round(roundDurationSec / 60);

                infoEl.innerHTML = `Deze ronde duurt <b>${durMin} min</b> (Klaar om ${finishStr})`;

                // Apply Highlight
                const now = new Date();
                const cardEl = document.getElementById(`round-card-${index}`);
                if (cardEl) {
                    if (now >= startTimeOfRound && now < endTimeOfRound) {
                        cardEl.classList.add('active-card');
                    } else {
                        cardEl.classList.remove('active-card');
                    }
                }
            });
        }






        function generateScheduleData(applyResumeFilter) {
            schedule = [];
            schedule.push({ type: 'prep', time: 15, label: "Voorbereiden", initialTime: 15, info: { round: 1, exercise: 1, set: 1 } });

            let globalExCount = 0;
            let currentSetGlobal = 0;

            workoutRounds.forEach((round, rIndex) => {
                const roundNum = rIndex + 1;
                const ex = round.exercises;
                const sts = round.sets;

                for (let e = 1; e <= ex; e++) {
                    globalExCount++;
                    for (let s = 1; s <= sts; s++) {
                        currentSetGlobal++;

                        // Construct Label
                        let key = `r${roundNum}-e${e}-s${s}`;
                        let prefix = round.name || `Ronde ${roundNum}`;
                        let label = customNames[key] || `${prefix} - Oefening ${e}.${s}`;

                        // Check Custom Work Time
                        let workDuration = round.workTime;
                        if (customWorkTimes[key]) workDuration = customWorkTimes[key];

                        // Add Work
                        schedule.push({
                            type: 'work',
                            time: workDuration,
                            initialTime: workDuration,
                            label: label,
                            info: { round: roundNum, exercise: e, set: s, maxRounds: workoutRounds.length, maxEx: ex, maxSets: sts, globalSet: currentSetGlobal }
                        });

                        // Add Rest
                        const isLastSetOfRound = (e === ex && s === sts);
                        const isLastSetOfExercise = (s === sts);

                        if (isLastSetOfRound) {
                            // Only add round rest if NOT the very last round? 
                            // Current logic adds it. User might want a finish. 
                            // Usually "End of Round" implies a rest before next round or finish.
                            // App usually ends with "KLAAR".
                            if (roundNum < workoutRounds.length) {
                                schedule.push({
                                    type: 'rest-long',
                                    time: round.roundRest,
                                    initialTime: round.roundRest,
                                    label: "RONDE PAUZE",
                                    info: { round: roundNum, text: "Even bijkomen..." }
                                });
                            }
                        } else if (isLastSetOfExercise) {
                            schedule.push({
                                type: 'rest-exercise',
                                time: round.exerciseRest || 15,
                                initialTime: round.exerciseRest || 15,
                                label: "WISSEL OEFENING",
                                info: { round: roundNum, text: "Volgende oefening" }
                            });
                        } else {
                            schedule.push({
                                type: 'rest',
                                time: round.restTime,
                                initialTime: round.restTime,
                                label: "RUST",
                                info: { round: roundNum, text: "Even ontspannen" }
                            });
                        }
                    }
                }
            });

            if (schedule.length > 1) schedule.push({ type: 'finish', time: 0, label: "KLAAR!", initialTime: 0, info: { text: "Goed gewerkt!" } });
            else schedule = [];
        }

        // --- MUSIC UI RENDERER ---

        // --- MUSIC MANIFEST (Hardcoded) ---
        const musicManifest = {
            "Kaseko": {
                rust: [
                    "Bossa Breeze 11.mp3", "Caribbean Drift 04.mp3", "Caribbean Lounge 08.mp3", "Coral Reef 05.mp3",
                    "Deep Blue Rest 06.mp3", "Dreamy Steel 12.mp3", "Dubby Drift 09.mp3", "Island Acoustic 07.mp3",
                    "Island Calm 03.mp3", "Ocean Pan 14.mp3", "Reggae Rest 13.mp3", "Steelpan Breeze 01.mp3",
                    "Sunset Steel 16.mp3", "Tropical Float 02.mp3", "Tropical Recharge 10.mp3", "Weightless Pan 15.mp3"
                ],
                werk: [
                    "Island Velocity 03.mp3", "Kaseko Drive 04.mp3", "Kaseko Focus 12.mp3", "Kaseko Grind 07.mp3",
                    "Kaseko Limits 14.mp3", "Kaseko Power 01.mp3", "Kaseko Stamina 09.mp3", "Kaseko Warrior 11.mp3",
                    "Suri Sweat 06.mp3", "Tropical Burn 02.mp3", "Tropical Fire 08.mp3", "Tropical Force 05.mp3",
                    "Tropical Motion 16.mp3", "Tropical Power 15.mp3", "Tropical Rush 13.mp3", "Tropical Speed 10.mp3"
                ]
            },
            "Neue Deutsche Hrte": {
                rust: [
                    "(Ein langes Zischen von Dampf).mp3",
                    "(Ein tiefer, gedmpfter Beat setzt sofor.mp3",
                    "(Langsam, Dster, Atmosphrisch).mp3",
                    "(Sehr langsam, Tief).mp3",
                    "(Tiefes Brummen der Motoren).mp3"
                ],
                werk: [
                    "BEFEHL IST BEFEHL!.mp3",
                    "DAS TIER!.mp3",
                    "DEUTSCHLAND!.mp3",
                    "DRECKIGER SCHWEINEKOPF!.mp3",
                    "DU BIST AUS STAHL!.mp3",
                    "EISEN!.mp3",
                    "HALT DIE FRESSE!.mp3",
                    "HAMMER!.mp3",
                    "HEUL NICHT!.mp3",
                    "NEIN!.mp3",
                    "PANZER!.mp3",
                    "VERDAMMTES ARSCHLOCH!.mp3"
                ]
            },
            "Phonk": {
                rust: [
                    "PhonkRelax1.mp3",
                    "PhonkRelax2.mp3",
                    "PhonkRelax3.mp3",
                    "PhonkRelax4.mp3"
                ],
                werk: [
                    "FASTER! FASTER!.mp3",
                    "FASTER!.mp3",
                    "FOCUS. 2.mp3",
                    "FOCUS..mp3",
                    "GO! PUSH IT TO THE LIMIT! NO MERCY! (WOR.mp3",
                    "GRIND!.mp3",
                    "KEEP IT MOVING!.mp3",
                    "STOMP! STOMP!.mp3",
                    "TOMA! TOMA! TOMA!.mp3"
                ]
            },
            "Happy Hardcore": {
                rust: [
                    "Angelic Voices 10.mp3", "Campfire Rave 08.mp3", "Cloud Drifter 04.mp3", "Fairy Tale 15.mp3",
                    "Final Heartbeat 16.mp3", "Flute Fantasy 09.mp3", "Gentle Light 05.mp3", "Happy Chill 01.mp3",
                    "Music Box Chill 03.mp3", "Ocean Blue 07.mp3", "Reverse Dream 11.mp3", "Robot Rest 14.mp3",
                    "Saxo Love 12.mp3", "String Serenade 02.mp3", "Sunset Rave 06.mp3", "Whistle Song 13.mp3"
                ],
                werk: [
                    "Bassline Runner 12.mp3", "Ding Dong Hardcore 15.mp3", "Dream Team 06.mp3", "Dutch Rave 02.mp3",
                    "Eternal Rave 16.mp3", "Happy Clapper 13.mp3", "Happy Power 01.mp3", "Jump High 03.mp3",
                    "Maximum Velocity 10.mp3", "Piano Power 14.mp3", "Raging Fire 04.mp3", "Rainbow High 07.mp3",
                    "Rave Unity 05.mp3", "Speed of Light 08.mp3", "Stomp It 09.mp3", "Stutter Power 11.mp3"
                ]
            }
        };

        class BackgroundMusicManager {
            constructor() {
                this.audio = new Audio();
                this.audio.loop = false; // FIXED: No loop, auto-advance
                // Use new Live ID but fallback to storage
                const volInput = document.getElementById('vol-music-live');
                const volRestInput = document.getElementById('vol-music-rest-live');

                this.volWork = volInput ? parseFloat(volInput.value) : parseFloat(localStorage.getItem('fnh_vol_music') || 0.4);
                this.volRest = volRestInput ? parseFloat(volRestInput.value) : parseFloat(localStorage.getItem('fnh_vol_music_rest') || 0.2);

                this.audio.volume = this.volRest; // Default to rest volume initially
                this.audio.preload = 'auto'; // Ensure preload

                // FIXED: Load persisted genres
                const savedGenres = localStorage.getItem('fnh_selected_genres');
                this.selectedGenres = savedGenres ? JSON.parse(savedGenres) : [];
                this.enabledGenres = new Set(this.selectedGenres);

                // FIXED PLAYLIST QUEUES
                this.workQueue = [];
                this.restQueue = [];
                this.workIndex = 0;
                this.restIndex = 0;

                this.workIndex = 0;
                this.restIndex = 0;

                this.continuousMode = false;
                // Load continuous mode preference
                if (localStorage.getItem('fnh_continuous') === 'true') {
                    this.setContinuous(true);
                    setTimeout(() => {
                        const chk = document.getElementById('chk-continuous-music');
                        if (chk) chk.checked = true;
                    }, 500);
                }

                this.currentGenre = null;
                this.currentType = 'rust'; // Default
                this.hasStartedForWorkout = false;

                // Handle Track End for Continuous Mode
                // Handle Track End
                this.audio.onended = () => {
                    if (this.hasStartedForWorkout) {
                        // Workout Mode: Always play next track (Work or Rest)
                        this.playNext();
                    } else {
                        // Preview Mode: Loop single track
                        this.audio.currentTime = 0;
                        this.audio.play();
                    }
                };
            }

            setContinuous(enabled) {
                this.continuousMode = enabled;
                localStorage.setItem('fnh_continuous', enabled); // Persist
                // Loop is always FALSE now to support auto-advance.

                // Refinement: If enabled AND currently playing a 'rust' track (or paused in rest), switch immediately.
                if (enabled && this.hasStartedForWorkout) {
                    const isRestTrack = this.audio.src.includes('/rust/');
                    if (isRestTrack) {
                        console.log("Continuous Mode Enabled during Rest -> Switching to Work Track");
                        this.playNextWorkTrack();
                    }
                }
            }

            togglePlayback() {
                if (this.audio.paused) {
                    this.audio.play().catch(e => console.log("Resume Error", e));
                } else {
                    this.audio.pause();
                }
            }

            playNext() {
                // Determine direction based on current phase?
                // Or simply advance index?
                // If in 'work' phase, we play next work track.
                // If in 'rest' phase, we play next rest track.
                // Both use same playlistIndex.

                this.playlistIndex = this.getEnabledIndex(this.playlistIndex, 1);

                const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                // Note: currentType is 'werk'/'rust'.

                // Play
                const item = queue[this.playlistIndex];
                this.playSpecificTrack(item, this.currentType);
            }

            playPrevious() {
                let idx = this.playlistIndex;
                const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                if (queue.length === 0) return;

                // Find previous enabled
                let attempts = 0;
                do {
                    idx = (idx - 1 + queue.length) % queue.length;
                    attempts++;
                    const item = queue[idx];
                    if (this.enabledGenres.has(item.genre)) {
                        this.playlistIndex = idx;
                        break;
                    }
                } while (attempts < queue.length);

                const item = queue[this.playlistIndex];
                this.playSpecificTrack(item, this.currentType);
            }

            fadeOut(durationSeconds) {
                if (!this.audio || this.audio.paused) return;

                // Clear any existing fade
                if (this.fadeInterval) clearInterval(this.fadeInterval);

                const startVolume = this.audio.volume;
                const steps = 20; // updates per second
                const totalSteps = durationSeconds * steps;
                const volumeStep = startVolume / totalSteps;
                let currentStep = 0;

                console.log(`Starting Fade Out over ${durationSeconds}s from ${startVolume}`);

                this.fadeInterval = setInterval(() => {
                    currentStep++;
                    // QUADRATIC / SQUARED FADE (User Request)
                    let linearFactor = (totalSteps - currentStep) / totalSteps;
                    if (linearFactor < 0) linearFactor = 0;

                    let newVol = startVolume * (linearFactor * linearFactor);

                    try {
                        this.audio.volume = newVol;
                    } catch (e) {
                        // ignore rounding errors
                    }

                    if (currentStep >= totalSteps) {
                        clearInterval(this.fadeInterval);
                        this.fadeInterval = null;
                        this.audio.pause();
                        console.log("Fade Out Complete. Audio Paused.");
                    }
                }, 1000 / steps);
            }

            playSpecificTrack(item, type) {
                if (!item) return;
                // Safety check: is genre enabled?
                if (!this.enabledGenres.has(item.genre)) {
                    // Decide behavior: block play?
                    // If user manually clicked a disabled track in playlist?
                    // (They shouldn't see it due to showNowPlaying filter).
                    // If called programmatically?
                    // Safe to block.
                    console.log("Blocked playing disabled genre:", item.genre);
                    return;
                }

                // CANCEL ANY ACTIVE FADE
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }

                const path = `muziek/${item.genre}/${type}/${item.track}`;
                this.audio.src = path;
                // Maintain current volume based on TYPE
                this.audio.volume = (type === 'werk') ? this.volWork : this.volRest;
                this.audio.play().catch(e => console.log("Manual Play Error", e));
                this.showNowPlaying(item.track, item.genre, type === 'werk' ? 'work' : 'rest');
            }


            updateVolumes(work, rest) {
                this.volWork = work;
                this.volRest = rest;

                // Immediate Effect: Apply volume if currently playing relevant type
                // Note: 'werk' matches 'work' phase, 'rust' matches 'rest' phase
                if (this.audio && !this.audio.paused) {
                    if (this.currentType === 'werk') {
                        this.audio.volume = this.volWork;
                    } else {
                        this.audio.volume = this.volRest;
                    }
                }
            }

            // ... showNowPlaying is separate ...

            playNextWorkTrack() {
                // Deprecated / Mapped to playNext if called by legacy event
                this.playNext();
            }

            setGenres(list) {
                this.selectedGenres = list;
                this.hasStartedForWorkout = false;
            }

            startWorkout() {
                // if (this.selectedGenres.length === 0) return; // Removed to support enable-mid-workout
                this.hasStartedForWorkout = true;
                this.buildPlaylists(); // Build full pool
                this.renderGenreToggles(); // Render UI
                // REMOVED: this.playPhase('rest'); // Don't auto-start. Controller decides.
            }

            buildPlaylists() {
                this.workQueue = [];
                this.restQueue = [];
                this.enabledGenres = new Set(this.selectedGenres);

                // Use ONLY selected genres
                const activeGenres = this.selectedGenres.length > 0 ? this.selectedGenres : []; // If empty, emptiness ensues

                if (activeGenres.length === 0) return;

                // 1. Prepare temp buckets & Find Min Length (STOP at shortest)
                const bucketsWork = {};
                const bucketsRest = {};
                let minLen = Infinity;

                activeGenres.forEach(genre => {
                    bucketsWork[genre] = [];
                    bucketsRest[genre] = [];
                    const db = musicManifest[genre];
                    if (db) {
                        if (db.werk) db.werk.forEach(t => bucketsWork[genre].push({ track: t, genre: genre }));
                        if (db.rust) db.rust.forEach(t => bucketsRest[genre].push({ track: t, genre: genre }));

                        this.shuffle(bucketsWork[genre]);
                        this.shuffle(bucketsRest[genre]);

                        if (bucketsWork[genre].length < minLen) minLen = bucketsWork[genre].length;
                    }
                });

                if (minLen === Infinity) minLen = 0;

                // 2. Interleave (Strict Round Robin)
                // Stop when ANY genre runs out (minLen) to ensure equal representation
                for (let i = 0; i < minLen; i++) {
                    activeGenres.forEach(genre => {
                        // Work Track
                        if (bucketsWork[genre] && bucketsWork[genre][i]) {
                            this.workQueue.push(bucketsWork[genre][i]);

                            // Match Rest Track (wrap if needed, but minLen usually ensures availability)
                            if (bucketsRest[genre] && bucketsRest[genre].length > 0) {
                                const rIndex = i % bucketsRest[genre].length;
                                this.restQueue.push(bucketsRest[genre][rIndex]);
                            } else {
                                this.restQueue.push({ track: 'silence.mp3', genre: genre });
                            }
                        }
                    });
                }

                // 3. Reset Indices
                this.playlistIndex = 0;
                this.justFinishedWork = false;
            }



            // Helper to find next/prev enabled index
            getEnabledIndex(currentIndex, direction) {
                let idx = currentIndex;
                const queue = (this.workQueue.length > 0) ? this.workQueue : [];                // queue is Master Queue. Length should be safe.
                if (queue.length === 0) return 0;

                let attempts = 0;
                do {
                    idx = (idx + direction + queue.length) % queue.length;
                    attempts++;
                    const item = queue[idx];
                    if (this.enabledGenres.has(item.genre)) return idx;
                } while (attempts < queue.length);

                return currentIndex; // No enabled tracks found
            }

            // Check if current index is enabled, if not separate find next
            ensureValidIndex() {
                if (this.workQueue.length === 0) return;
                // Handle safe index wrapper
                this.playlistIndex = (this.playlistIndex || 0) % this.workQueue.length;

                const item = this.workQueue[this.playlistIndex];
                if (!item || !this.enabledGenres.has(item.genre)) {
                    this.playlistIndex = this.getEnabledIndex(this.playlistIndex, 1);
                }
            }

            toggleGenre(genre, isEnabled) {
                if (isEnabled) {
                    this.enabledGenres.add(genre);
                    // Auto-start if it was silenced?
                    if (this.audio.paused && this.hasStartedForWorkout && this.enabledGenres.size > 0) {
                        // Force a "refresh" of the current state
                        const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                        if (queue.length > 0) {
                            // Try to find a valid track
                            this.ensureValidIndex();
                            const item = queue[this.playlistIndex];
                            // If valid, play
                            if (item && this.enabledGenres.has(item.genre)) {
                                const path = `muziek/${item.genre}/${this.currentType === 'werk' ? 'werk' : 'rust'}/${item.track}`;
                                this.audio.src = path;
                                this.audio.play().catch(e => console.log("Resume play error", e));
                                this.showNowPlaying(item.track, item.genre, this.currentType === 'werk' ? 'work' : 'rest');
                            }
                        }
                    }
                } else {
                    this.enabledGenres.delete(genre);
                    // IMMEDIATE STOP if empty
                    if (this.enabledGenres.size === 0) {
                        this.audio.pause();
                        this.hideNowPlaying();
                        // Allow return, but ensure we save state first!
                    }
                }

                // FIXED: Persist Selection
                this.selectedGenres = Array.from(this.enabledGenres);
                localStorage.setItem('fnh_selected_genres', JSON.stringify(this.selectedGenres));

                if (this.enabledGenres.size === 0) return; // Exit after saving if empty

                this.ensureValidIndex();

                // Refresh Playlist UI if visible
                const nowEl = document.getElementById('gym-now-playing');
                if (nowEl) {
                    const queue = (this.currentType === 'werk') ? this.workQueue : this.restQueue;
                    const item = queue[this.playlistIndex];
                    if (item) this.showNowPlaying(item.track, item.genre, this.currentType === 'werk' ? 'work' : 'rest');
                }
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            stopWorkout() {
                this.audio.pause();
                this.audio.currentTime = 0;
                this.hasStartedForWorkout = false;
                this.hideNowPlaying();
            }

            refillQueue() {
                // No-op in new system, master queue is cyclic
            }

            getNextGenre() {
                return null; // Deprecated
            }

            playPhase(phase) {
                // CANCEL ANY ACTIVE FADE (Fix for Work Music not starting)
                if (this.fadeInterval) {
                    clearInterval(this.fadeInterval);
                    this.fadeInterval = null;
                }

                // if (this.selectedGenres.length === 0) return; // REMOVED!

                // VOLUME LOGIC
                const targetVol = (phase === 'work') ? this.volWork : this.volRest;
                this.audio.volume = targetVol;

                const previousType = this.currentType;
                this.currentType = (phase === 'work') ? 'werk' : 'rust';

                // CONTINUOUS MODE
                if (this.continuousMode && !this.audio.paused) {
                    // Start of FIX for "Only Rest Music Playing":
                    const isRestTrack = this.audio.src.includes('/rust/');
                    if (phase === 'work' && isRestTrack) {
                        console.log("Continuous Mode: Switching from Rest to Work track");
                        // Allow fall-through to switch track
                    } else {
                        return; // Logic as before: don't interrupt
                    }
                }

                // FIXED GENRE ORDER: "Rest should always precede Work"
                // This means we advance the genre index ONLY when transitioning from WORK to REST.
                // So: Rest(A) -> Work(A) -> [Next] Rest(B) -> Work(B)
                // Use 'previousType' because 'this.currentType' has already been updated to 'rust'
                if (phase !== 'work' && previousType === 'werk') {
                    this.playlistIndex = this.getEnabledIndex(this.playlistIndex, 1);
                }

                // Removed old "justFinishedWork" logic which was causing "Work -> Rest" order (Work B -> Rest B)
                // if (phase === 'work') { ... }

                this.ensureValidIndex();

                const queue = (phase === 'work') ? this.workQueue : this.restQueue;
                if (queue.length === 0) return;

                this.playlistIndex = this.playlistIndex % queue.length;
                const item = queue[this.playlistIndex];

                if (!item) return;

                // CRITICAL CHECK: Is this item actually enabled?
                // If ensureValidIndex failed to find an enabled track (e.g. all disabled), it returns current.
                // So we must check again.
                if (!this.enabledGenres.has(item.genre)) {
                    // All genres disabled (or logic issue). Stop/Pause.
                    this.audio.pause();
                    this.hideNowPlaying();
                    // Don't advance state or volume
                    return;
                }

                const path = `muziek/${item.genre}/${phase === 'work' ? 'werk' : 'rust'}/${item.track}`;
                this.audio.src = path;
                this.audio.play().catch(e => console.log("Play Error", e));
                this.showNowPlaying(item.track, item.genre, phase === 'work' ? 'work' : 'rest');

                if (phase === 'work') {
                    this.justFinishedWork = true;
                }
            }

            renderGenreToggles(targetId = null) {
                // Find or create container in audio settings
                let containerId = targetId || 'audio-settings-genres';
                let container = document.getElementById(containerId);

                if (!container && !targetId) {
                    // Create it after volume controls (Default behavior)
                    const parent = document.getElementById('active-volume-panel'); // ... existing creation logic ...
                    // (Simplified for this edit: reuse existing if possible, or fail gracefully if custom ID missing)
                    if (parent) {
                        container = document.createElement('div');
                        container.id = 'audio-settings-genres';
                        container.style.marginTop = "15px";
                        container.style.borderTop = "1px solid rgba(255,255,255,0.1)";
                        container.style.paddingTop = "10px";
                        // Insert before playlist-view if exists
                        const playlist = document.getElementById('playlist-view');
                        if (playlist) parent.insertBefore(container, playlist);
                        else parent.appendChild(container); // Append at end
                    }
                }
                if (!container) return;

                if (!targetId) {
                    container.innerHTML = "<div style='font-size:12px; font-weight:bold; color:#888; margin-bottom:5px;'>GENRES (LIVE)</div>";
                } else {
                    container.innerHTML = ""; // Clear custom container
                }

                // Show ALL manifest genres so user can enable music even if started with none.
                const allGenres = Object.keys(musicManifest);

                allGenres.forEach(genre => {
                    const row = document.createElement('div');
                    row.style.display = "flex";
                    row.style.alignItems = "center";
                    row.style.marginBottom = "5px";

                    const cb = document.createElement('input');
                    cb.type = "checkbox";
                    cb.checked = this.enabledGenres.has(genre);
                    cb.style.marginRight = "8px";
                    cb.style.cursor = "pointer";

                    cb.onchange = (e) => {
                        this.toggleGenre(genre, e.target.checked);
                    };

                    const lbl = document.createElement('span');
                    lbl.innerText = genre;
                    lbl.style.fontSize = "14px";

                    row.appendChild(cb);
                    row.appendChild(lbl);
                    container.appendChild(row);
                });
            }

            showNowPlaying(trackName, genre, type) {
                const nowEl = document.getElementById('gym-now-playing');
                const listEl = document.getElementById('gym-queue-list');

                if (nowEl) {
                    const cleanTitle = trackName.replace('.mp3', '');
                    nowEl.innerText = ` ${genre} - ${cleanTitle} (${type})`;
                }

                if (listEl) {
                    listEl.innerHTML = "";
                    const queue = (type === 'work' || type === 'work') ? this.workQueue : this.restQueue;
                    // Note: 'werk' vs 'work' consistency fix handled by '||' logic usually, 
                    // but here passed 'type' comes from call.
                    // playPhase sends 'work'/'rest'.

                    let displayIndex = 1;

                    queue.forEach((item, i) => {
                        // FILTER: Only show enabled genres
                        if (!this.enabledGenres.has(item.genre)) return;

                        const div = document.createElement('div');
                        div.style.padding = "4px 8px";
                        div.style.borderBottom = "1px solid rgba(255,255,255,0.05)";
                        div.style.cursor = "pointer";
                        div.className = "playlist-item";

                        const cleanTrack = item.track.replace('.mp3', '');

                        if (i === this.playlistIndex) {
                            div.style.color = "#30D158";
                            div.style.fontWeight = "bold";
                            div.innerText = ` ${cleanTrack} (${item.genre})`;
                        } else {
                            div.style.color = "#aaa";
                            div.innerText = `${displayIndex}. ${cleanTrack} (${item.genre})`;
                        }
                        displayIndex++;

                        div.onclick = () => {
                            this.playlistIndex = i;
                            this.playSpecificTrack(item, (type === 'work' || type === 'work') ? 'werk' : 'rust');
                            // Note: playSpecificTrack is legacy. Ideally should call playPhase-like logic?
                            // But playSpecificTrack is: audio.src = ...
                            // We should maintain it or update it.
                            // See logic below.
                        };

                        listEl.appendChild(div);
                    });
                }
            }

            hideNowPlaying() {
                const txt = document.getElementById('gym-now-playing');
                if (txt) txt.innerHTML = "";

                const list = document.getElementById('gym-queue-list');
                if (list) list.innerHTML = "";
            }
        }

        const bgMusicManager = new BackgroundMusicManager();

        window.addEventListener('load', function () {
            populateLiveCoachSelect(); // Ensure Select is ready for Save ops
            // renderMusicGenres(); // Removed (Old UI)
            // Ensure Audio Mode UI matches state
            updateLiveAudioUI();
        });

        function renderMusicGenres() {
            const container = document.getElementById('music-genres-container');
            if (!container) return;
            container.innerHTML = "";

            const genres = Object.keys(musicManifest);

            if (genres.length === 0) {
                container.innerHTML = "<div style='color:#666; font-size:12px;'>Geen muziek gevonden</div>";
                return;
            }

            genres.forEach(genre => {
                const div = document.createElement('div');
                div.className = 'gen-checkbox-item';
                div.innerHTML = `
                    <input type="checkbox" value="${genre}" class="music-genre-check" id="chk-genre-${genre}">
                    <label for="chk-genre-${genre}" style="cursor:pointer; color:#ccc; margin:0; text-transform:none;">${genre}</label>
                `;
                div.onclick = (e) => {
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'LABEL') {
                        const cb = div.querySelector('input');
                        cb.checked = !cb.checked;
                    }
                };
                container.appendChild(div);
            });
        }

        function getSelectedGenres() {
            const checks = document.querySelectorAll('.music-genre-check:checked');
            return Array.from(checks).map(c => c.value);
        }




        // Global Audio State (Priority System)
        let currentActiveSource = null;

        let currentAudioPriority = 0; // 0=Idle, 1=Low, 2=High

        function playMp3WebAudio(url, key, priority = 1) {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Check Cache
            if (audioCache[url]) {
                logAudioDebug(` WebAudio Cache: ${key} (P${priority})`);
                playBuffer(audioCache[url], priority, key);
                return;
            }

            // Fetch
            fetch(url)
                .then(response => {
                    if (!response.ok) throw new Error("404");
                    return response.arrayBuffer();
                })
                .then(arrayBuffer => audioCtx.decodeAudioData(arrayBuffer))
                .then(audioBuffer => {
                    audioCache[url] = audioBuffer;
                    logAudioDebug(` WebAudio Play: ${key} (P${priority})`);
                    playBuffer(audioBuffer, priority, key);
                })
                .catch(e => {
                    failedAudioKeys.add(key);
                    logAudioDebug(` WebAudio Fail: ${key}`);
                    console.error("WebAudio Error", e);
                });
        }

        function playBuffer(buffer, priority, key = "") {
            // STOP previous active sound if it exists
            if (currentActiveSource) {
                // EXCEPTION: Allow "Work Start" (P2) to overlap "Countdown" (P2)
                // This fixes the issue where "1" is cut off by "GO!"
                const curKey = currentActiveSource.customKey || "";
                const newKey = key || "";

                const isWorkStart = newKey.includes('work_start');
                // Cover common countdown keys: 'prep_countdown', 'count', '3', '2', '1'
                const isCountdown = curKey.includes('count') || curKey.includes('down') || ['1', '2', '3'].includes(curKey);

                const shouldOverlap = (isWorkStart && isCountdown);

                if (!shouldOverlap) {
                    logAudioDebug(` Stopping ${curKey} for ${newKey}`);
                    try {
                        currentActiveSource.stop();
                        currentActiveSource = null;
                    } catch (e) { console.log("Stop error", e); }
                } else {
                    logAudioDebug(` Mixing: ${curKey} + ${newKey}`);
                }
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            source.customKey = key; // Store for next comparison

            // VOLUME BOOST (for Mix Mode) - Adjusted by Coach Volume Slider
            const gainNode = audioCtx.createGain();
            // Base boost was 2.5. Multiply by coach volume (0.0 - 1.0)
            const coachVolInput = document.getElementById('vol-coach-live');
            const coachVol = coachVolInput ? parseFloat(coachVolInput.value) : parseFloat(localStorage.getItem('fnh_vol_coach') || 1.0);
            gainNode.gain.value = 2.5 * coachVol;

            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            // Update State
            // Only update "Current Active" if we stopped the old one OR if it's a new dominant sound?
            // If we are mixing, we have TWO sources.
            // If we replace the pointer `currentActiveSource` with the new one, the old one just plays out (Good).
            // But if the old one ends cleanly, its onended might clear the NEW one's priority if we are not careful?
            // Logic below handles this: `if (currentActiveSource === source)`
            // Since we update `currentActiveSource` to the NEW source, the old source's onended will see mismatch and do nothing.
            // Perfect.

            currentActiveSource = source;
            currentAudioPriority = priority;

            source.onended = function () {
                // Only reset if THIS was the active source
                if (currentActiveSource === source) {
                    currentAudioPriority = 0;
                    currentActiveSource = null;
                }
            };

            source.start(0);
        }

        function addBonusStep(r, label, time, rest, bId) {
            schedule.push({
                type: 'work',
                time: time,
                initialTime: time,
                label: label,
                info: { round: r, exercise: 0, set: 0, globalSet: 0, bonusId: bId } // 0 indicates bonus
            });
            schedule.push({
                type: 'rest-exercise',
                time: rest,
                initialTime: rest,
                label: "WISSEL",
                info: { round: r, exercise: 0, set: 0, text: "Klaarmaken..." }
            });
        }

        function renderPreviewList() {
            const list = document.getElementById('preview-list'); list.innerHTML = ""; let runningDate = new Date();
            schedule.forEach((item) => {
                if (item.type === 'finish') return;
                let timeStr = runningDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                runningDate.setSeconds(runningDate.getSeconds() + item.time);
                const div = document.createElement('div'); div.className = `schedule-item`;
                let icon = ""; if (item.type === 'rest-long') { div.style.borderLeft = "4px solid #0A84FF"; icon = ''; } else if (item.type === 'rest-exercise') { div.style.borderLeft = "4px solid #BF5AF2"; icon = ''; } else if (item.type === 'work') icon = ''; else if (item.type === 'rest') icon = ''; else icon = '';
                let desc = item.label;
                // If it's a generic label and we have a custom name, use that?
                // Actually, generateScheduleData now sets item.label to customNames if available.
                // But if we want to add (R1/E1/S1) suffix:
                if (item.info && item.info.round && item.info.exercise > 0) desc += ` (R${item.info.round}/E${item.info.exercise}/S${item.info.set})`;
                div.innerHTML = `<div class="col-time">${timeStr}</div><div class="col-desc">${icon} ${desc}</div><div class="col-dur">${item.time}s</div>`;
                list.appendChild(div);
            });
        }

        function triggerAudio(key, fallbackText, extraInfo = "") {
            try {
                if (audioMode === 'beep') {
                    if (key.includes('work')) playBeep(800, 'start');
                    else if (key.includes('rest')) playBeep(400, 'end');
                    else if (key === 'tick') playBeep(600, 'tick');
                    else if (key === 'finish') playBeep(1000, 'win');
                    else if (key === 'prep_countdown') {
                        // 3 beeps for 3-2-1
                        playBeep(600, 'tick');
                        setTimeout(() => playBeep(600, 'tick'), 1000);
                        setTimeout(() => playBeep(600, 'tick'), 2000);
                    }
                    return;
                }

                // MP3 Support Logic
                const coachId = document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : 'eva'; // UPDATED


                // Check Enable/Disable Toggle
                if (speechSettings[key] && speechSettings[key].enabled === false) {
                    logAudioDebug(` Silenced by user setting: ${key}`);
                    return;
                }

                if (coachId && coachId !== 'loading' && !failedAudioKeys.has(key)) {
                    let finalKey = key;

                    // Retrieve variants config for this coach
                    const preset = coachPresets[coachId];
                    const variantsMap = preset ? (preset.variants || {}) : {};

                    // --- VARIANT LOGIC ---
                    if (variantsMap[key] && variantsMap[key] >= 1) {
                        const count = variantsMap[key];
                        // Initialize playlist if needed
                        if (!audioPlaylists[key]) {
                            const arr = Array.from({ length: count }, (_, i) => i + 1);
                            // Fisher-Yates Shuffle
                            for (let i = arr.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [arr[i], arr[j]] = [arr[j], arr[i]];
                            }
                            audioPlaylists[key] = { tracks: arr, ptr: 0 };
                        }
                        const pl = audioPlaylists[key];
                        const variantId = pl.tracks[pl.ptr];
                        pl.ptr = (pl.ptr + 1) % pl.tracks.length;
                        finalKey = `${key}_${variantId}`;
                    }

                    logAudioDebug(` Attempting MP3: ${coachId}/${finalKey}.mp3`);
                    const mp3Path = `coaches/${coachId}/${finalKey}.mp3`;

                    // ALWAYS USE WEB AUDIO MIX MODE (Better Priority & Overlap Handling)
                    // Priority Mapping
                    let priority = 1; // Default: Low
                    const highPriorityKeys = [
                        'work_start', 'rest_start', 'rest_set_start',
                        'rest_switch_start', 'rest_round_start',
                        'prep_countdown', 'finish',
                        'work_start_lastround',
                        'manual_override', 'work_complete', 'rest_complete',
                        'tick'
                    ];

                    // Check Priority
                    if (highPriorityKeys.includes(key) || key.includes('work_start') || key.includes('count') || ['1', '2', '3'].includes(key)) {
                        priority = 2;
                    }

                    // PRIORITY RULE:
                    // If P2 comes in -> Stop everything (handled in playBuffer) and Play.
                    // If P1 comes in -> ONLY play if current is 0. If current is 2, IGNORE P1.
                    if (priority === 1 && currentAudioPriority === 2) {
                        logAudioDebug(` Skipped Low Priority: ${key} (Busy w/ High)`);
                        return;
                    }

                    playMp3WebAudio(mp3Path, key, priority);
                    return;
                }

                // (Legacy fallback removed - WebAudio is enforced)
                return;
            } catch (e) {
                console.error("Audio Trigger Error", e);
                logAudioDebug(` Audio Error: ${e.message}`);
            }
        }

        function testMixModeSound() {
            logAudioDebug(" Sound Check Triggered");

            // Replicate triggerAudio logic regarding Mix Mode
            if (iosMixMode) {
                playMp3WebAudio('sound_check.mp3', 'sound_check', 2);
            } else {
                globalCoachAudio.src = 'sound_check.mp3';
                globalCoachAudio.play()
                    .then(() => logAudioDebug(" Standard Audio Check"))
                    .catch(e => logAudioDebug(" Standard Audio Fail: " + e.message));
            }
        }

        function logAudioDebug(msg) {
            const loginfo = document.getElementById('audio-debug-log');
            if (loginfo) {
                const line = document.createElement('div');
                const time = new Date().toLocaleTimeString('nl-NL', { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
                line.innerText = `[${time}] ${msg}`;
                loginfo.prepend(line);
                // Keep only last 20 lines
                while (loginfo.children.length > 20) {
                    loginfo.removeChild(loginfo.lastChild);
                }
            }
        }

        function playBeep(f, t) { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); const o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.frequency.value = f; o.type = 'sine'; const n = audioCtx.currentTime; if (t === 'tick') { g.gain.setValueAtTime(0.1, n); o.start(n); o.stop(n + 0.1); } else if (t === 'win') { g.gain.setValueAtTime(0.1, n); o.start(n); o.stop(n + 0.2); setTimeout(() => playBeep(1200, 'tick'), 300); } else { g.gain.setValueAtTime(0.3, n); o.start(n); o.stop(n + 0.5); } }

        let preWorkoutInterval = null;

        function startWorkout() {
            // Audio Context for Beep Mode (Ensure resumed)
            if (audioMode === 'beep') { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); }

            const startStr = document.getElementById('startTimeValue').value;
            if (startStr) {
                const now = new Date();
                const [h, m] = startStr.split(':');
                const targetStart = new Date();
                targetStart.setHours(h, m, 0, 0);

                // FIX: If time is in the past, treat as "Next Day" (Wrap 24h)
                // User requested: "Countdown to tomorrow" instead of immediate start
                if (targetStart <= now) {
                    targetStart.setDate(targetStart.getDate() + 1);
                }

                // CHECK: If we are already active (Edit Mode), resume instead
                if (isWorkoutActive && globalWorkoutStartVal) {
                    resumeSyncWorkout();
                    return;
                }

                if (targetStart > now) {
                    // Show Countdown Overlay
                    const overlay = document.getElementById('pre-workout-overlay');
                    const timerEl = document.getElementById('pre-workout-timer');
                    const startInfoEl = document.getElementById('pre-workout-start-time'); // NEW

                    overlay.style.display = 'flex';
                    if (startInfoEl) startInfoEl.innerText = `STARTTIJD: ${startStr}`;

                    // NEW: Show Jump In button if start was in the past (wraps to tomorrow)
                    const jumpBtn = document.getElementById('btn-jump-in');
                    if (jumpBtn) {
                        const originalTarget = new Date();
                        originalTarget.setHours(h, m, 0, 0);
                        if (originalTarget < now) {
                            jumpBtn.style.display = 'block';
                            jumpBtn.setAttribute('data-original-start', originalTarget.getTime());
                        } else {
                            jumpBtn.style.display = 'none';
                        }
                    }

                    // AUDIO CONTROLS INIT (PRE-WORKOUT)
                    const volWorkPre = document.getElementById('vol-music-pre');
                    const volRestPre = document.getElementById('vol-rest-pre');
                    const valVolWorkPre = document.getElementById('val-vol-work-pre');
                    const valVolRestPre = document.getElementById('val-vol-rest-pre');
                    const chkContPre = document.getElementById('chk-continuous-pre');

                    // Sync with current Manager state
                    if (volWorkPre) {
                        volWorkPre.value = bgMusicManager.volWork;
                        valVolWorkPre.innerText = Math.round(bgMusicManager.volWork * 100) + "%";
                        volWorkPre.oninput = (e) => {
                            const v = parseFloat(e.target.value);
                            bgMusicManager.volWork = v;
                            valVolWorkPre.innerText = Math.round(v * 100) + "%";
                            // If playing work, update live
                            if (bgMusicManager.currentType === 'werk') bgMusicManager.audio.volume = v;
                            // Also sync main settings
                            const main = document.getElementById('vol-music-live'); if (main) main.value = v;
                            localStorage.setItem('fnh_vol_music', v);
                        };
                    }
                    if (volRestPre) {
                        volRestPre.value = bgMusicManager.volRest;
                        valVolRestPre.innerText = Math.round(bgMusicManager.volRest * 100) + "%";
                        volRestPre.oninput = (e) => {
                            const v = parseFloat(e.target.value);
                            bgMusicManager.volRest = v;
                            valVolRestPre.innerText = Math.round(v * 100) + "%";
                            // If playing rest, update live
                            if (bgMusicManager.currentType === 'rust') bgMusicManager.audio.volume = v;
                            // Also sync main settings
                            const main = document.getElementById('vol-music-rest-live'); if (main) main.value = v;
                            localStorage.setItem('fnh_vol_music_rest', v);
                        };
                    }
                    if (chkContPre) {
                        chkContPre.checked = bgMusicManager.continuousMode;
                        chkContPre.onchange = (e) => {
                            bgMusicManager.setContinuous(e.target.checked);
                            // Sync main
                            const main = document.getElementById('chk-music-continuous'); if (main) main.checked = e.target.checked;

                            // Live Switch Logic for Countdown
                            if (e.target.checked) {
                                // Switched ON -> Play Work Music immediately
                                bgMusicManager.playPhase('work');
                            } else {
                                // Switched OFF -> Play Rest Music immediately
                                bgMusicManager.playPhase('rest');
                            }
                        };
                    }

                    // MUSIC START (Immediate)
                    // Ensure Manager is initialized (builds playlists -> syncs enabledGenres) BEFORE rendering UI
                    if (!bgMusicManager.hasStartedForWorkout) {
                        bgMusicManager.startWorkout();
                    }

                    // Render Genres (Now using fresh enabledGenres)
                    bgMusicManager.renderGenreToggles('pre-workout-genres');

                    // LPOGIC: If Continuous Mode, Play Work Music NOW
                    if (bgMusicManager.continuousMode) {
                        bgMusicManager.playPhase('work');
                    } else {
                        bgMusicManager.playPhase('rest');
                    }

                    // Initial wake lock attempt (user interaction context)
                    if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(console.log);

                    clearInterval(preWorkoutInterval);

                    const updateTimer = () => {
                        const currentNow = new Date();
                        const diffMs = targetStart - currentNow;

                        if (diffMs <= 0) {
                            clearInterval(preWorkoutInterval);
                            overlay.style.display = 'none';
                            performStart();
                            return;
                        }

                        // Format MM:SS
                        const totalSec = Math.ceil(diffMs / 1000);
                        const mins = Math.floor(totalSec / 60);
                        const secs = totalSec % 60;
                        timerEl.innerText = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                    };

                    updateTimer(); // Immediate update
                    preWorkoutInterval = setInterval(updateTimer, 1000);
                    return;
                }
            }
            // No delay needed
            performStart();
        }

        function performStart() {
            // Hide overlay if manual skip was triggered
            document.getElementById('pre-workout-overlay').style.display = 'none';
            if (preWorkoutInterval) clearInterval(preWorkoutInterval);
            if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(console.log);
            if (audioMode === 'beep') { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume(); } else { if (window.speechSynthesis) window.speechSynthesis.cancel(); }

            window.lastStepChangeTime = Date.now(); // SAFETY: Set anchor on actual start
            clearInterval(timerInterval); // Ensure no previous timer is running

            // SET GLOBAL ACTIVE STATE
            isWorkoutActive = true;
            globalWorkoutStartVal = Date.now();
            updateStartButtonState();

            // LOGGING START
            try {
                logWorkoutToSheet();
            } catch (err) {
                console.log("Logging failed", err);
            }

            // Ensure times are fresh
            // FIX: Force Start Time Input to NOW. performStart() means we are starting immediately.
            // This ensures calculateRealTime() sees the correct "Now" time vs End Time.
            const now = new Date();
            document.getElementById('startTimeValue').value = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

            calculateRealTime();
            generateScheduleData(true);
            populateJumpMenus();

            document.getElementById('setup-screen').classList.add('hidden');
            // Scroll Fix v1.9: Use block display for reliable scrolling
            // Reset style completely to remove !important inline hider
            const ts = document.getElementById('timer-screen');
            ts.style.cssText = '';
            ts.style.display = 'block';

            workoutStartTime = new Date();
            const [h, m] = document.getElementById('endTimeValue').value.split(':');
            targetEndTimeDate = new Date(); targetEndTimeDate.setHours(h, m, 0, 0);
            if (targetEndTimeDate < workoutStartTime) targetEndTimeDate.setDate(targetEndTimeDate.getDate() + 1);

            updateEndTimeDisplay();
            currentIndex = 0;
            audioPlaylists = {}; // Reset Shuffle Queues
            failedAudioKeys.clear(); // Reset MP3 failures on new workout start
            milestonesTriggered = { m25: false, m50: false, m75: false }; // Reset milestones
            stepEndTime = Date.now() + (schedule[0].time * 1000);

            // NEW: Render Live Schedule
            renderLiveSchedule();

            // MUSIC START
            // bgMusicManager.setGenres(getSelectedGenres()); // REMOVED: Respect persistent state
            // Only start if not already started (e.g. by overlay)
            if (!bgMusicManager.hasStartedForWorkout) {
                bgMusicManager.startWorkout();
            }

            runStep();
        }

        function startSyncWorkout() {
            const jumpBtn = document.getElementById('btn-jump-in');
            const originalStartMs = parseInt(jumpBtn.getAttribute('data-original-start'));
            if (!originalStartMs) return;

            const now = Date.now();
            let elapsedSec = Math.floor((now - originalStartMs) / 1000);

            // 1. Prepare Workout
            calculateRealTime();
            generateScheduleData(true);
            populateJumpMenus();

            // 2. Find Sync Point
            let foundIdx = 0;
            let cumulativeSec = 0;
            for (let i = 0; i < schedule.length; i++) {
                const stepTime = schedule[i].time;
                if (cumulativeSec + stepTime > elapsedSec) {
                    foundIdx = i;
                    break;
                }
                cumulativeSec += stepTime;
                foundIdx = i; // Fallback to last if totally over
            }

            // 3. Jump to that point
            currentIndex = foundIdx;
            const remainingInStep = (cumulativeSec + schedule[foundIdx].time) - elapsedSec;

            // 4. Perform Start
            document.getElementById('pre-workout-overlay').style.display = 'none';
            if (preWorkoutInterval) clearInterval(preWorkoutInterval);
            if ('wakeLock' in navigator) navigator.wakeLock.request('screen').catch(console.log);
            if (audioMode === 'beep') { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); }

            document.getElementById('setup-screen').classList.add('hidden');
            const ts = document.getElementById('timer-screen');
            ts.style.cssText = '';
            ts.style.display = 'block';

            workoutStartTime = new Date(originalStartMs);
            // Sync Global
            globalWorkoutStartVal = originalStartMs;
            isWorkoutActive = true;
            updateStartButtonState(); // Update text to "Return"
            const [h, m] = document.getElementById('endTimeValue').value.split(':');
            targetEndTimeDate = new Date(); targetEndTimeDate.setHours(h, m, 0, 0);

            updateEndTimeDisplay();
            audioPlaylists = {};
            failedAudioKeys.clear();
            milestonesTriggered = { m25: false, m50: false, m75: false };

            // Start Step with remaining time
            stepEndTime = Date.now() + (remainingInStep * 1000);
            renderLiveSchedule();

            if (!bgMusicManager.hasStartedForWorkout) {
                bgMusicManager.startWorkout();
            }

            runStep();
            triggerAudio('manual_override', "Ingehaakt op huidige moment");
        }

        function populateJumpMenus() {
            // UPDATED: Use workoutRounds instead of legacy inputs
            let rounds = 1;
            let maxEx = 1;
            let maxSets = 1;

            if (typeof workoutRounds !== 'undefined' && workoutRounds.length > 0) {
                rounds = workoutRounds.length;
                workoutRounds.forEach(r => {
                    if (r.exercises > maxEx) maxEx = r.exercises;
                    if (r.sets > maxSets) maxSets = r.sets;
                });
            } else {
                // Fallback
                rounds = parseInt(document.getElementById('rounds').value) || 1;
                maxEx = parseInt(document.getElementById('exercises').value) || 1;
                maxSets = parseInt(document.getElementById('sets').value) || 1;
            }

            const rSel = document.getElementById('jump-round'); const eSel = document.getElementById('jump-exercise'); const sSel = document.getElementById('jump-set');
            rSel.innerHTML = ""; eSel.innerHTML = ""; sSel.innerHTML = "";
            for (let i = 1; i <= rounds; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = "Ronde " + i; rSel.appendChild(opt); }
            for (let i = 1; i <= maxEx; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = "Oef " + i; eSel.appendChild(opt); }
            for (let i = 1; i <= maxSets; i++) { const opt = document.createElement('option'); opt.value = i; opt.text = "Set " + i; sSel.appendChild(opt); }
        }

        function handleJump() {
            const r = parseInt(document.getElementById('jump-round').value); const e = parseInt(document.getElementById('jump-exercise').value); const s = parseInt(document.getElementById('jump-set').value);
            const newIndex = schedule.findIndex(step => { return step.type === 'work' && step.info && step.info.round === r && step.info.exercise === e && step.info.set === s; });
            if (newIndex > -1) {
                // FIXED: Use same logic as Schedule List Click (Popup for Skip/Adjust)
                jumpToStep(newIndex);
            }
        }

        function runStep() {
            if (currentIndex >= schedule.length) return;
            try {
                const step = schedule[currentIndex];
                const nextStep = schedule[currentIndex + 1];
                const totalRounds = parseInt(document.getElementById('rounds').value);
                const totalEx = document.getElementById('exercises').value;

                const body = document.body; body.className = '';
                const titleEl = document.getElementById('gym-phase-title'); const nextEl = document.getElementById('gym-next-info');

                // MUSIC UPDATE
                if (step.type === 'finish') {
                    bgMusicManager.stopWorkout();
                } else if (step.type === 'work') {
                    bgMusicManager.playPhase('work');
                } else {
                    bgMusicManager.playPhase('rest');
                }

                if (step.info && step.info.maxRounds) {
                    document.getElementById('val-round').innerText = `${step.info.round}/${step.info.maxRounds}`;
                    // Only show exercise/set if not 0 (extra phase)
                    if (step.info.exercise > 0) {
                        document.getElementById('val-exercise').innerText = `${step.info.exercise}/${step.info.maxEx}`;
                        document.getElementById('val-set').innerText = `${step.info.set}/${step.info.maxSets}`;
                        document.getElementById('jump-round').value = step.info.round; document.getElementById('jump-exercise').value = step.info.exercise; document.getElementById('jump-set').value = step.info.set;
                    } else {
                        document.getElementById('val-exercise').innerText = "-";
                        document.getElementById('val-set').innerText = "-";
                    }
                    document.getElementById('gym-stats-container').style.opacity = 1;
                } else { document.getElementById('gym-stats-container').style.opacity = 0.5; }

                // NEW: Update Live Schedule Highlight
                updateLiveScheduleHighlight();

                // Dynamic Inner Ring Color (based on NEXT step)
                let nextColor = '#30D158'; // Default Green (Work)
                let nextGlow = 'rgba(48, 209, 88, 0.6)';
                if (nextStep) {
                    if (nextStep.type === 'work') { nextColor = '#30D158'; nextGlow = 'rgba(48, 209, 88, 0.6)'; }
                    else if (nextStep.type === 'rest') { nextColor = '#FF9F0A'; nextGlow = 'rgba(255, 159, 10, 0.6)'; }
                    else if (nextStep.type === 'rest-exercise') { nextColor = '#BF5AF2'; nextGlow = 'rgba(191, 90, 242, 0.6)'; }
                    else if (nextStep.type === 'rest-long') { nextColor = '#0A84FF'; nextGlow = 'rgba(10, 132, 255, 0.6)'; }
                    else if (nextStep.type === 'finish') { nextColor = '#FFD60A'; nextGlow = 'rgba(255, 214, 10, 0.6)'; }
                    else if (nextStep.type === 'prep') { nextColor = '#3a3a3c'; nextGlow = 'rgba(58, 58, 60, 0.6)'; }
                } else {
                    nextColor = '#FFD60A'; nextGlow = 'rgba(255, 214, 10, 0.6)';
                }

                // Current Color Logic for Background (Smooth Transition)
                let currentColor = '#000000';
                if (step.type === 'work') currentColor = '#30D158';
                else if (step.type === 'rest') currentColor = '#FF9F0A';
                else if (step.type === 'rest-exercise') currentColor = '#BF5AF2';
                else if (step.type === 'rest-long') currentColor = '#0A84FF';
                else if (step.type === 'prep') currentColor = '#3a3a3c';

                const hgBg = document.getElementById('hourglass-bg');
                if (hgBg) {
                    hgBg.style.backgroundColor = currentColor;
                }

                // ANCHOR FOR PROGRESS BAR (SAFE MODE)
                window.lastStepChangeTime = Date.now();

                const ringStep = document.getElementById('ring-step');
                if (ringStep) {
                    ringStep.style.stroke = "#ffffff"; // Always White
                    ringStep.style.filter = `drop-shadow(0 0 10px rgba(255,255,255,0.4))`;
                }

                titleEl.innerText = step.label;
                titleEl.className = 'gym-phase-title';
                if (step.label === 'WERKEN' || step.label === 'RUST' || step.type === 'work') {
                    // Dynamic Sizing based on character count
                    if (step.label.length > 20) {
                        titleEl.classList.add('long-text');
                    } else if (step.label.length < 10) {
                        titleEl.classList.add('huge-text');
                    }
                    // Else: Normal (8vw)
                }

                let nextText = "Hierna: Klaar";
                if (nextStep) { nextText = "Hierna: " + nextStep.label; if (nextStep.type === 'work' && nextStep.info && nextStep.info.exercise > 0) nextText += ` (Oef ${nextStep.info.exercise})`; }
                nextEl.innerText = nextText;

                // Set Hourglass Color immediately at start of step
                const hgFill = document.getElementById('hourglass-fill');
                if (hgFill) {
                    hgFill.style.backgroundColor = nextColor;
                    // INSTANT RESET: Disable transition to prevent "falling" look
                    hgFill.style.transition = 'none';
                    hgFill.style.height = "0%";
                    // Force reflow
                    hgFill.offsetHeight;
                    // Restore transition (needs to match CSS: height 1s linear, background-color 0.5s ease)
                    hgFill.style.transition = 'height 1s linear, background-color 0.5s ease';
                }

                if (!step.hasPlayedEntry) {
                    step.hasPlayedEntry = true;
                    if (step.type === 'work') {
                        body.classList.add('mode-work');
                        // Standard work audio triggers
                        if (step.info.exercise > 0 || step.info.bonusId) {
                            // ALWAYS trigger "Start" (High Priority)
                            // NEW: Check for First Set of Last Exercise (Last Round only? User said "Laatste Oefening" replacing "Laatste Ronde")
                            // Assuming Last Round -> Last Exercise -> Set 1.
                            if (step.info.round === step.info.maxRounds && step.info.exercise === step.info.maxEx && step.info.set === 1) {
                                triggerAudio('work_start_lastround', "Start laatste oefening");
                            } else {
                                triggerAudio('work_start', "Start");
                            }

                            // Removed mile_lastround logic per request
                        }
                    }
                    else if (step.type === 'rest') {
                        body.classList.add('mode-rest');
                        let info = ""; if (speechSettings.rest_set_tips && speechSettings.rest_set_tips.enabled) { const tips = ["Adem in, adem uit", "Schud je spieren los", "Slokje water", "Blijf gefocust"]; info = tips[Math.floor(Math.random() * tips.length)]; }
                        triggerAudio('rest_set_start', "Rust", info);
                    }
                    else if (step.type === 'rest-exercise') {
                        body.classList.add('mode-switch');
                        let info = ""; if (speechSettings.rest_switch_info && speechSettings.rest_switch_info.enabled && nextStep && nextStep.info && nextStep.info.exercise > 0) { info = `Hierna oefening ${nextStep.info.exercise} van de ${totalEx}`; }
                        triggerAudio('rest_switch_start', "Wissel", info);
                    }
                    else if (step.type === 'rest-long') {
                        body.classList.add('mode-long');
                        let info = ""; if (speechSettings.rest_round_info && speechSettings.rest_round_info.enabled && nextStep && nextStep.info) { info = `Hierna ronde ${nextStep.info.round} van de ${totalRounds}`; }
                        triggerAudio('rest_round_start', "Grote pauze", info);
                    }
                    else if (step.type === 'prep') { body.classList.add('mode-prep'); triggerAudio('prep_intro', "Welkom"); }
                    else { finish(); return; }
                } else {
                    // Ensure class is correct valid even if we didn't play audio
                    if (step.type === 'work') body.classList.add('mode-work');
                    else if (step.type === 'rest') body.classList.add('mode-rest');
                    else if (step.type === 'rest-exercise') body.classList.add('mode-switch');
                    else if (step.type === 'rest-long') body.classList.add('mode-long');
                    else if (step.type === 'prep') body.classList.add('mode-prep');
                }

                stepEndTime = Date.now() + (step.time * 1000);
                document.getElementById('countdown').innerText = step.time;

                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    if (!isPaused) {
                        const now = Date.now();
                        const remainingMs = stepEndTime - now;
                        let remainingSec = Math.ceil(remainingMs / 1000);

                        // HOURGLASS ANIMATION
                        if (hgFill) {
                            const totalDurMs = step.initialTime * 1000;
                            if (totalDurMs > 0) {
                                let pct = 100 - ((remainingMs / totalDurMs) * 100);
                                if (pct < 0) pct = 0;
                                if (pct > 100) pct = 100;
                                hgFill.style.height = pct + "%";
                            }
                        }

                        if (remainingSec < 0) {
                            while (remainingSec < 0) {
                                currentIndex++; if (currentIndex >= schedule.length) { finish(); return; }
                                const skippedStep = schedule[currentIndex];
                                stepEndTime += (skippedStep.time * 1000);
                                remainingSec = Math.ceil((stepEndTime - Date.now()) / 1000);
                            }
                            runStep(); return;
                        }

                        step.time = remainingSec;
                        document.getElementById('countdown').innerText = step.time;

                        // REAL TIME SYNC ENGINE:
                        // 1. Verify/Update Schedule & Get Authoritative End Time
                        const rtcEndTime = renderLiveSchedule();

                        // 2. Sync Global End Time & Display
                        if (rtcEndTime && !isNaN(rtcEndTime.getTime())) {
                            targetEndTimeDate = rtcEndTime;
                            updateEndTimeDisplay(); // Keep text synced
                        }

                        // 3. Update Rings using the synced time
                        updateProgressRings(step.time, step.initialTime);

                        const totalDiff = targetEndTimeDate - now;
                        if (totalDiff > 0) {
                            const m = Math.floor(totalDiff / 60000); const s = Math.floor((totalDiff % 60000) / 1000);
                            const circleRem = document.getElementById('circle-remaining');
                            if (circleRem) circleRem.innerText = `${m}m ${s}s`;
                        } else {
                            const circleRem = document.getElementById('circle-remaining');
                            if (circleRem) circleRem.innerText = "0m 0s";
                        }

                        const init = step.initialTime;
                        if (step.type === 'work') {
                            let audioTriggered = false;
                            if (step.time === Math.floor(init / 2) && init >= 20) {
                                triggerAudio('work_halfway', "Halverwege");
                                audioTriggered = true;
                            }
                            if (!audioTriggered && step.time === 30 && init > 40) {
                                triggerAudio('work_30s', "30 seconden");
                                audioTriggered = true;
                            }
                            if (!audioTriggered && step.time === 10 && init > 20) {
                                triggerAudio('work_10s', "10 seconden");
                            }
                        }
                        if (step.type === 'rest-long' && step.time === 15 && init > 20) triggerAudio('rest_round_15s', "Nog 15 seconden, ga naar je oefening");
                        if (step.type === 'rest-exercise' && step.time === 10 && init > 15) triggerAudio('rest_switch_10s', "Nog 10 seconden");

                        if (step.time <= 0) { clearInterval(timerInterval); currentIndex++; runStep(); }
                        else if (step.time <= 5) {
                            // FADE OUT REST MUSIC (User Request: Start at 5s, End at 1s -> 4s duration)
                            // This ensures the last second ("1") is completely silent.
                            if (step.time === 5 && (step.type === 'rest' || step.type === 'rest-exercise' || step.type === 'rest-long' || step.type === 'prep')) {
                                bgMusicManager.fadeOut(4);
                            }

                            // COUNTDOWN AUDIO (Still starts at 3s)
                            if (step.time <= 3) {
                                if (speechSettings.use_mp3) {
                                    // MP3 Mode: Trigger prep_countdown once at 3s. Silence at 2s/1s.
                                    if (step.time === 3) triggerAudio('prep_countdown', "3 2 1");
                                } else {
                                    // TTS Mode: Individual ticks
                                    triggerAudio('tick', step.time.toString());
                                }
                            }
                        }
                    } else {
                        // Do nothing while paused
                    }
                }, 1000);
            } catch (e) {
                console.error("CRITICAL ERROR IN RUNSTEP:", e);
                alert("Fout in timer: " + e.message + "\n\nMaak een screenshot en stuur dit door!");
            }
        }

        function triggerEndTimeEdit() {
            const timeStr = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            const input = document.getElementById('hidden-endtime-input'); input.value = timeStr;
            if ('showPicker' in HTMLInputElement.prototype) { try { input.showPicker(); } catch (e) { input.click(); } } else { input.click(); }
        }

        function handleNewEndTime(newVal) {
            if (!newVal) return;
            const [h, m] = newVal.split(':'); const newDate = new Date(); newDate.setHours(h, m, 0, 0);
            const now = new Date();
            if (newDate < now) { if (newDate.getTime() < now.getTime() - 12 * 3600 * 1000) { newDate.setDate(newDate.getDate() + 1); } }

            targetEndTimeDate = newDate;
            updateEndTimeDisplay(); recalculateForFixedEnd();
            renderLiveSchedule(); // Re-render to show updated times if needed
            triggerAudio('manual_override', "Eindtijd aangepast, schema herberekend");
        }

        function recalculateForFixedEnd() {
            const now = new Date();
            const secsRemaining = Math.floor((targetEndTimeDate - now) / 1000);
            let workStepsLeft = 0; let fixedRest = 0;
            for (let i = currentIndex; i < schedule.length; i++) {
                if (schedule[i].type === 'finish') continue;
                if (schedule[i].type.includes('rest')) fixedRest += schedule[i].time;
                else if (schedule[i].type === 'work') {
                    // Check if it's a regular exercise or extra start
                    // We only adjust regular exercises.
                    // Extra start is considered fixed time (like rest).
                    if (schedule[i].info && schedule[i].info.exercise > 0) {
                        workStepsLeft++;
                    } else {
                        fixedRest += schedule[i].time; // Treat extra work as fixed rest time for calc purposes
                    }
                }
                else if (schedule[i].type === 'prep') workStepsLeft++; // Prep usually 10s fixed, but kept logic same
            }

            if (workStepsLeft > 0) {
                const availableForWork = secsRemaining - fixedRest;
                let newWork = Math.floor(availableForWork / workStepsLeft);
                if (newWork < 5) newWork = 5;

                const currentIsWork = (schedule[currentIndex].type === 'work' && schedule[currentIndex].info.exercise > 0);
                const oldWorkVal = schedule[currentIndex].initialTime;

                for (let i = currentIndex; i < schedule.length; i++) {
                    if (schedule[i].type === 'work' && schedule[i].info.exercise > 0) {
                        schedule[i].time = newWork; schedule[i].initialTime = newWork;
                    }
                }
                if (currentIsWork) {
                    const diff = newWork - oldWorkVal;
                    stepEndTime += (diff * 1000);
                    document.getElementById('countdown').innerText = Math.ceil((stepEndTime - Date.now()) / 1000);
                }
            }
        }

        function handlePauseClick() {
            const btn = document.getElementById('btn-pause');

            // Toggle state? 
            // Current flow: Pause -> Menu. Resume is handled by Menu buttons.
            // If we are already paused and menu is closed (e.g. via Cancel), clicking Play opens menu again.

            if (!isPaused) {
                isPaused = true;
                pauseStartTime = Date.now();
                if (btn) btn.innerText = "";
                document.body.classList.add('mode-pause');
                const titleEl = document.getElementById('gym-phase-title');
                if (titleEl) titleEl.innerText = "GEPAUZEERD";
                triggerAudio('manual_override', "Gepauzeerd");
                if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.pause();
            }

            // ALWAYS open the modal to allow resuming or adjusting
            try {
                previewPauseOptions();
            } catch (e) {
                console.error("Preview options error:", e);
                // Fallback: show 0s
                document.getElementById('pause-duration-display').innerText = "--";
            }
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function handleForcePauseMenu() {
            // Called by "Einde (Klik!)"
            // Goal: Pause app (if running) AND immediately show the menu.

            try {
                if (!isPaused) {
                    handlePauseClick(); // This pauses the app, sets isPaused=true
                }
            } catch (err) {
                console.error("ForcePause error:", err);
                // Fallback if handlePauseClick crashes
                isPaused = true;
                if (!pauseStartTime) pauseStartTime = Date.now();
            }

            // Explicitly show the modal now (handlePauseClick only does this if ALREADY paused)
            try {
                previewPauseOptions();
                document.getElementById('pause-modal').style.display = 'flex';
            } catch (e) {
                console.error("Modal open error:", e);
                // Last resort: simple show
                const m = document.getElementById('pause-modal');
                if (m) m.style.display = 'flex';
            }
        }

        // --- NEW PAUSE RESOLUTION LOGIC ---
        function previewPauseOptions() {
            const now = Date.now();
            currentPauseDuration = Math.ceil((now - pauseStartTime) / 1000); // Seconds paused
            document.getElementById('pause-duration-display').innerText = currentPauseDuration + "s";

            // 1. Push Endtime (Always possible)
            const newEndDate = new Date(targetEndTimeDate.getTime() + (currentPauseDuration * 1000));
            const oldEndStr = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            const newEndStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            const extraMin = Math.ceil(currentPauseDuration / 60);
            document.getElementById('btn-text-push').innerText = `Van ${oldEndStr} naar ${newEndStr} (+${extraMin}m)`;

            // 2. Catch up Work
            const workSteps = countRemainingSteps('work');
            const btnWork = document.getElementById('btn-catch-work');
            if (workSteps > 0) {
                const deduction = Math.ceil(currentPauseDuration / workSteps);
                const currentWork = getFirstStepTime('work');
                const newWork = currentWork - deduction;
                if (newWork >= 5) {
                    btnWork.disabled = false; btnWork.style.opacity = 1;
                    document.getElementById('btn-text-work').innerText = `Werk: ${currentWork}s -> ${newWork}s`;
                } else {
                    btnWork.disabled = true; btnWork.style.opacity = 0.5;
                    document.getElementById('btn-text-work').innerText = `Niet mogelijk (Werk wordt < 5s)`;
                }
            } else {
                btnWork.disabled = true; btnWork.style.opacity = 0.5; document.getElementById('btn-text-work').innerText = "Geen werksets meer";
            }

            // 3. Catch up Rest (Set)
            updateCatchUpButton('rest', 'btn-catch-rest', 'btn-text-rest', "Rust");
            // 4. Catch up Switch
            updateCatchUpButton('rest-exercise', 'btn-catch-switch', 'btn-text-switch', "Wissel");
            // 5. Catch up Round
            updateCatchUpButton('rest-long', 'btn-catch-round', 'btn-text-round', "Pauze");
        }

        // --- LIVE END TIME ADJUSTMENT LOGIC ---
        let liveBaseEndTime = null; // The projected end time BEFORE adjustment starts

        function openLiveEndAdjustment() {
            // 1. Pause App similar to handleForcePauseMenu
            try {
                if (!isPaused) {
                    handlePauseClick();
                }
            } catch (e) { console.error(e); isPaused = true; }

            // 2. Hide standard pause modal (if open)
            document.getElementById('pause-modal').style.display = 'none';

            // 3. Calc projected end time based on CURRENT schedule
            // We use the renderLiveSchedule() return value as the source of truth
            const projected = renderLiveSchedule(false) || targetEndTimeDate;
            liveBaseEndTime = new Date(projected);

            // 4. Set Input
            const timeStr = liveBaseEndTime.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('live-adjust-input').value = timeStr;

            // 5. Reset Diff UI
            calcLiveEndDiff();

            // 6. Show Modal
            document.getElementById('live-end-adjust-modal').style.display = 'flex';
        }

        function cancelLiveAdjustment() {
            document.getElementById('live-end-adjust-modal').style.display = 'none';
            // Return to standard pause menu
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function calcLiveEndDiff() {
            const val = document.getElementById('live-adjust-input').value;
            if (!val) return;

            const [h, m] = val.split(':');
            const newDate = new Date();
            newDate.setHours(h, m, 0, 0);
            // Fix day wrapping
            const now = new Date();
            if (newDate < now && (now.getTime() - newDate.getTime() > 12 * 3600 * 1000)) {
                newDate.setDate(newDate.getDate() + 1);
            }

            const diffMs = newDate - liveBaseEndTime;
            const diffSec = Math.round(diffMs / 1000);

            const txt = document.getElementById('live-adjust-diff');
            if (diffSec > 0) {
                txt.innerText = `+${Math.floor(diffSec / 60)}m ${diffSec % 60}s`;
                txt.style.color = "#30D158";
            } else if (diffSec < 0) {
                txt.innerText = `-${Math.floor(Math.abs(diffSec) / 60)}m ${Math.abs(diffSec) % 60}s`;
                txt.style.color = "#FF453A";
            } else {
                txt.innerText = "Geen verschil";
                txt.style.color = "#888";
            }

            // Update buttons with projected effect
            updateLiveEffect('work', diffSec, 'btn-live-work', 'sub-live-work');
            updateLiveEffect('rest', diffSec, 'btn-live-rest', 'sub-live-rest');
            updateLiveEffect('switch', diffSec, 'btn-live-switch', 'sub-live-switch');
        }

        function updateLiveEffect(typeKey, totalDiffSec, btnId, subId) {
            const btn = document.getElementById(btnId);
            const sub = document.getElementById(subId);

            // Count remaining steps of this type
            // typeKey mapping: 'work'->'work', 'rest'->'rest', 'switch'->'rest-exercise' (roughly)
            let internalTypes = [];
            if (typeKey === 'work') internalTypes = ['work'];
            if (typeKey === 'rest') internalTypes = ['rest'];
            if (typeKey === 'switch') internalTypes = ['rest-exercise'];

            let count = 0;
            // Count ONLY future steps
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (internalTypes.includes(schedule[i].type)) count++;
            }

            if (count === 0) {
                btn.disabled = true;
                btn.style.opacity = 0.5;
                sub.innerText = "Niet beschikbaar (geen stappen)";
                return;
            }

            btn.disabled = false;
            btn.style.opacity = 1;
            const perStep = Math.round(totalDiffSec / count);
            const sign = perStep > 0 ? "+" : "";
            sub.innerText = `Effect: ${sign}${perStep}s per stap (${count}x)`;
        }

        function applyLiveEndAdjustment(typeKey) {
            const val = document.getElementById('live-adjust-input').value;
            if (!val) return;

            // Calc Diff
            const [h, m] = val.split(':');
            const newDate = new Date(); newDate.setHours(h, m, 0, 0);
            const now = new Date();
            if (newDate < now && (now.getTime() - newDate.getTime() > 12 * 3600 * 1000)) {
                newDate.setDate(newDate.getDate() + 1);
            }
            const diffMs = newDate - liveBaseEndTime;
            const diffSec = Math.round(diffMs / 1000);

            if (diffSec === 0) { cancelLiveAdjustment(); return; }

            // Map type
            let internalTypes = [];
            if (typeKey === 'work') internalTypes = ['work'];
            if (typeKey === 'rest') internalTypes = ['rest'];
            if (typeKey === 'switch') internalTypes = ['rest-exercise'];

            // Distribute
            let count = 0;
            let indices = [];
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (internalTypes.includes(schedule[i].type)) {
                    count++;
                    indices.push(i);
                }
            }

            if (count > 0) {
                const perStep = Math.floor(diffSec / count);
                let remainder = diffSec % count;

                indices.forEach(idx => {
                    let add = perStep;
                    if (remainder !== 0) {
                        // Distribute remainder 1 by 1
                        if (remainder > 0) { add++; remainder--; }
                        else { add--; remainder++; }
                    }

                    // Check minimum bounds? (e.g. don't go below 5s)
                    let newVal = schedule[idx].initialTime + add;
                    if (newVal < 5) newVal = 5; // Safety floor

                    schedule[idx].initialTime = newVal;
                    schedule[idx].time = newVal; // Update current state if it hasn't run yet? 
                    // Actually 'time' is active state. For future steps, time == initialTime usually.
                });

                triggerAudio('manual_override', "Schema aangepast");
            }

            // Close and Resume
            document.getElementById('live-end-adjust-modal').style.display = 'none';
            document.getElementById('live-end-adjust-modal').style.display = 'none';
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = "";

            // Re-render
            renderLiveSchedule(true);
        }


        // --- SETUP WORK ADJUSTMENT LOGIC ---
        function openSetupWorkAdjustment() {
            // Ensure we have the latest calculation
            calculateRealTime();

            // Check if we have a valid work time
            if (workTimeSec <= 0) {
                alert("Er is nog geen geldig schema berekend. Vul eerst de instellingen in.");
                return;
            }

            document.getElementById('setup-work-input').value = workTimeSec;
            calcSetupWorkDiff();
            document.getElementById('setup-work-adjust-modal').style.display = 'flex';
        }

        function closeSetupWorkAdjustment() {
            document.getElementById('setup-work-adjust-modal').style.display = 'none';
        }

        function adjustSetupWorkInput(delta) {
            const inp = document.getElementById('setup-work-input');
            let val = parseInt(inp.value) || 0;
            val += delta;
            if (val < 5) val = 5;
            inp.value = val;
            calcSetupWorkDiff();
        }

        function calcSetupWorkDiff() {
            const val = parseInt(document.getElementById('setup-work-input').value) || 0;
            const diff = val - workTimeSec;
            const txt = document.getElementById('setup-work-diff');

            if (diff > 0) { txt.innerText = `+${diff}s per set`; txt.style.color = "#30D158"; }
            else if (diff < 0) { txt.innerText = `${diff}s per set`; txt.style.color = "#FF453A"; }
            else { txt.innerText = "Geen wijziging"; txt.style.color = "#888"; }

            // Update Buttons Text
            const btnDur = document.getElementById('btn-setup-duration');
            const subDur = document.getElementById('sub-setup-duration');
            const btnRest = document.getElementById('btn-setup-rest');
            const subRest = document.getElementById('sub-setup-rest');

            // 1. Duration Impact
            const rounds = parseInt(document.getElementById('rounds').value);
            const ex = parseInt(document.getElementById('exercises').value);
            const sets = parseInt(document.getElementById('sets').value);
            const totalWorkSets = rounds * ex * sets;

            // Current Duration Calculation
            const st = document.getElementById('startTimeValue').value;
            const et = document.getElementById('endTimeValue').value;
            const d1 = new Date("1970-01-01T" + st);
            const d2 = new Date("1970-01-01T" + et);
            if (d2 < d1) d2.setDate(d2.getDate() + 1);
            const curDurSec = (d2 - d1) / 1000;
            const curDurMin = Math.round(curDurSec / 60);

            const totalImpactSec = diff * totalWorkSets;
            const newDurSec = curDurSec + totalImpactSec;
            const newDurMin = Math.round(newDurSec / 60);
            const diffMin = newDurMin - curDurMin;

            if (totalImpactSec !== 0) {
                subDur.innerText = `Duur: ${curDurMin}m -> ${newDurMin}m (${diffMin > 0 ? '+' : ''}${diffMin}m)`;
                btnDur.disabled = false; btnDur.style.opacity = 1;
            } else {
                subDur.innerText = "Geen verandering";
                btnDur.disabled = true; btnDur.style.opacity = 0.5;
            }

            // 2. Rest Impact
            // Get current Rests
            const curRest = parseInt(document.getElementById('restSec').value);
            const curSwitch = parseInt(document.getElementById('exerciseRestSec').value);

            // Count slots
            const slotsRest = (sets - 1) * ex * rounds;
            const slotsSwitch = (ex - 1) * rounds;
            const totalSlots = slotsRest + slotsSwitch;

            if (totalSlots > 0 && totalImpactSec !== 0) {
                // We need to REMOVE totalImpactSec from the rest pool.
                // (Because if Work goes UP, Rest must go DOWN to keep duration same)
                const reducePerSlot = Math.round(totalImpactSec / totalSlots);

                const newRest = curRest - reducePerSlot;
                const newSwitch = curSwitch - reducePerSlot;

                if (newRest < 5 || newSwitch < 5) {
                    subRest.innerText = "Niet mogelijk (Rust wordt < 5s)";
                    btnRest.disabled = true; btnRest.style.opacity = 0.5;
                } else {
                    subRest.innerText = `Rust: ${curRest}s -> ${newRest}s`;
                    if (curSwitch !== curRest || newSwitch !== newRest) {
                        // If switch is different, show it too, or simplified
                        // Let's just show main "Rust" change as primary indicator
                        // subRest.innerText += ` | Wissel: ${curSwitch}s -> ${newSwitch}s`;
                    }
                    btnRest.disabled = false; btnRest.style.opacity = 1;
                }
            } else {
                subRest.innerText = "Geen relevant aantal rustmomenten";
                btnRest.disabled = true; btnRest.style.opacity = 0.5;
            }
        }

        function applySetupWorkAdjustment(mode) {
            const newVal = parseInt(document.getElementById('setup-work-input').value) || 0;
            const diff = newVal - workTimeSec;
            if (diff === 0) { closeSetupWorkAdjustment(); return; }

            if (mode === 'duration') {
                // Change Total Duration
                // We have totalImpactSec calculated above
                const rounds = parseInt(document.getElementById('rounds').value);
                const ex = parseInt(document.getElementById('exercises').value);
                const sets = parseInt(document.getElementById('sets').value);
                const totalWorkSets = rounds * ex * sets;
                const totalImpactSec = diff * totalWorkSets;

                // Update Duration Input (minutes)
                // Start with current selected duration
                // Actually, "Total Min" dropdown is the master controller usually.
                // But we might be in start/end mode.
                // Let's modify the End Time primarily? Or Total Duration?
                // Modifying Duration is safer for "Duration" mode.

                // Get current duration in seconds (based on current calculation budget)
                // We can grab it from startTime vs endTime
                const st = document.getElementById('startTimeValue').value;
                const et = document.getElementById('endTimeValue').value;
                // Helper to parse
                const d1 = new Date("1970-01-01T" + st);
                const d2 = new Date("1970-01-01T" + et);
                if (d2 < d1) d2.setDate(d2.getDate() + 1);
                let curDurSec = (d2 - d1) / 1000;

                let newDurSec = curDurSec + totalImpactSec;
                let newDurMin = Math.round(newDurSec / 60);

                // Update input and trigger sync
                // We need to update the Total Min dropdown IF it exists there, or add custom?
                // The app usually snaps to 5m increments.
                // But let's try updating End Time to match exact seconds?
                // Updating End Time is most flexible.

                const newEndDate = new Date(d1.getTime() + (newDurSec * 1000));
                const endStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                document.getElementById('endTimeValue').value = endStr;

                // Also try to update TotalMin visual if close
                // Check if valid option exists?
                // document.getElementById('totalMin').value = newDurMin; // Might fail if not in options
                // Let's invoke syncTime('endtime') to cascade changes
                syncTime('endtime');
                saveToLocal();

            } else if (mode === 'rest') {
                // Change Rest Times to absorb diff
                const curRest = parseInt(document.getElementById('restSec').value);
                const curSwitch = parseInt(document.getElementById('exerciseRestSec').value);

                const rounds = parseInt(document.getElementById('rounds').value);
                const ex = parseInt(document.getElementById('exercises').value);
                const sets = parseInt(document.getElementById('sets').value);

                const slotsRest = (sets - 1) * ex * rounds;
                const slotsSwitch = (ex - 1) * rounds;
                const totalSlots = slotsRest + slotsSwitch;
                const totalWorkSets = rounds * ex * sets;
                const totalImpactSec = diff * totalWorkSets;

                if (totalSlots > 0) {
                    const reducePerSlot = Math.round(totalImpactSec / totalSlots);
                    let newRest = curRest - reducePerSlot;
                    let newSwitch = curSwitch - reducePerSlot;

                    if (newRest < 5) newRest = 5;
                    if (newSwitch < 5) newSwitch = 5;

                    // Update Selects (Create option if not exists)
                    setSelectValue('restSec', newRest);
                    setSelectValue('exerciseRestSec', newSwitch);

                    // Trigger Recalc
                    calculateRealTime();
                    saveToLocal();
                }
            }

            closeSetupWorkAdjustment();
        }

        // Helper to force set value in select (adding if missing)
        function setSelectValue(id, val) {
            const sel = document.getElementById(id);
            let found = false;
            for (let i = 0; i < sel.options.length; i++) {
                if (parseInt(sel.options[i].value) === val) {
                    sel.selectedIndex = i;
                    found = true;
                    break;
                }
            }
            if (!found) {
                const opt = document.createElement('option');
                opt.value = val;
                opt.innerText = val + "s";
                sel.add(opt);
                sel.value = val;
            }
        }

        // --- LIVE WORK ADJUSTMENT ---
        let liveBaseWorkTime = 0;


        function openLiveWorkAdjustment() {
            try { if (!isPaused) handlePauseClick(); } catch (e) { isPaused = true; }
            document.getElementById('pause-modal').style.display = 'none';

            // Find current Work Time (only regular exercises)
            let found = schedule.find((s, i) => i >= currentIndex && s.type === 'work' && s.info && s.info.exercise > 0);
            if (!found) found = { initialTime: 45 }; // Fallback

            liveBaseWorkTime = found.initialTime;
            document.getElementById('live-work-input').value = liveBaseWorkTime;

            calcLiveWorkDiff();
            document.getElementById('live-work-adjust-modal').style.display = 'flex';
        }

        function cancelLiveWorkAdjustment() {
            document.getElementById('live-work-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function adjustLiveWorkInput(delta) {
            const inp = document.getElementById('live-work-input');
            let val = parseInt(inp.value) || 0;
            val += delta;
            if (val < 5) val = 5;
            inp.value = val;
            calcLiveWorkDiff();
        }

        function calcLiveWorkDiff() {
            const val = parseInt(document.getElementById('live-work-input').value) || 0;
            const diff = val - liveBaseWorkTime;

            const txt = document.getElementById('live-work-diff');
            if (diff > 0) { txt.innerText = `+${diff}s per set`; txt.style.color = "#30D158"; }
            else if (diff < 0) { txt.innerText = `${diff}s per set`; txt.style.color = "#FF453A"; }
            else { txt.innerText = "Geen wijziging"; txt.style.color = "#888"; }

            // Count occurrences (Regular Sets Only - THIS ROUND ONLY)
            const currentRound = schedule[currentIndex]?.info?.round;
            let workCount = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].info?.round !== currentRound) continue;
                if (schedule[i].type === 'work' && schedule[i].info && schedule[i].info.exercise > 0) workCount++;
            }
            const totalImpact = diff * workCount;

            // 1. Push - Visual Feedback
            const subPush = document.getElementById('sub-work-push');
            subPush.innerText = `Totale impact: ${totalImpact > 0 ? '+' : ''}${totalImpact}s op eindtijd`;

            // 2. Compensate Rest
            const btnRest = document.getElementById('btn-work-rest');
            const subRest = document.getElementById('sub-work-rest');
            // calcLiveRestDiff uses: updateCompensateButton('work', diff, count, btnWork, subWork, "Werk");
            // Signature: (targetType, diffPerSource, sourceCount, btn, sub, label)
            // For Work->Rest: target=Rest. diffPerSource=diff. sourceCount=workCount.
            updateCompensateButton('rest', diff, workCount, btnRest, subRest, "Rust");

            // 3. Compensate Switch
            const btnSwitch = document.getElementById('btn-work-switch');
            const subSwitch = document.getElementById('sub-work-switch');
            updateCompensateButton('rest-exercise', diff, workCount, btnSwitch, subSwitch, "Wissel");
        }

        // Shared helper for predicting compensation (Used by Work & Rest adjustment)
        function updateCompensateButton(targetType, diffPerSource, sourceCount, btnEl, subEl, label) {
            let targetCount = 0;
            let currentTargetVal = 0;
            const currentRound = schedule[currentIndex]?.info?.round;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].info?.round !== currentRound) continue;
                if (schedule[i].type === targetType) {
                    targetCount++;
                    if (currentTargetVal === 0) currentTargetVal = schedule[i].initialTime;
                }
            }

            if (targetCount === 0) {
                btnEl.disabled = true; btnEl.style.opacity = 0.5;
                subEl.innerText = "Geen stappen meer";
                return;
            }

            const totalNeeded = diffPerSource * sourceCount;
            // If Work +10s (diff=+10). Count=10. TotalNeeded=+100s.
            // We need to REDUCE target by 100s.
            // deduction = 100 / targetCount.
            // new = current - deduction.

            const deductionPerStep = Math.floor(totalNeeded / targetCount);
            const newVal = currentTargetVal - deductionPerStep;

            if (newVal < 5) {
                btnEl.disabled = true; btnEl.style.opacity = 0.5;
                subEl.innerText = `Onmogelijk (${newVal}s < 5s)`;
            } else {
                btnEl.disabled = false; btnEl.style.opacity = 1;
                // If deduction is positive (Work increased), we subtract. Sign is MINUS.
                // If deduction is negative (Work decreased), we add. Sign is PLUS.
                const sign = deductionPerStep > 0 ? '-' : '+';
                subEl.innerText = `${label} wordt ${newVal}s (${sign}${Math.abs(deductionPerStep)}s)`;
            }
        }

        function applyLiveWorkAdjustment(mode) {
            const val = parseInt(document.getElementById('live-work-input').value) || 0;
            const diff = val - liveBaseWorkTime;
            if (diff === 0) { cancelLiveWorkAdjustment(); return; }

            // 1. Update all future WORK steps (Sets only - THIS ROUND ONLY)
            const currentRound = schedule[currentIndex]?.info?.round;
            let workCount = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].info?.round !== currentRound) continue;
                if (schedule[i].type === 'work' && schedule[i].info && schedule[i].info.exercise > 0) {
                    schedule[i].initialTime = val;
                    schedule[i].time = val;
                    workCount++;
                }
            }

            // 2. Handle Compensation
            if (mode === 'rest' || mode === 'switch') {
                const targetType = (mode === 'switch') ? 'rest-exercise' : 'rest';
                const totalNeeded = diff * workCount;

                let targetIndices = [];
                for (let i = currentIndex + 1; i < schedule.length; i++) {
                    if (schedule[i].info?.round !== currentRound) continue;
                    if (schedule[i].type === targetType) targetIndices.push(i);
                }

                if (targetIndices.length > 0) {
                    // We want to REDUCE Rest by totalNeeded.
                    const deductionTotal = totalNeeded;
                    const deductionPerStep = Math.floor(deductionTotal / targetIndices.length);
                    let remainder = deductionTotal % targetIndices.length;

                    targetIndices.forEach(idx => {
                        let deduct = deductionPerStep;
                        if (remainder !== 0) {
                            if (remainder > 0) { deduct++; remainder--; }
                            else { deduct--; remainder++; }
                        }

                        let time = schedule[idx].initialTime - deduct;
                        if (time < 5) time = 5;
                        schedule[idx].initialTime = time;
                        schedule[idx].time = time;
                    });
                }
            }

            triggerAudio('manual_override', "Werktijd aangepast");

            document.getElementById('live-work-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'none'; // Close all
            document.getElementById('pause-modal').style.display = 'none'; // Close all
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = "";

            renderLiveSchedule(true);
        }

        // --- LIVE REST/SWITCH/ROUND ADJUSTMENT ---
        let liveBaseRestTime = 0;
        let liveRestType = 'rest'; // 'rest', 'rest-exercise', 'rest-long'

        function openLiveRestAdjustment(type) {
            liveRestType = type;
            // 1. Label
            const lbl = document.getElementById('live-rest-type-label');
            if (type === 'rest') lbl.innerText = "Rust (Set)";
            else if (type === 'rest-exercise') lbl.innerText = "Wissel";
            else if (type === 'rest-long') lbl.innerText = "Pauze (Ronde)";

            // 2. Pause
            try { if (!isPaused) handlePauseClick(); } catch (e) { isPaused = true; }
            document.getElementById('pause-modal').style.display = 'none';

            // 3. Find current value
            let found = schedule.find((s, i) => i >= currentIndex && s.type === type);
            if (!found) {
                // Fallback or alert if none exist
                found = { initialTime: (type === 'rest' ? 15 : (type === 'rest-exercise' ? 30 : 60)) };
            }

            liveBaseRestTime = found.initialTime;
            document.getElementById('live-rest-input').value = liveBaseRestTime;

            calcLiveRestDiff();
            document.getElementById('live-rest-adjust-modal').style.display = 'flex';
        }

        function cancelLiveRestAdjustment() {
            document.getElementById('live-rest-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'flex';
        }

        function adjustLiveRestInput(delta) {
            const inp = document.getElementById('live-rest-input');
            let val = parseInt(inp.value) || 0;
            val += delta;
            if (val < 5) val = 5;
            inp.value = val;
            calcLiveRestDiff();
        }

        function calcLiveRestDiff() {
            const val = parseInt(document.getElementById('live-rest-input').value) || 0;
            const diff = val - liveBaseRestTime;

            const txt = document.getElementById('live-rest-diff');
            if (diff > 0) { txt.innerText = `+${diff}s per keer`; txt.style.color = "#30D158"; }
            else if (diff < 0) { txt.innerText = `${diff}s per keer`; txt.style.color = "#FF453A"; }
            else { txt.innerText = "Geen wijziging"; txt.style.color = "#888"; }

            // Count occurrences
            let count = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === liveRestType) count++;
            }
            const totalImpact = diff * count;

            // 1. Push
            const subPush = document.getElementById('sub-rest-push');
            subPush.innerText = `Totale impact: ${totalImpact > 0 ? '+' : ''}${totalImpact}s op eindtijd`;

            // 2. Work (Trade)
            // If we add Rest (+), we must subtract Work (-).
            const btnWork = document.getElementById('btn-rest-work');
            const subWork = document.getElementById('sub-rest-work');

            updateCompensateButton('work', diff, count, btnWork, subWork, "Werk");
        }

        function applyLiveRestAdjustment(mode) {
            const val = parseInt(document.getElementById('live-rest-input').value) || 0;
            const diff = val - liveBaseRestTime;
            if (diff === 0) { cancelLiveRestAdjustment(); return; }

            // 1. Update all future steps of THIS type
            let count = 0;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                if (schedule[i].type === liveRestType) {
                    schedule[i].initialTime = val;
                    schedule[i].time = val;
                    count++;
                }
            }

            // 2. Handle Compensation with WORK
            if (mode === 'work') {
                const totalNeeded = diff * count; // +20s total rest means we need -20s total work

                let workIndices = [];
                for (let i = currentIndex + 1; i < schedule.length; i++) {
                    if (schedule[i].type === 'work') workIndices.push(i);
                }

                if (workIndices.length > 0) {
                    const deductionPerStep = Math.floor(totalNeeded / workIndices.length);
                    let remainder = totalNeeded % workIndices.length;

                    workIndices.forEach(idx => {
                        let deduct = deductionPerStep;
                        if (remainder !== 0) {
                            if (remainder > 0) { deduct++; remainder--; }
                            else { deduct--; remainder++; }
                        }

                        let time = schedule[idx].initialTime - deduct;
                        if (time < 5) time = 5;
                        schedule[idx].initialTime = time;
                        schedule[idx].time = time;
                    });
                }
            }

            triggerAudio('manual_override', "Tijden aangepast");

            document.getElementById('live-rest-adjust-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'none';
            document.getElementById('pause-modal').style.display = 'none';
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            const btn = document.getElementById('btn-pause');
            if (btn) btn.innerText = "";

            renderLiveSchedule(true);
        }

        function updateCatchUpButton(type, btnId, textId, label) {
            const steps = countRemainingSteps(type);
            const btn = document.getElementById(btnId);
            if (steps > 0) {
                const deduction = Math.ceil(currentPauseDuration / steps);
                const currentVal = getFirstStepTime(type);
                const newVal = currentVal - deduction;
                if (newVal >= 5) {
                    btn.disabled = false; btn.style.opacity = 1;
                    document.getElementById(textId).innerText = `${label}: ${currentVal}s -> ${newVal}s`;
                } else {
                    btn.disabled = true; btn.style.opacity = 0.5;
                    document.getElementById(textId).innerText = `Niet mogelijk (${newVal}s < 5s)`;
                }
            } else {
                btn.disabled = true; btn.style.opacity = 0.5; document.getElementById(textId).innerText = "Niet van toepassing";
            }
        }

        function countRemainingSteps(type) {
            let count = 0;
            // Only count regular work steps, not fixed extra steps for adjustment
            for (let i = currentIndex; i < schedule.length; i++) {
                if (schedule[i].type === type) {
                    if (type === 'work') {
                        if (schedule[i].info && schedule[i].info.exercise > 0) count++;
                    } else {
                        count++;
                    }
                }
            }
            return count;
        }

        function getFirstStepTime(type) {
            for (let i = currentIndex; i < schedule.length; i++) {
                if (schedule[i].type === type) {
                    // FIX: Ignore Bonuses when checking for 'work' time (otherwise returns bonus duration)
                    if (type === 'work' && schedule[i].info && schedule[i].info.bonusId) continue;
                    return schedule[i].time;
                }
            }
            return 0;
        }

        let pendingEarlyStartSec = 0;

        function previewEarlyStartOptions() {
            console.log("DEBUG_PREVIEW (" + Date.now() + ")", { work: getFirstStepTime('work'), scheduleLen: schedule.length, workSteps: countRemainingSteps('work') });
            const startStr = document.getElementById('startTimeValue').value;
            const now = new Date();
            const [h, m] = startStr.split(':');
            const targetStart = new Date();
            targetStart.setHours(h, m, 0, 0);
            if (targetStart < now) targetStart.setDate(targetStart.getDate() + 1);

            // Calculate Surplus
            const diffMs = targetStart - now;
            if (diffMs <= 0) { performStart(); return; }

            pendingEarlyStartSec = Math.ceil(diffMs / 1000);

            // FIX: Hide Overlay and Stop Timer
            document.getElementById('pre-workout-overlay').style.display = 'none';
            if (preWorkoutInterval) clearInterval(preWorkoutInterval);

            // Show UI
            document.getElementById('pause-modal').style.display = 'flex';
            document.getElementById('pause-modal-title').innerText = "TE VROEG GESTART?";
            document.getElementById('pause-msg-p').innerHTML = `Je start <span style="color:#30D158; font-weight:bold;">${pendingEarlyStartSec}s</span> eerder.`;

            // 1. Shift End Time (Finish Early)
            // Logic: EndTime = EndTime - Surplus
            // Display: Old -> New
            const oldEndStr = document.getElementById('endTimeValue').value;
            // newEndDate isn't finalized until we performStart, but we can calc relative
            // Actually targetEndTimeDate is current input.
            const curEndVal = document.getElementById('endTimeValue').value;
            const nowCheck = new Date();
            const [eh, em] = curEndVal.split(':');
            const curEnd = new Date();
            curEnd.setHours(eh, em, 0, 0);
            if (curEnd < nowCheck) curEnd.setDate(curEnd.getDate() + 1);

            const newEndDate = new Date(curEnd.getTime() - diffMs);
            const newEndStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

            document.getElementById('btn-text-push').innerText = `Eindtijd: ${oldEndStr} -> ${newEndStr} (Klaar: Eerder)`;

            // 2. Extra Work (Default behavior of performStart if we don't shift end)
            // We just need to show what happens.
            // Estimate new Work Time?
            // Current Work Time (Plan) vs New Work Time.
            // If we add surplus to duration, work increases.
            // Approx: NewWork = OldWork + (Surplus / WorkSteps)
            const workSteps = countRemainingSteps('work'); // This looks at current schedule (generated). OK.
            const btnWork = document.getElementById('btn-catch-work');
            if (workSteps > 0) {
                const currentWork = getFirstStepTime('work');
                const added = Math.floor(pendingEarlyStartSec / workSteps);
                const newWork = currentWork + added;
                btnWork.disabled = false; btnWork.style.opacity = 1;
                document.getElementById('btn-text-work').innerText = `Werk: ${currentWork}s -> ${newWork}s`;
            } else {
                btnWork.disabled = true; btnWork.style.opacity = 0.5; document.getElementById('btn-text-work').innerText = "-";
            }

            // 3/4/5. Extra Rest
            // btn-text-rest etc.
            const updateEarlyBtn = (type, btnId, txtId, label) => {
                const steps = countRemainingSteps(type);
                const btn = document.getElementById(btnId);
                if (steps > 0) {
                    const currentVal = getFirstStepTime(type);
                    const added = Math.floor(pendingEarlyStartSec / steps);
                    const newVal = currentVal + added;
                    btn.disabled = false; btn.style.opacity = 1;
                    document.getElementById(txtId).innerText = `${label}: ${currentVal}s -> ${newVal}s`;
                } else {
                    btn.disabled = true; btn.style.opacity = 0.5; document.getElementById(txtId).innerText = "-";
                }
            };

            updateEarlyBtn('rest', 'btn-catch-rest', 'btn-text-rest', "Rust");
            updateEarlyBtn('rest-exercise', 'btn-catch-switch', 'btn-text-switch', "Wissel");
            updateEarlyBtn('rest-long', 'btn-catch-round', 'btn-text-round', "Pauze");
        }

        function resolvePause(choice) {
            // Handle Jump Index First
            if (pendingJumpIndex !== null) {
                currentIndex = pendingJumpIndex;
                triggerAudio('manual_override', "Springen naar selectie");
                schedule[currentIndex].time = schedule[currentIndex].initialTime;
            }

            document.getElementById('pause-modal').style.display = 'none';
            // Restore Title default
            document.getElementById('pause-modal-title').innerText = "PAUZE VOORBIJ";
            document.getElementById('pause-msg-p').innerHTML = `Je hebt <span id="pause-duration-display" style="color:white; font-weight:bold;">0s</span> gepauzeerd.`;

            if (pendingEarlyStartSec > 0) {
                // EARLY START RESOLUTION
                const surplus = pendingEarlyStartSec;
                pendingEarlyStartSec = 0; // Reset

                // FIX: Only call performStart if NOT in Jump Mode
                // Capture jump state for later use
                const isJump = pendingJumpIndex !== null;

                if (choice === 'push') {
                    // Option 1: Shift End Time Earlier (Remove Surplus)

                    // FIX: Ensure targetEndTimeDate is defined (it might not be if performStart hasn't run yet)
                    if (!targetEndTimeDate) {
                        const endStr = document.getElementById('endTimeValue').value;
                        if (endStr) {
                            const [h, m] = endStr.split(':');
                            targetEndTimeDate = new Date();
                            targetEndTimeDate.setHours(h, m, 0, 0);
                            // Handle Day Wrap if needed (though unlikely for "Early" start unless around midnight)
                            if (targetEndTimeDate < new Date()) targetEndTimeDate.setDate(targetEndTimeDate.getDate() + 1);
                        } else {
                            // Fallback if inputs are empty? Should not happen in this flow.
                            targetEndTimeDate = new Date();
                        }
                    }

                    targetEndTimeDate = new Date(targetEndTimeDate.getTime() - (surplus * 1000));

                    // FIX: Sync Inputs to Reality so calculateRealTime works correctly
                    const now = new Date();
                    document.getElementById('startTimeValue').value = now.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
                    document.getElementById('endTimeValue').value = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

                    // FORCE RECALC: Update global workTimeSec based on new inputs
                    // This ensures performStart -> generateScheduleData uses the updated (smaller) workTimeSec (e.g. 32s)
                    // instead of the old one (60s).
                    calculateRealTime();

                    // FIX: Conditionally adjust start time
                    if (isJump) {
                        workoutStartTime = new Date(workoutStartTime.getTime() - (surplus * 1000));
                    }

                    updateEndTimeDisplay();
                }

                if (!isJump) {
                    performStart();
                } else {
                    // Jump Mode: We are already running.
                    // Just need to handle the Surplus logic manually.
                    // Note: pendingJumpIndex was already applied at start of function.
                    pendingJumpIndex = null; // Clear it now
                    runStep(); // Kill Zombie Timer & Start New Step
                    renderLiveSchedule(); // Sync UI
                }

                if (choice === 'push') {
                    renderLiveSchedule(); // Update visible schedule immediately
                }
                else if (choice === 'work') {
                    // Option 2: Absorb into Work
                    // Do nothing! performStart already put it in Work.
                    triggerAudio('manual_override', "Extra werk tijd toegevoegd");
                }
                else {
                    // Option 3: Absorb into Rest/Switch/Round
                    // We need to move the surplus FROM Work TO Rest.
                    let typeToIncrease = '';
                    if (choice === 'rest') typeToIncrease = 'rest';
                    else if (choice === 'switch') typeToIncrease = 'rest-exercise';
                    else if (choice === 'round') typeToIncrease = 'rest-long';

                    const steps = countRemainingSteps(typeToIncrease);
                    const addition = Math.floor(surplus / steps);

                    for (let i = currentIndex; i < schedule.length; i++) {
                        if (schedule[i].type === typeToIncrease) {
                            schedule[i].time += addition;
                            schedule[i].initialTime += addition;
                        }
                    }
                    // Now Rest is higher. Duration matches inputs (Wide).
                    // We must recalculate work to shrink it (since we gave space to Rest).
                    recalculateForFixedEnd();
                    triggerAudio('manual_override', "Extra rust tijd toegevoegd");
                }

                // FIX: If we skipped performStart (Jump Mode), we must manually Resume!
                // Otherwise app stays paused.
                const btn = document.getElementById('btn-pause');
                if (btn.innerText === "" || isPaused) {
                    btn.innerText = ""; btn.classList.remove('paused');
                    btn.innerText = ""; btn.classList.remove('paused');
                    isPaused = false;
                    if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
                    document.body.classList.remove('mode-pause');
                    triggerAudio('manual_override', "We gaan weer door");
                }

                return;
            }

            // STANDARD PAUSE RESOLUTION
            const btn = document.getElementById('btn-pause');
            btn.innerText = ""; btn.classList.remove('paused');
            btn.innerText = ""; btn.classList.remove('paused');
            isPaused = false;
            if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            document.body.classList.remove('mode-pause');
            triggerAudio('manual_override', "We gaan weer door");

            // Apply Logic
            if (choice === 'push') {
                targetEndTimeDate = new Date(targetEndTimeDate.getTime() + (currentPauseDuration * 1000));
                updateEndTimeDisplay();
                stepEndTime += (currentPauseDuration * 1000);
                renderLiveSchedule(); // Update visible schedule immediately
            } else {
                stepEndTime += (currentPauseDuration * 1000);

                // Now Reduce
                let typeToReduce = '';
                if (choice === 'work') typeToReduce = 'work';
                else if (choice === 'rest') typeToReduce = 'rest';
                else if (choice === 'switch') typeToReduce = 'rest-exercise';
                else if (choice === 'round') typeToReduce = 'rest-long';

                const steps = countRemainingSteps(typeToReduce);
                const deduction = Math.ceil(currentPauseDuration / steps);

                // Apply deduction
                let currentStepReduced = false;
                for (let i = currentIndex; i < schedule.length; i++) {
                    if (schedule[i].type === typeToReduce) {
                        // Protect Extra Work from reduction if mode is 'work'
                        if (typeToReduce === 'work' && schedule[i].info.exercise === 0) continue;

                        schedule[i].time = Math.max(5, schedule[i].time - deduction);
                        schedule[i].initialTime = schedule[i].time;
                        if (i === currentIndex) currentStepReduced = true;
                    }
                }

                if (currentStepReduced) {
                    stepEndTime -= (deduction * 1000);
                    document.getElementById('countdown').innerText = Math.ceil((stepEndTime - Date.now()) / 1000);
                }
                renderLiveSchedule(); // Update visible schedule immediately
            }

            // Restore UI Classes
            const step = schedule[currentIndex];
            if (step) {
                if (step.type === 'work') document.body.classList.add('mode-work');
                else if (step.type === 'rest') document.body.classList.add('mode-rest');
                else if (step.type === 'rest-exercise') document.body.classList.add('mode-switch');
                else if (step.type === 'rest-long') document.body.classList.add('mode-long');

                document.getElementById('gym-phase-title').innerText = step.label;
                const titleEl = document.getElementById('gym-phase-title');
                titleEl.className = 'gym-phase-title';
                if (step.label === 'WERKEN' || step.label === 'RUST' || step.type === 'work') {
                    // Dynamic Sizing
                    if (step.label.length > 20) {
                        titleEl.classList.add('long-text');
                    } else if (step.label.length < 10) {
                        titleEl.classList.add('huge-text');
                    }
                }
            }
        }

        function updateEndTimeDisplay() {
            const timeStr = targetEndTimeDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });
            document.getElementById('val-endtime').innerText = timeStr;
        }


        function updateProgressRings(currentSec, totalSec) {
            // Inner Ring (Step) uses REVERSE logic (starts full, goes to empty)
            const ringStep = document.getElementById('ring-step');
            if (ringStep && totalSec > 0) {
                const totalC = 251.3; // 2 * pi * 40
                // pct is % LEFT
                let pct = currentSec / totalSec;
                if (pct > 1) pct = 1; if (pct < 0) pct = 0;

                const offset = totalC * (1 - pct);
                ringStep.style.strokeDashoffset = offset;
            } else {
                // console.log("Ring update failed", totalSec);
            }

            // Outer Ring (Total)
            const ringTotal = document.getElementById('ring-total');
            if (ringTotal) {
                // FIXED: Force 0% during Prep Phase (User Requirement)
                if (schedule[currentIndex] && schedule[currentIndex].type === 'prep') {
                    const totalC = 301.6; // 2 * pi * 48
                    ringTotal.style.strokeDashoffset = totalC; // Empty
                    const ringPctEl = document.getElementById('ring-percent');
                    if (ringPctEl) ringPctEl.innerText = "0%";
                    return;
                }

                // NEW LOGIC: Set-Based Progress (User Request)
                // Formula: (Total Work Sets - Remaining Work Sets) / Total Work Sets
                // Filter: type === 'work' AND info.exercise > 0 (excludes bonuses/toetjes)

                try {
                    // 1. Base Progress: Completed Sets / Total Sets
                    let totalWorkSets = 0;
                    let remainingWorkSets = 0;

                    schedule.forEach((s, i) => {
                        if (s.type === 'work' && s.info && s.info.exercise > 0) {
                            totalWorkSets++;
                            if (i >= currentIndex) remainingWorkSets++;
                        }
                    });

                    if (totalWorkSets > 0) {
                        let basePct = (totalWorkSets - remainingWorkSets) / totalWorkSets;
                        if (basePct < 0) basePct = 0;
                        if (basePct > 1) basePct = 1;

                        // 2. Time Factor: Interpolate remaining % over remaining time
                        let finalPct = basePct;
                        const anchorStart = window.lastStepChangeTime || Date.now();

                        if (targetEndTimeDate && anchorStart) {
                            const nowMs = Date.now();
                            const totalDurationMs = targetEndTimeDate.getTime() - anchorStart;
                            const elapsedMs = nowMs - anchorStart;

                            if (totalDurationMs > 1000) {
                                let timeFactor = elapsedMs / totalDurationMs;
                                if (timeFactor > 1) timeFactor = 1;
                                if (timeFactor < 0) timeFactor = 0;

                                // Fill the gap (1 - basePct)
                                const gap = 1.0 - basePct;
                                finalPct = basePct + (gap * timeFactor);
                            }
                        }

                        if (finalPct > 1) finalPct = 1;
                        if (finalPct < 0) finalPct = 0;
                        if (isNaN(finalPct)) finalPct = 0;

                        const totalC = 301.6;
                        const offset = totalC * (1 - finalPct);
                        if (!isNaN(offset)) {
                            ringTotal.style.strokeDashoffset = offset;
                        }

                        // Update Percentage Text
                        const ringPctEl = document.getElementById('ring-percent');
                        if (ringPctEl) {
                            ringPctEl.innerText = Math.round(finalPct * 100) + "%";
                        }

                        // TIMELINE MILESTONES (Based on %)
                        if (finalPct >= 0.25 && !milestonesTriggered.m25) {
                            triggerAudio('mile_start', "Goede start");
                            milestonesTriggered.m25 = true;
                        }
                        if (finalPct >= 0.50 && !milestonesTriggered.m50) {
                            triggerAudio('mile_half', "Helft");
                            milestonesTriggered.m50 = true;
                        }
                        if (finalPct >= 0.75 && !milestonesTriggered.m75) {
                            triggerAudio('mile_end', "Eindsprint");
                            milestonesTriggered.m75 = true;
                        }
                    }
                } catch (err) {
                    console.error("Safe Progress Error:", err);
                }
            }
        }

        function finish() {
            document.body.className = 'mode-finish';
            document.getElementById('gym-phase-title').innerText = "KLAAR!";
            document.getElementById('gym-phase-title').classList.remove('huge-text');
            document.getElementById('countdown').innerText = "";
            document.getElementById('gym-stats-container').style.display = 'none';
            document.getElementById('btn-pause').style.display = 'none';
            // Force 100% progress
            updateProgressRings(0, 1);
            const ringTotal = document.getElementById('ring-total');
            if (ringTotal) ringTotal.style.strokeDashoffset = 0; // Ensure full

            clearInterval(timerInterval);
            triggerAudio('finish', "Training klaar");
        }

        function fullReset() {
            if (!confirm("Weet je zeker dat je alle instellingen wilt resetten naar standaard?")) return;

            document.getElementById('rounds').value = appDefaults.rounds;
            document.getElementById('exercises').value = appDefaults.exercises;
            document.getElementById('sets').value = appDefaults.sets;
            document.getElementById('restSec').value = appDefaults.restSec;
            document.getElementById('exerciseRestSec').value = appDefaults.exerciseRestSec;
            document.getElementById('roundRestSec').value = appDefaults.roundRestSec;
            document.getElementById('totalMin').value = appDefaults.totalMin;
            if (document.getElementById('coach-preset-live')) document.getElementById('coach-preset-live').value = appDefaults.coachPreset; // UPDATED

            for (let i = 0; i < 3; i++) {
                document.getElementById(`bonus${i + 1}-name`).value = appDefaults.bonuses[i].name;
                document.getElementById(`bonus${i + 1}-duration`).value = appDefaults.bonuses[i].duration;
                document.getElementById(`bonus${i + 1}-freq`).value = appDefaults.bonuses[i].freq;
            }

            // Calculations
            syncTime('duration');
            calculateRealTime();

            // Manual Coach Reset (Silent - No Validation Modal)
            const defCoach = appDefaults.coachPreset;
            if (coachPresets[defCoach]) {
                speechSettings = JSON.parse(JSON.stringify(coachPresets[defCoach]));
                renderAudioToggles();
            }

            updateBonusVisibility(); // Fix UI
            saveToLocal();
        }

        function resetApp() {
            // Reset Global State
            isWorkoutActive = false;
            globalWorkoutStartVal = null;
            updateStartButtonState(); // Ensure button is reset

            clearInterval(timerInterval);
            // Force Tabataman on reset (User Request)
            try {
                let s = JSON.parse(localStorage.getItem('fnh_settings_v8') || "{}");
                s.coachPreset = 'tabataman';
                localStorage.setItem('fnh_settings_v8', JSON.stringify(s));
            } catch (e) { console.error("Reset pref fail", e); }
            location.reload();
        }

        function confirmStop() { if (confirm("Weet je zeker dat je de training wilt stoppen?")) { bgMusicManager.stopWorkout(); resetApp(); } }

        // Define cancelPause if not exists (fallback)
        function cancelPause() {
            document.getElementById('pause-modal').style.display = 'none';
            if (isPaused) {
                isPaused = false;
                document.body.classList.remove('mode-pause');
                const btn = document.getElementById('btn-pause');
                if (btn) { btn.innerText = ""; btn.classList.remove('paused'); }
                triggerAudio('manual_override', "We gaan weer door");
                if (bgMusicManager.hasStartedForWorkout) bgMusicManager.audio.play();
            }
        }

        // --- NEW FEATURES: LIVE SCHEDULE & NAVIGATION ---

        function renderLiveSchedule(forceRebuild = false) {
            const tbody = document.getElementById('live-table-body');

            // 1. Check if we need to build the rows (First run or Force)
            // We filter out 'finish' step, so count appropriately.
            const schedItems = schedule.filter(s => s.type !== 'finish');
            const needsBuild = forceRebuild || tbody.children.length === 0 || tbody.children.length !== schedItems.length;

            if (needsBuild) {
                tbody.innerHTML = "";
            }

            // 2. Setup Time Calculation
            let tempDate = new Date(workoutStartTime || Date.now());

            schedule.forEach((item, index) => {
                if (item.type === 'finish') return;

                let tr = document.getElementById(`sched-row-${index}`);

                // Build Row if needed
                if (needsBuild) {
                    tr = document.createElement('tr');
                    tr.id = `sched-row-${index}`;
                    tr.onclick = () => jumpToStep(index);

                    const tdTime = document.createElement('td'); // Cell 0
                    const tdName = document.createElement('td'); // Cell 1
                    const tdDur = document.createElement('td');  // Cell 2
                    tdDur.style.textAlign = "right";

                    tr.appendChild(tdTime);
                    tr.appendChild(tdName);
                    tr.appendChild(tdDur);
                    tbody.appendChild(tr);
                }

                // 4. Advance Time (Real Time Clock Logic) & Render
                let dur = item.initialTime;

                // Calculate Start & End Date for this step
                // startTime is simply tempDate (current pointer)
                const startTime = new Date(tempDate);
                let endTime = new Date(tempDate);

                if (index === currentIndex) {
                    // Special case: Current step logic matching the main loop
                    if (stepEndTime) {
                        // If running, we know the exact absolute end time
                        endTime = new Date(stepEndTime);
                    } else {
                        // Not running yet?
                        endTime.setSeconds(endTime.getSeconds() + dur);
                    }
                } else {
                    // Future step
                    endTime.setSeconds(endTime.getSeconds() + dur);
                }

                if (tr) {
                    // Update Class
                    if (index < currentIndex) tr.className = "past-row";
                    else if (index === currentIndex) tr.className = "active-row";
                    else tr.className = "future-row";

                    // Update Time (Start <br> End)
                    const fmt = (d) => d.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit', second: '2-digit' }) + "." + d.getMilliseconds().toString().padStart(3, '0');
                    tr.children[0].innerHTML = `<span style="color:#fff">${fmt(startTime)}</span><br><span style="color:#555">${fmt(endTime)}</span>`;

                    // Update Name (Static, but safe to refresh)
                    let desc = item.label;
                    if (item.info && item.info.round && item.info.exercise > 0) desc += ` <span style='color:#888; font-size:11px;'>(R${item.info.round}/E${item.info.exercise}/S${item.info.set})</span>`;
                    tr.children[1].innerHTML = desc;

                    // Update Duration
                    // Update Duration
                    if (item.type === 'work') {
                        tr.children[2].innerHTML = '';
                        const inp = document.createElement('input');
                        inp.type = 'number';
                        inp.value = dur;
                        inp.onfocus = () => { inp.select(); }; // User convenience
                        inp.className = 'no-drag'; // Prevent drag issues if any
                        inp.style.width = '50px';
                        inp.style.textAlign = 'center';
                        inp.style.background = 'transparent';
                        inp.style.color = '#fff';
                        inp.style.border = '1px solid #444';
                        inp.style.borderRadius = '4px';
                        inp.style.fontSize = '14px';
                        inp.style.padding = '2px';

                        inp.onclick = (e) => e.stopPropagation();

                        inp.onchange = (e) => {
                            const val = parseInt(e.target.value);
                            if (val && val >= 5) {
                                schedule.forEach((s, idx) => {
                                    // Update ALL work steps (Past, Present, Future)
                                    if (s.type === 'work') {
                                        const oldInit = s.initialTime;
                                        s.initialTime = val;

                                        if (idx > currentIndex) {
                                            s.time = val;
                                        } else if (idx === currentIndex) {
                                            s.time += (val - oldInit);
                                            if (s.time < 0) s.time = 0;
                                        }
                                    }
                                });
                                renderLiveSchedule(true);
                                triggerAudio('manual_override', "Tijd aangepast");
                            } else {
                                // Invalid or empty: Revert to current duration
                                e.target.value = dur;
                            }
                        };
                        tr.children[2].appendChild(inp);
                    } else {
                        tr.children[2].innerText = dur + "s";
                    }
                }

                // Advance the pointer for the NEXT loop iteration
                // The start of the next step is the end of this step.
                tempDate = new Date(endTime);
            });

            // --- UPDATE STATS ---
            updateEndTimeDisplay();

            // Update Work Time Display
            // Find first active or future 'work' step to show current setting (Excluding Bonuses)
            let workStep = schedule.find((s, i) => i >= currentIndex && s.type === 'work' && (!s.info || !s.info.bonusId));
            const workDisplay = document.getElementById('val-worktime');
            if (workDisplay) workDisplay.innerText = workStep ? (workStep.initialTime + "s") : "-";

            // Update Rest/Switch/Round Displays
            const updateStat = (type, id) => {
                const el = document.getElementById(id);
                if (!el) return;
                const found = schedule.find((s, i) => i >= currentIndex && s.type === type);
                el.innerText = found ? (found.initialTime + "s") : "-";
            };
            updateStat('rest', 'val-rest');
            updateStat('rest-exercise', 'val-switch');
            updateStat('rest-long', 'val-pause-round');

            return tempDate; // Return the final calculated end time
        }

        function updateLiveScheduleHighlight() {
            // Remove old highlight
            // FIX: Selector was '.live-table tr' which INCLUDED the <thead> row!
            // This caused index 0 to target the Header, and Index 1 to target the first body row.
            // Result: Highlight was always 1 step behind (OFFSET BY 1).
            const rows = document.querySelectorAll('#live-table-body tr');

            rows.forEach((r, idx) => {
                if (idx < currentIndex) r.className = "past-row";
                else if (idx === currentIndex) {
                    r.className = "active-row";
                    // Scroll disabled to keep focus on top of page
                }
                else r.className = "future-row";
            });
        }

        function handleNextClick() {
            if (currentIndex < schedule.length - 1) {
                currentIndex++;
                schedule.forEach(s => delete s.hasPlayedEntry); // Allow audio to play for new step
                stepEndTime = Date.now() + (schedule[currentIndex].time * 1000);
                triggerAudio('manual_override', "Volgende");
                renderLiveSchedule(); // Update times potentially?
                runStep();
            } else {
                finish();
            }
        }

        function handlePrevClick() {
            if (currentIndex > 0) {
                currentIndex--;
                schedule.forEach(s => delete s.hasPlayedEntry); // Allow audio to play for previous step
                // Restore time for the step we are going BACK to (full duration)
                schedule[currentIndex].time = schedule[currentIndex].initialTime;
                stepEndTime = Date.now() + (schedule[currentIndex].time * 1000);
                triggerAudio('manual_override', "Vorige");
                renderLiveSchedule();
                runStep();
            }
        }

        // SMART JUMP LOGIC
        let pendingJumpIndex = null;

        function jumpToStep(index) {
            if (index < 0 || index >= schedule.length) return;
            if (index === currentIndex) return;

            // 1. Pause App (to freeze state)
            if (!isPaused) handlePauseClick();

            // 2. Calculate Diff
            const diff = calculateJumpDiff(index);
            pendingJumpIndex = index;

            // 3. Show Modal
            document.getElementById('pause-modal').style.display = 'flex';

            if (diff > 0) {
                // SURPLUS (Skipping Forward) -> "Early Start" Logic
                // We have gained time.
                pendingEarlyStartSec = diff;
                pendingPauseDur = 0;
                document.getElementById('pause-modal-title').innerText = "SPRINGEN (OVERSLAAN)";
                document.getElementById('pause-msg-p').innerHTML = `Je slaat <span style="color:#30D158; font-weight:bold;">${diff}s</span> over.`;
            } else {
                // DEFICIT (Going Back) -> "Pause" Logic
                // We need more time.
                pendingEarlyStartSec = 0;
                pendingPauseDur = Math.abs(diff);
                document.getElementById('pause-modal-title').innerText = "SPRINGEN (TERUG)";
                document.getElementById('pause-msg-p').innerHTML = `Je voegt <span style="color:#FF9F0A; font-weight:bold;">${Math.abs(diff)}s</span> toe.`;
            }

            // Update End Time Preview Button
            const oldEndStr = document.getElementById('endTimeValue').value;
            // Approximate new end time based on diff
            // If diff > 0 (Surplus), new end is earlier (old - diff)
            // If diff < 0 (Deficit), new end is later (old + abs(diff))
            // Note: targetEndTimeDate is the reference.

            const curEnd = targetEndTimeDate;
            const newEndDate = new Date(curEnd.getTime() - (diff * 1000)); // diff is positive for surplus (earlier), negative for deficit (later)
            const newEndStr = newEndDate.toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' });

            document.getElementById('btn-text-push').innerText = `Eindtijd: ${oldEndStr} -> ${newEndStr}`;
        }

        function calculateJumpDiff(targetIdx) {
            // Returns SECONDS difference.
            // Positive = Surplus (Skipping / Early)
            // Negative = Deficit (Adding / Late)

            // 1. Current Remaining (Real)
            // Time remaining in current step + full time of all future steps
            let currentRem = 0;
            if (stepEndTime > Date.now()) currentRem += (stepEndTime - Date.now()) / 1000;
            for (let i = currentIndex + 1; i < schedule.length; i++) {
                currentRem += schedule[i].initialTime;
            }

            // 2. Target Remaining (Hypothetical)
            // Full time of target step + full time of all steps AFTER target
            let targetRem = schedule[targetIdx].initialTime;
            for (let i = targetIdx + 1; i < schedule.length; i++) {
                targetRem += schedule[i].initialTime;
            }

            // Diff = Current - Target
            // Example: Current has 100s rem. Target has 20s rem.
            // Diff = 80s (We have 80s extra "surplus" if we jump).
            return Math.ceil(currentRem - targetRem);
        }

        function cancelPause() {
            document.getElementById('pause-modal').style.display = 'none';
            pendingJumpIndex = null;
            pendingEarlyStartSec = 0;
            pendingPauseDur = 0;
            // Just resume
            handlePauseClick();
        }

        // --- iOS Audio Guide Popup ---
        (function checkDeviceAndInstruct() {
            // 1. Check of gebruiker dit permanent verborgen heeft
            if (localStorage.getItem("fnh_hide_audio_guide") === "true") return;

            // 2. Detecteer iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes("Mac") && "ontouchend" in document);
            if (!isIOS) return;

            // 3. Bepaal Model Type
            const width = Math.min(window.screen.width, window.screen.height);
            let deviceType = "switch";

            if (navigator.userAgent.includes("iPad") || (navigator.userAgent.includes("Mac") && "ontouchend" in document)) {
                deviceType = "ipad";
            }
            else if (width === 402 || width === 440) {
                deviceType = "action"; // iPhone 16 Pro / Max
            }
            else if (width === 393 || width === 430) {
                deviceType = "ambiguous"; // iPhone 14/15/16 mix
            }

            // 4. Toon Popup
            // Wait slightly to ensure DOM is ready if script is at end of body
            setTimeout(() => showAudioPopup(deviceType), 500);
        })();

        function showAudioPopup(type) {
            if (sessionStorage.getItem("audio_popup_seen")) return;

            let title = " Geluid Aanzetten";
            let msg = "";
            let icon = "";

            switch (type) {
                case "ipad":
                    title = "Instellen";
                    icon = "";
                    msg = `
                        <b>1. Bedieningspaneel:</b> Veeg rechtsboven omlaag.<br>
                        <b>2. Belletje:</b> Zorg dat het bel-icoon  AAN staat.<br>
                        <b>3. Focus:</b> Zet 'Niet Storen' aan.
                    `;
                    break;
                case "action":
                    title = "Instellen";
                    icon = "";
                    msg = `
                        <b>Optie 1:</b> Houd de <b>Actieknop</b> (zijkant) ingedrukt tot 'Stille modus: Uit'.<br>
                        <b>Optie 2:</b> Via Bedieningspaneel (belletje ).
                    `;
                    break;
                case "ambiguous":
                    title = "Instellen";
                    icon = "";
                    msg = `
                        <b>Heb je een Actieknop?</b><br> Houd ingedrukt tot Stille Modus UIT gaat.<br><br>
                        <b>Heb je een Schakelaar?</b><br> Zet het schuifje links omhoog.
                    `;
                    break;
                default:
                    title = "Zet Geluid Aan";
                    icon = "  ";
                    msg = `
                        <b>De fysieke schakelaar:</b><br>
                        Zet het schuifje aan de linkerkant omhoog.<br>
                        <i>(Geen oranje vlakje zichtbaar!)</i>
                    `;
                    break;
            }

            const div = document.createElement("div");
            div.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:99999; display:flex; align-items:center; justify-content:center; padding:20px; backdrop-filter:blur(5px);";

            div.innerHTML = `
                <div style="background:#1c1c1e; color:white; padding:20px; border-radius:20px; max-width:340px; text-align:center; border:1px solid #333; box-shadow:0 10px 30px rgba(0,0,0,0.5);">
                    <div style="font-size:35px; margin-bottom:10px;">${icon}</div>
                    <h2 style="margin:0 0 10px 0; color:#30D158; font-size:20px;">${title}</h2>
                    <div style="font-size:13px; color:#ccc; line-height:1.4; text-align:left; margin-bottom:15px;">${msg}</div>
                    
                    <div style="background:rgba(255, 214, 10, 0.1); border:1px solid rgba(255, 214, 10, 0.3); padding:10px; border-radius:8px; text-align:left; margin-bottom:15px;">
                        <div style="font-size:12px; font-weight:bold; color:#FFD60A; margin-bottom:2px;"> PRO TIP: Begeleide Toegang</div>
                        <div style="font-size:11px; color:#ddd;">
                            Voorkomt dat je de app wegveegt n blokkeert notificaties.
                            <br><br>
                             <b>Druk 3x snel op de zijknop</b> om te starten.
                        </div>
                    </div>

                    <label style="display:flex; align-items:center; justify-content:center; margin-bottom:15px; cursor:pointer; font-size:12px; color:#888;">
                        <input type="checkbox" id="hide-future-popup" style="margin-right:8px; transform:scale(1.2); accent-color:#30D158;">
                        Dit bericht niet meer tonen
                    </label>

                    <button id="btn-audio-ok" style="background:#0A84FF; color:white; border:none; padding:12px 30px; border-radius:12px; font-weight:bold; font-size:16px; cursor:pointer; width:100%;">
                        Begrepen 
                    </button>
                </div>
            `;

            document.body.appendChild(div);

            document.getElementById("btn-audio-ok").onclick = () => {
                if (document.getElementById("hide-future-popup").checked) {
                    localStorage.setItem("fnh_hide_audio_guide", "true");
                } else {
                    sessionStorage.setItem("audio_popup_seen", "true");
                }
                div.remove();
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (ctx.state !== 'running') ctx.resume()
            };
        }

        // IMPROVED: Cross-browser & iOS Friendly Fullscreen
        function toggleFullScreen() {
            const doc = window.document;
            const docEl = doc.documentElement;

            // 1. Check for iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.userAgent.includes("Mac") && "ontouchend" in doc);

            if (isIOS) {
                // iOS doesn't support the fullscreen API for web apps in Safari reliably.
                // Best practice is "Add to Home Screen" (Standalone mode).
                const isStandalone = ('standalone' in window.navigator) && (window.navigator.standalone);

                if (!isStandalone) {
                    showIOSFullscreenHelp();
                    return;
                }
            }

            // 2. Standard API
            const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
            const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

            if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
                if (requestFullScreen) {
                    requestFullScreen.call(docEl).catch(err => {
                        console.warn("Fullscreen request denied/failed", err);
                        // Fallback: If blocked (often on iOS), show help
                        if (isIOS) showIOSFullscreenHelp();
                    });
                }
            } else {
                if (cancelFullScreen) {
                    cancelFullScreen.call(doc);
                }
            }
        }

        function showIOSFullscreenHelp() {
            // Check if already seen session-wise to avoid annoyance, unless user clicks button explicitly? 
            // Actually, if they click the button, they WANT fullscreen, so show it every time.

            const div = document.createElement("div");
            div.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:200005; display:flex; align-items:center; justify-content:center; padding:20px; backdrop-filter:blur(5px);";

            div.innerHTML = `
                <div style="background:#1c1c1e; color:white; padding:25px; border-radius:24px; max-width:340px; text-align:center; border:1px solid #333; box-shadow:0 10px 40px rgba(0,0,0,0.6);">
                    <div style="font-size:40px; margin-bottom:15px;"></div>
                    <h2 style="margin:0 0 10px 0; color:#30D158; font-size:22px;">Volledig Scherm</h2>
                    <div style="font-size:14px; color:#ccc; line-height:1.5; text-align:left; margin-bottom:20px;">
                        Op iPhone/iPad werkt dit knopje niet direct in Safari.
                        <br><br>
                        <b>Voor de beste ervaring:</b>
                        <ol style="margin:10px 0; padding-left:20px; color:#fff;">
                            <li>Tik op de <b style="color:#0A84FF">Deel-knop</b>  (onderin).</li>
                            <li>Kies <b style="color:#fff">"Zet op beginscherm"</b> .</li>
                        </ol>
                        Start de app daarna via het nieuwe icoontje!
                    </div>
                    <button id="btn-ios-close" style="background:#333; color:white; border:none; padding:12px 30px; border-radius:12px; font-weight:bold; font-size:16px; cursor:pointer; width:100%;">
                        Sluiten
                    </button>
                </div>
            `;
            document.body.appendChild(div);
            document.getElementById("btn-ios-close").onclick = () => div.remove();
        }

        // --- ROBUST iOS PWA AUDIO FIX ---
        // Solves "intermittent audio" by forcing context resume on touch & visibility change
        function unlockIOSAudio() {
            // 1. Web Audio API Context
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                // Access the global context if we can find it, or just create a dummy to wake the subsystem?
                // Better: If we have a global context variable (created in playMp3WebAudio), use it.
                // If not, we can't easily reach it unless we exposed it.
                // However, usually one context per page is best practice.
                // Let's assume standard behavior:
                // We'll trust that 'playMp3WebAudio' (if it exists) manages its context.
                // We can try to resume IT if we can find the variable.
                // Looking at standard implementations, often 'audioCtx' is global.
                if (window.audioCtx && window.audioCtx.state === 'suspended') {
                    window.audioCtx.resume().then(() => console.log("AudioContext Resumed by Touch"));
                }
            }

            // 2. HTML5 Audio Elements (Warmup)
            // Silence is golden.
        }

        // Global unlocker for ANY AudioContext created in the future
        document.addEventListener('touchstart', function () {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext && window.audioCtx) {
                window.audioCtx.resume();
            }
        }, { passive: true });

        document.addEventListener('click', function () {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext && window.audioCtx) {
                window.audioCtx.resume();
            }
        }, { passive: true });

        // VISIBILITY KEEP-ALIVE
        document.addEventListener('visibilitychange', function () {
            if (!document.hidden) {
                // App came to foreground -> Force Resume
                console.log("App Foregrounded -> Resuming Audio");
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext && window.audioCtx && window.audioCtx.state === 'suspended') {
                    window.audioCtx.resume();
                }
                // Also refresh Background Music if needed
                if (bgMusicManager && bgMusicManager.audio && !bgMusicManager.audio.paused) {
                    // Check if it actually stopped playing?
                    // Sometimes iOS pauses it.
                    // If we expect it to be playing, we might need to nudge it.
                }
            }
        });

        // Periodic Highlight Update for Setup Screen
        setInterval(() => {
            const setupScreen = document.getElementById('setup-screen');
            if (setupScreen && !setupScreen.classList.contains('hidden')) {
                updateRoundCardsInfo();
            }
        }, 5000);

        // NEW: Live Edit Logic
        function toggleLiveEdit() {
            // Switch to Setup Screen
            document.getElementById('timer-screen').style.display = 'none';
            document.getElementById('setup-screen').classList.remove('hidden');

            // Note: Timer continues in background because we simply hide the div.
            // isWorkoutActive ensures "Start" button becomes "Resume"
            updateStartButtonState();
        }

        function updateStartButtonState() {
            const btn = document.getElementById('btn-start-app');
            if (!btn) return;

            if (isWorkoutActive) {
                btn.innerText = " TERUG NAAR TRAINING";
                btn.classList.add('active-session-btn'); // CSS for pulsing green?
                btn.style.background = "#30D158";
                btn.style.color = "black";
            } else {
                btn.innerText = "START TRAINING";
                btn.classList.remove('active-session-btn');
                btn.style.background = ""; // Revert to default class style
                btn.style.color = "";
            }
        }

        function resumeSyncWorkout() {
            if (!globalWorkoutStartVal) return; // Safety

            const now = Date.now();
            let elapsedSec = Math.floor((now - globalWorkoutStartVal) / 1000);

            console.log("Resuming Sync. Elapsed:", elapsedSec);

            // 1. Recalculate everything based on potential edits
            calculateRealTime();
            generateScheduleData(true);
            populateJumpMenus(); // ensure stats work

            // 2. Find Sync Point (Same logic as Jump In)
            let foundIdx = 0;
            let cumulativeSec = 0;
            for (let i = 0; i < schedule.length; i++) {
                const stepTime = schedule[i].time;
                if (cumulativeSec + stepTime > elapsedSec) {
                    foundIdx = i;
                    break;
                }
                cumulativeSec += stepTime;
                foundIdx = i;
            }

            // 3. Jump to that point
            currentIndex = foundIdx;
            const remainingInStep = (cumulativeSec + schedule[foundIdx].time) - elapsedSec;

            // 4. Show Timer
            document.getElementById('setup-screen').classList.add('hidden');
            const ts = document.getElementById('timer-screen');
            ts.style.cssText = '';
            ts.style.display = 'block';

            // 5. Update Timer State
            // IMPORTANT: We do NOT reset workoutStartTime here, simply ensure it aligns
            workoutStartTime = new Date(globalWorkoutStartVal);

            stepEndTime = Date.now() + (remainingInStep * 1000);
            renderLiveSchedule();

            // Audio context is likely already running, no need to force resume unless blocked.

            runStep();
            triggerAudio('work_start', "Schema bijgewerkt");
        }

    </script>

    <div id="pre-workout-overlay" class="modal-overlay epic-overlay"
        style="display:none; flex-direction:column; justify-content:center; align-items:center; background:black; color:white;">
        <div style="font-size:18px; color:#888; text-transform:uppercase; letter-spacing:4px; margin-bottom:10px;">
            TRAINING BEGINT OVER</div>

        <div id="pre-workout-timer" class="epic-timer" style="font-size:120px; font-weight:900; line-height:1;">
            00:00
        </div>

        <!-- NEW START TIME INFO -->
        <div id="pre-workout-start-time"
            style="font-size:24px; color:#30D158; font-weight:bold; margin-bottom:20px; text-transform:uppercase; letter-spacing:1px; text-shadow: 0 0 10px rgba(48,209,88,0.4);">
            STARTTIJD: --:--
        </div>



        <button onclick="previewEarlyStartOptions()" class="action-btn"
            style="margin-top:50px; padding:15px 40px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); backdrop-filter:blur(10px); width:auto;">
             NU BEGINNEN (OVERSLAAN)
        </button>

        <button id="btn-jump-in" onclick="startSyncWorkout()" class="action-btn"
            style="display:none; margin-top:15px; padding:15px 40px; background:rgba(48,209,88,0.2); border:1px solid rgba(48,209,88,0.4); backdrop-filter:blur(10px); width:auto; color:#30D158;">
             IN HAKEN (MOMENTEEL BEZIG)
        </button>
        <script>
            function getFingerprint() {
                let fp = localStorage.getItem('fnh_fingerprint');
                if (!fp) {
                    fp = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
                    localStorage.setItem('fnh_fingerprint', fp);
                }
                return fp;
            }

            function logWorkoutToSheet() {
                const url =
                    "https://script.google.com/macros/s/AKfycbzjwH5TfLJEinllUn3wYlQE17uno0DdnLoBaG1FmdMeVBUE0wd5-pf07TEoOg6jj2sF/exec";

                // Safe Retrieval
                const totalMinEl = document.getElementById('totalMin');
                const totalMinText = totalMinEl ? totalMinEl.value : "Err";

                const payload = {
                    fingerprint: getFingerprint(),
                    rounds: document.getElementById('rounds').value,
                    exercises: document.getElementById('exercises').value,
                    sets: document.getElementById('sets').value,
                    totalMin: totalMinText,
                    coach: document.getElementById('coach-preset-live') ? document.getElementById('coach-preset-live').value : 'unknown', // UPDATED
                    startTime: new Date().toLocaleTimeString('nl-NL', { hour: '2-digit', minute: '2-digit' })
                };

                console.log("Logging Payload:", payload);

                // Fire and forget (no-cors prevents reading response but allows sending)
                // Use text/plain to avoid CORS preflight (OPTIONS) which Apps Script doesn't handle
                fetch(url, {
                    method: 'POST',
                    mode: 'no-cors',
                }).then(() => console.log("Log sent (blind)")).catch(e => console.log("Logging error", e));
            }
            // --- PULL TO REFRESH (Custom) ---
            (function initPullToRefresh() {
                // 1. Inject CSS
                const style = document.createElement('style');
                style.innerHTML = `
                #ptr-spinner {
                    position: fixed; top: -60px; left: 0; right: 0; height: 60px;
                    display: flex; align-items: center; justify-content: center;
                    z-index: 99999; pointer-events: none; /* Passes touches through until visible/active? No, we need to see it. */
                    transition: top 0.2s;
                }
                #ptr-icon {
                    font-size: 24px; color: #30D158;
                    transition: transform 0.2s;
                    text-shadow: 0 0 10px black;
                }
                .ptr-refreshing #ptr-spinner { top: 20px; }
                .ptr-refreshing #ptr-icon { animation: ptr-spin 1s linear infinite; }
                @keyframes ptr-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
            `;
                document.head.appendChild(style);

                // 2. Inject DOM
                const ptr = document.createElement('div');
                ptr.id = 'ptr-spinner';
                ptr.innerHTML = '<div id="ptr-icon"></div>';
                document.body.appendChild(ptr);

                // 3. Variables
                let startY = 0;
                let isDragging = false;
                const threshold = 250; // Increased to make it harder (user request)

                // 4. Touch Handlers
                document.addEventListener('touchstart', (e) => {
                    // Only enable if at top AND critical overlays are NOT active
                    // We allow it on Setup Screen (Start Page) now.
                    const isBlockingOverlay = document.getElementById('pause-modal').style.display === 'flex' ||
                        document.getElementById('pre-workout-overlay').style.display === 'flex';

                    if (window.scrollY === 0 && !isBlockingOverlay) {
                        startY = e.touches[0].clientY;
                        isDragging = true;
                    }
                }, { passive: true });

                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    const y = e.touches[0].clientY;
                    const diff = y - startY;

                    if (diff > 0 && window.scrollY <= 0) {
                        // Pulling down
                        ptr.style.top = (diff / 3.0 - 60) + 'px'; // Increased resistance slightly
                        const icon = document.getElementById('ptr-icon');
                        if (diff > threshold) {
                            icon.style.transform = 'rotate(180deg)';
                            icon.innerText = "";
                        } else {
                            icon.style.transform = 'rotate(0deg)';
                            icon.innerText = "";
                        }
                    } else {
                        isDragging = false; // Scrolled down
                    }
                }, { passive: true });

                document.addEventListener('touchend', (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    const y = e.changedTouches[0].clientY;
                    const diff = y - startY;

                    if (diff > threshold && window.scrollY <= 0) {
                        // Trigger Refresh Check
                        if (confirm("Weet je zeker dat je de pagina wilt verversen? \n(De huidige training stopt dan)")) {
                            ptr.className = 'ptr-refreshing';
                            location.reload();
                        } else {
                            // Cancel
                            ptr.style.top = '-60px';
                        }
                    } else {
                        // Reset
                        ptr.style.top = '-60px';
                    }
                });
            })();

            // --- CLICK OUTSIDE TO CLOSE AUDIO SETTINGS ---
            document.addEventListener('click', (e) => {
                const panel = document.getElementById('active-volume-panel');
                const btn = document.getElementById('global-volume-btn');

                if (panel && panel.style.display !== 'none') {
                    // Check if click is OUTSIDE panel AND OUTSIDE trigger button
                    if (!panel.contains(e.target) && !btn.contains(e.target)) {
                        panel.style.display = 'none';
                    }
                }
            });

        </script>

        <!-- AUDIO GUIDE POPUP -->



    </div> <!-- Close pre-workout-overlay -->



    <!-- GLOBAL FULLSCREEN BTN (Relocated & HIGH Z-INDEX) -->
    <div id="global-fullscreen-btn"
        style="position:fixed; top:20px; right:75px; z-index:200000; background:rgba(0,0,0,0.6); width:44px; height:44px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; border:1px solid rgba(255,255,255,0.5); backdrop-filter:blur(10px); color:white; box-shadow:0 4px 12px rgba(0,0,0,0.3);"
        onclick="toggleFullScreen()">
        <span style="font-size:20px;"></span>
    </div>

    <div id="global-volume-btn"
        style="position:fixed; top:20px; right:20px; z-index:200000; background:rgba(0,0,0,0.6); width:44px; height:44px; border-radius:50%; display:flex; align-items:center; justify-content:center; cursor:pointer; border:1px solid rgba(255,255,255,0.5); backdrop-filter:blur(10px); color:white; box-shadow:0 4px 12px rgba(0,0,0,0.3);"
        onclick="toggleVolumePanel()">
        <span style="font-size:20px;"></span>
    </div>

    <!-- VOLUME PANEL OVERLAY (Relocated to Body) -->
    <div id="active-volume-panel"
        style="display:none; position:fixed; top:70px; right:20px; width:280px; max-height:80vh; overflow-y:auto; scrollbar-width:none; -ms-overflow-style:none; background:rgba(28, 28, 30, 0.95); backdrop-filter:blur(20px); -webkit-backdrop-filter:blur(20px); padding:15px; border-radius:20px; border:1px solid rgba(255,255,255,0.2); z-index:200001; box-shadow:0 30px 60px rgba(0,0,0,0.8);">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:15px;">
            <span style="font-size:13px; color:#fff; font-weight:bold; letter-spacing:0.5px;">AUDIO SETTINGS</span>
            <span style="font-size:24px; cursor:pointer; opacity:0.6;" onclick="toggleVolumePanel()"></span>
        </div>

        <!-- Playback Controls -->
        <div
            style="display:flex; align-items:center; justify-content:center; gap:25px; margin-bottom:25px; background:rgba(255,255,255,0.05); padding:10px; border-radius:15px;">
            <div onclick="bgMusicManager.playPrevious()" style="cursor:pointer; font-size:20px; opacity:0.8;">
            </div>
            <div onclick="bgMusicManager.togglePlayback()"
                style="cursor:pointer; font-size:28px; transform:scale(1.1);"></div>
            <div onclick="bgMusicManager.playNext()" style="cursor:pointer; font-size:20px; opacity:0.8;"></div>
        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
            <span style="font-size:16px; min-width:30px;"></span>
            <div style="flex:1; margin:0 10px; display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#aaa; margin-bottom:4px; font-weight:bold;">WERK MUZIEK</span>
                <input type="range" id="vol-music-live" min="0" max="1" step="0.1" value="0.4"
                    style="width:100%; accent-color:#30D158;" oninput="updateLiveVolumes()">
            </div>

        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
            <span style="font-size:16px; min-width:30px;"></span>
            <div style="flex:1; margin:0 10px; display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#aaa; margin-bottom:4px; font-weight:bold;">RUST MUZIEK</span>
                <input type="range" id="vol-music-rest-live" min="0" max="1" step="0.1" value="0.2"
                    style="width:100%; accent-color:#FF9F0A;" oninput="updateLiveVolumes()">
            </div>

        </div>

        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:20px;">
            <span style="font-size:16px; min-width:30px;"></span>
            <div style="flex:1; margin:0 10px; display:flex; flex-direction:column;">
                <span style="font-size:10px; color:#aaa; margin-bottom:4px; font-weight:bold;">COACH VOLUME</span>
                <input type="range" id="vol-coach-live" min="0" max="1" step="0.1" value="1.0"
                    style="width:100%; accent-color:#0A84FF;" oninput="updateLiveVolumes()">
            </div>

        </div>

        <!-- COLLAPSIBLE AUDIO SETTINGS -->
        <!-- AUDIO SETTINGS (Always Visible) -->
        <div style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">

            <div style="margin-top:15px; padding-left:5px; padding-right:5px;">
                <!-- Continuous Mode Toggle -->
                <div
                    style="display:flex; align-items:center; justify-content:space-between; padding:15px; background:rgba(255,255,255,0.05); border-radius:12px; border:1px solid rgba(255,255,255,0.05);">
                    <div style="display:flex; flex-direction:column; text-align:left;">
                        <div style="font-size:13px; color:#fff; font-weight:bold;"> Continuous Mode</div>
                        <div style="font-size:10px; color:#888; margin-top:2px;">Alleen werkmuziek (geen dip)</div>
                    </div>
                    <label class="switch" style="position:relative; display:inline-block; width:40px; height:24px;">
                        <input type="checkbox" id="chk-continuous-music"
                            onchange="bgMusicManager.setContinuous(this.checked)">
                        <span class="slider round"
                            style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background-color:#444; transition:.4s; border-radius:34px;"></span>
                        <style>
                            .slider:before {
                                position: absolute;
                                content: "";
                                height: 18px;
                                width: 18px;
                                left: 3px;
                                bottom: 3px;
                                background-color: white;
                                transition: .4s;
                                border-radius: 50%;
                            }

                            input:checked+.slider {
                                background-color: #30D158;
                            }

                            input:checked+.slider:before {
                                transform: translateX(16px);
                            }
                        </style>
                    </label>
                </div>

                <!-- GENRE LIST CONTAINER (Reordered) -->
                <div id="audio-settings-genres"
                    style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px; max-height:200px; overflow-y:auto;">
                    <!-- Populated by renderGenreToggles -->
                </div>

                <!-- PLAYLIST VIEW (Reordered) -->
                <div id="playlist-view"
                    style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px; max-height:150px; overflow-y:auto;">
                    <div id="gym-now-playing"
                        style="font-size:11px; color:#30D158; font-weight:bold; margin-bottom:5px;">
                        Now Playing: -</div>
                    <div id="gym-queue-list" style="font-size:10px; color:#666;">
                        <!-- Queue items populated by JS -->
                    </div>
                </div>

                <!-- COACH SETTINGS (Reordered) -->
                <div style="border-top:1px solid rgba(255,255,255,0.1); margin-top:15px; padding-top:15px;">
                    <div
                        style="font-size:11px; font-weight:900; color:#666; margin-bottom:10px; text-transform:uppercase;">
                        COACH TYPE</div>

                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <button class="toggle-btn active" id="btn-audio-speech-live"
                            onclick="setAudioMode('speech'); updateLiveAudioUI();"
                            style="flex:1; padding:8px; font-size:11px;"> SPRAAK</button>
                        <button class="toggle-btn" id="btn-audio-beep-live"
                            onclick="setAudioMode('beep'); updateLiveAudioUI();"
                            style="flex:1; padding:8px; font-size:11px;"> PIEPJES</button>
                    </div>

                    <select id="coach-preset-live" class="text-input"
                        onchange="applyCoachPreset(this.value); saveToLocal();"
                        style="width:100%; font-size:13px; padding:10px; margin-bottom:10px; background:rgba(0,0,0,0.3); border-radius:10px;">
                        <!-- Populated via JS -->
                    </select>

                    <!-- SPEECH TOGGLES (Detailed) -->
                    <div id="audio-toggles-panel"
                        style="margin-top:10px; padding-top:5px; border-top:1px solid rgba(255,255,255,0.05);">
                        <!-- Populated by renderAudioToggles -->
                    </div>
                </div>


            </div>
        </div>
    </div>
    </div>

    <script>
        // Initialize Global Database
        let workoutDatabase = [];
        fetch('workoutdatabase.json')
            .then(response => response.json())
            .then(data => {
                workoutDatabase = data;
                console.log("Workout Database Loaded:", workoutDatabase.length, "items");
                populateExerciseDatalist(); // Populate datalist on load
                hydrateMissingDetails(); // Auto-fill details for existing exercises
            })
            .catch(err => console.error("Failed to load workout database:", err));

        function populateExerciseDatalist() {
            let dl = document.getElementById('exercise-datalist');
            if (!dl) {
                dl = document.createElement('datalist');
                dl.id = 'exercise-datalist';
                document.body.appendChild(dl);
            }
            dl.innerHTML = '';
            // unique names
            const names = new Set(workoutDatabase.map(e => e.exercise_name));
            names.forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                dl.appendChild(opt);
            });
        }

        // AUTO-HYDRATION FUNCTION
        function hydrateMissingDetails() {
            console.log("Starting hydration of missing details...");
            let updatesMade = false;

            // Iterate over all possible round/exercise keys in customNames (which tracks all exercise names)
            Object.keys(customNames).forEach(key => {
                const exerciseName = customNames[key];
                if (!exerciseName) return;

                // Check if details are missing
                const hasDetails = customDetails[key] && (customDetails[key].desc || customDetails[key].mat || customDetails[key].thumbUrl);

                // If missing details (or we want to force check, but let's stick to missing for now or if just name exists)
                if (!hasDetails) {
                    const match = workoutDatabase.find(e => e.exercise_name.toLowerCase() === exerciseName.toLowerCase());
                    if (match) {
                        if (!customDetails[key]) customDetails[key] = {};

                        customDetails[key].desc = match.instructions || '';
                        customDetails[key].mat = match.material_name || '';
                        customDetails[key].matDesc = match.material_description || '';
                        customDetails[key].thumbUrl = match.thumbnail || '';
                        customDetails[key].videoUrl = match.video_search_url || '';
                        customDetails[key].checkNum = match.check_number || '';

                        updatesMade = true;
                        console.log(`Hydrated ${key}: ${exerciseName}`);
                    }
                }
            });

            if (updatesMade) {
                saveToLocal();
                console.log("Hydration complete. Saving and re-rendering...");
                // Re-render all rounds to show new details
                renderAllRounds();
            } else {
                console.log("Hydration complete. No updates needed.");
            }
        }

        function renderAllRounds() {
            // Re-render visible round cards if they exist
            const roundCards = document.querySelectorAll('.round-card');
            roundCards.forEach((card, idx) => {
                renderRoundExerciseList(idx);
            });
        }

        // INLINE ROUND EXERCISE EDITOR (NO POPUP)

        // Function to render exercise list directly in a round card
        function renderRoundExerciseList(roundIndex) {
            const roundCard = document.getElementById(`round-card-${roundIndex}`);
            if (!roundCard) return;

            // Get round configuration
            const exercisesInput = roundCard.querySelector('input[onchange*="\'exercises\'"]');
            const setsInput = roundCard.querySelector('input[onchange*="\'sets\'"]');

            if (!exercisesInput || !setsInput) return;

            const numExercises = parseInt(exercisesInput.value) || 5;
            const numSets = parseInt(setsInput.value) || 3;

            // Initialize round data if not exists
            if (!roundExercises[roundIndex]) {
                roundExercises[roundIndex] = {};
            }

            // Check if exercise list container already exists
            let exerciseListContainer = roundCard.querySelector('.exercise-list-container');
            if (!exerciseListContainer) {
                exerciseListContainer = document.createElement('div');
                exerciseListContainer.className = 'exercise-list-container';
                exerciseListContainer.style.cssText = 'margin-top:15px; padding-top:15px; border-top:1px solid rgba(255,255,255,0.1);';
                roundCard.appendChild(exerciseListContainer);
            }

            // Clear existing content
            exerciseListContainer.innerHTML = '';

            // Header removed as per user request

            // Create list of all exercise-set combinations
            for (let exIdx = 0; exIdx < numExercises; exIdx++) {
                // Initialize exercise data if not exists
                if (!roundExercises[roundIndex][exIdx]) {
                    roundExercises[roundIndex][exIdx] = {};
                }

                for (let setIdx = 0; setIdx < numSets; setIdx++) {
                    const exerciseName = roundExercises[roundIndex][exIdx][setIdx] || '';
                    const uniqueId = `r${roundIndex + 1}-e${exIdx + 1}-s${setIdx + 1}`;

                    // --- MAIN ROW WRAPPER ---
                    const rowWrapper = document.createElement('div');
                    rowWrapper.style.cssText = 'margin-bottom:6px; background:rgba(0,0,0,0.3); border-radius:8px; overflow:hidden; transition:all 0.2s;';

                    // --- VISIBLE HEADER (Click to expand) ---
                    const exerciseRow = document.createElement('div');
                    exerciseRow.className = 'exercise-row-header';
                    exerciseRow.style.cssText = 'display:flex; justify-content:space-between; align-items:center; padding:8px 12px; cursor:pointer; border-left:3px solid ' + (setIdx === 0 ? '#30D158' : '#666') + ';';

                    // Hover effects
                    exerciseRow.onmouseover = () => { exerciseRow.style.background = 'rgba(48,209,88,0.1)'; };
                    exerciseRow.onmouseout = () => { exerciseRow.style.background = 'transparent'; };

                    const labelDiv = document.createElement('div');
                    labelDiv.style.cssText = 'display:flex; align-items:center; gap:10px; flex:1;';

                    // Expand/Collapse Arrow
                    const arrowBtn = document.createElement('span');
                    arrowBtn.id = `arrow-${uniqueId}`;
                    arrowBtn.innerHTML = ''; // Right arrow
                    arrowBtn.style.cssText = 'font-size:10px; color:#888; transition:transform 0.2s; display:inline-block; width:15px;';

                    // Click handler for arrow/row to toggle details
                    exerciseRow.onclick = (e) => {
                        // Don't toggle if clicking directly on the editable name or inputs
                        if (e.target.isContentEditable || e.target.tagName === 'INPUT') return;
                        toggleExerciseDetails(uniqueId);
                    };

                    const label = document.createElement('span');
                    label.style.cssText = 'font-size:11px; color:#888; min-width:120px;';
                    label.innerText = `Oefening ${exIdx + 1}, Set ${setIdx + 1}`;


                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.setAttribute('list', 'exercise-datalist');
                    nameInput.value = exerciseName;
                    nameInput.style.cssText = 'font-size:13px; color:' + (exerciseName === '' ? '#666' : '#fff') + '; font-weight:600; outline:none; background:transparent; border:1px solid transparent; border-radius:4px; transition:all 0.2s; min-width: 100px; padding:4px 8px; font-family:inherit; width:100%;';

                    // Prevent row click when editing name
                    nameInput.onclick = (e) => e.stopPropagation();

                    nameInput.onfocus = () => {
                        nameInput.style.background = 'rgba(10,132,255,0.2)';
                        nameInput.style.color = '#fff';
                        nameInput.select();
                    };

                    nameInput.onblur = () => {
                        nameInput.style.background = 'transparent';
                        const newExercise = nameInput.value.trim();
                        if (newExercise !== '' && newExercise !== exerciseName) {
                            updateExerciseSlot(roundIndex, exIdx, setIdx, newExercise);
                        } else if (newExercise === '') {
                            nameInput.value = exerciseName;
                        }
                    };

                    nameInput.onkeydown = (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            nameInput.blur();
                        }
                    };

                    labelDiv.appendChild(arrowBtn);
                    labelDiv.appendChild(label);
                    labelDiv.appendChild(nameInput);
                    exerciseRow.appendChild(labelDiv);

                    // Time Input (Right Side)
                    const timeDiv = document.createElement('div');
                    timeDiv.style.cssText = 'display:flex; align-items:center; gap:5px; margin-left:10px; flex-shrink:0;';



                    const timeInput = document.createElement('input');
                    timeInput.type = 'number';
                    // removed highlight-input class to avoid conflicts

                    const globalRound = workoutRounds[roundIndex];
                    const defaultWt = (globalRound && globalRound.workTime) ? globalRound.workTime : 45;
                    const uniqueTimeKey = `r${roundIndex + 1}-e${exIdx + 1}-s${setIdx + 1}`;
                    const customWt = customWorkTimes[uniqueTimeKey];

                    const displayVal = customWt || defaultWt;
                    timeInput.value = displayVal;
                    timeInput.placeholder = defaultWt;

                    // High Contrast Styling 
                    let inputColor = '#FFFFFF';
                    let inputBorder = '1px solid #3A3A3C';
                    let inputBg = '#2C2C2E';

                    if (customWt) {
                        inputColor = '#30D158';
                        inputBorder = '1px solid #30D158';
                        inputBg = 'rgba(48,209,88,0.15)';
                    }

                    // Force explicit dimensions and visibility
                    timeInput.style.cssText = `width:50px; height:28px; background:${inputBg}; border:${inputBorder}; border-radius:6px; text-align:center; color:${inputColor}; font-size:14px; font-weight:bold; font-family:inherit; outline:none; -moz-appearance:textfield; display:block; padding:0;`;

                    timeInput.onchange = (e) => {
                        setCustomWorkTime(roundIndex, exIdx, setIdx, e.target.value);
                    };
                    timeInput.onclick = (e) => e.stopPropagation();


                    timeDiv.appendChild(timeInput);
                    exerciseRow.appendChild(timeDiv);

                    rowWrapper.appendChild(exerciseRow);

                    // --- DETAILS SECTION (Hidden by default) ---
                    const detailsDiv = document.createElement('div');
                    detailsDiv.id = `details-${uniqueId}`;
                    detailsDiv.style.cssText = 'display:none; padding:10px 12px; background:rgba(0,0,0,0.2); border-top:1px solid rgba(255,255,255,0.05); flex-direction:column; gap:8px;';

                    // LOAD SAVED DETAILS
                    const savedDetails = customDetails && customDetails[uniqueId] ? customDetails[uniqueId] : {};

                    // 1. Check Number Input & Auto-load
                    // --- CSS STYLES (Inline optimized) ---
                    const labelStyle = 'font-size:11px; color:#8E8E93; font-weight:600; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px; display:block;';
                    const inputStyle = 'width:100%; padding:10px; background:#2C2C2E; border:1px solid #3A3A3C; border-radius:8px; color:#fff; font-size:13px; font-family:inherit; transition:border 0.2s; outline:none;';
                    const rowStyle = 'display:flex; gap:12px; margin-bottom:12px; align-items:flex-start;';

                    // 1. Top Row: Check # (Small) + Materiaal (Flex)
                    const topRow = document.createElement('div');
                    topRow.style.cssText = rowStyle;


                    // Group: Smart Menu Trigger (Formerly Check #)
                    const menuGroup = document.createElement('div');
                    menuGroup.style.cssText = 'flex: 0 0 50px; display:flex; flex-direction:column;';
                    const menuLabel = document.createElement('span');
                    menuLabel.innerText = 'Kies';
                    menuLabel.style.cssText = labelStyle + 'text-align:center;';

                    const smartMenu = createExerciseMenu(uniqueId, roundIndex, exIdx, setIdx);
                    // Append
                    menuGroup.appendChild(menuLabel);
                    menuGroup.appendChild(smartMenu);


                    // Group: Materiaal
                    const matGroup = document.createElement('div');
                    matGroup.style.cssText = 'flex: 1;';
                    const matLabel = document.createElement('span');
                    matLabel.innerText = 'Materiaal';
                    matLabel.style.cssText = labelStyle;
                    const matInput = document.createElement('input');
                    matInput.id = `mat-${uniqueId}`;
                    matInput.type = 'text';
                    matInput.placeholder = 'Bijv. Dumbbells';
                    matInput.style.cssText = inputStyle;
                    // Populate from Saved Data
                    if (savedDetails.mat) matInput.value = savedDetails.mat;

                    matGroup.appendChild(matLabel);
                    matGroup.appendChild(matInput);

                    topRow.appendChild(menuGroup);
                    topRow.appendChild(matGroup);
                    detailsDiv.appendChild(topRow);

                    // 2. Instructies (Full Width)
                    const descGroup = document.createElement('div');
                    descGroup.style.cssText = 'margin-bottom:12px;';
                    // const descLabel = document.createElement('span');
                    // descLabel.innerText = 'Instructies';
                    // descLabel.style.cssText = labelStyle;
                    const descText = document.createElement('textarea');
                    descText.id = `desc-${uniqueId}`;
                    descText.placeholder = 'Instructies / Beschrijving van de oefening...';
                    descText.style.cssText = inputStyle + 'min-height:70px; resize:vertical; line-height:1.4;';
                    // Populate from Saved Data
                    if (savedDetails.desc) descText.value = savedDetails.desc;

                    // descGroup.appendChild(descLabel);
                    descGroup.appendChild(descText);
                    detailsDiv.appendChild(descGroup);

                    // 3. Materiaal Beschrijving (Full Width)
                    const matDescGroup = document.createElement('div');
                    matDescGroup.style.cssText = 'margin-bottom:12px;';
                    const matDescLabel = document.createElement('span');
                    matDescLabel.innerText = 'Materiaal Beschrijving';
                    matDescLabel.style.cssText = labelStyle;
                    const matDescTextarea = document.createElement('textarea');
                    matDescTextarea.id = `matdesc-${uniqueId}`;
                    matDescTextarea.placeholder = 'Extra details over het materiaal...';
                    matDescTextarea.style.cssText = inputStyle + 'min-height:50px; resize:vertical; color:#ccc;';
                    // Populate from Saved Data
                    if (savedDetails.matDesc) matDescTextarea.value = savedDetails.matDesc;

                    matDescGroup.appendChild(matDescLabel);
                    matDescGroup.appendChild(matDescTextarea);
                    detailsDiv.appendChild(matDescGroup);

                    // 4. Thumbnail (Image Only - Clickable)
                    const thumbContainer = document.createElement('div');
                    thumbContainer.style.cssText = 'margin-top:5px; width:250px; position:relative; group;'; // Container for positioning

                    const thumbImg = document.createElement('img');
                    thumbImg.id = `img-${uniqueId}`;
                    thumbImg.src = '';
                    // Improved Image Style: Rounded, Border, Shadow, Transition
                    thumbImg.style.cssText = 'width:100%; height:140px; object-fit:cover; background:#1C1C1E; border-radius:8px; border:1px solid #333; cursor:pointer; display:none; transition: transform 0.2s, border-color 0.2s; box-shadow: 0 4px 10px rgba(0,0,0,0.3);';

                    // Populate from Saved Data
                    if (savedDetails.thumbUrl) {
                        thumbImg.src = savedDetails.thumbUrl;
                        thumbImg.style.display = 'block';
                    }
                    if (savedDetails.videoUrl) {
                        thumbImg.setAttribute('data-video-url', savedDetails.videoUrl);
                        thumbImg.title = "Klik om video te openen";
                    }

                    thumbImg.onclick = function () {
                        const url = this.getAttribute('data-video-url');
                        if (!url) return;

                        // Extract ID (Standard YouTube formats)
                        let videoId = null;
                        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
                        const match = url.match(regExp);
                        if (match && match[2].length == 11) {
                            videoId = match[2];
                        }

                        if (videoId) {
                            // Create Iframe
                            const iframe = document.createElement('iframe');
                            iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
                            iframe.style.width = '100%';
                            iframe.style.height = '140px';
                            iframe.style.border = 'none';
                            iframe.style.borderRadius = '8px';
                            iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                            iframe.allowFullscreen = true;

                            // Swap
                            this.style.display = 'none';
                            thumbContainer.insertBefore(iframe, this); // Insert before implies it takes the spot, logic valid
                        } else {
                            window.open(url, '_blank');
                        }
                    };

                    // Hover Effect (via JS since inline)
                    thumbImg.onmouseover = () => { thumbImg.style.transform = 'scale(1.02)'; thumbImg.style.borderColor = '#30D158'; };
                    thumbImg.onmouseout = () => { thumbImg.style.transform = 'scale(1)'; thumbImg.style.borderColor = '#333'; };

                    const thumbUrlInput = document.createElement('input');
                    thumbUrlInput.id = `thumb-url-${uniqueId}`;
                    thumbUrlInput.type = 'text';
                    thumbUrlInput.style.cssText = 'display:none;';
                    if (savedDetails.thumbUrl) thumbUrlInput.value = savedDetails.thumbUrl;

                    thumbUrlInput.oninput = (e) => {
                        const url = e.target.value;
                        if (url) {
                            thumbImg.src = url;
                            thumbImg.style.display = 'block';
                        } else {
                            thumbImg.style.display = 'none';
                        }
                    };

                    // PLAY ICON OVERLAY REMOVED BY USER REQUEST
                    // const playOverlay = document.createElement('div');
                    // playOverlay.innerHTML = '';
                    // playOverlay.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); color:white; font-size:24px; text-shadow:0 2px 4px rgba(0,0,0,0.8); pointer-events:none; display:none;';

                    // Link overly visibility to image visibility
                    // Simpler: Helper to show/hide both
                    // thumbImg.addEventListener('load', () => { playOverlay.style.display = 'block'; }); // Removed play overlay listeners
                    // thumbImg.addEventListener('error', () => { playOverlay.style.display = 'none'; });

                    thumbContainer.appendChild(thumbImg);
                    // thumbContainer.appendChild(playOverlay); // Removed play overlay append
                    thumbContainer.appendChild(thumbUrlInput);
                    detailsDiv.appendChild(thumbContainer);

                    rowWrapper.appendChild(detailsDiv);
                    exerciseListContainer.appendChild(rowWrapper);
                }
            }
        }

        // --- NEW HELPER FUNCTIONS ---

        function toggleExerciseDetails(uniqueId) {
            const details = document.getElementById(`details-${uniqueId}`);
            const arrow = document.getElementById(`arrow-${uniqueId}`);

            if (details.style.display === 'none') {
                details.style.display = 'flex';
                arrow.innerHTML = ''; // Down arrow
                arrow.style.color = '#30D158';
            } else {
                details.style.display = 'none';
                arrow.innerHTML = ''; // Right arrow
                arrow.style.color = '#888';
            }
        }

        function updateExerciseDetail(uniqueId, field, value) {
            if (!customDetails[uniqueId]) customDetails[uniqueId] = {};
            customDetails[uniqueId][field] = value;
            saveToLocal();
        }

        function autoLoadFromCheckNumber(checkNum, uniqueId, roundIdx, exIdx, setIdx) {
            console.log('autoLoadFromCheckNumber called for uniqueId:', uniqueId, 'checkNum:', checkNum);
            if (!checkNum || !workoutDatabase) return;

            const match = workoutDatabase.find(ex => ex.check_number === checkNum);
            if (match) {
                const newName = match.exercise_name || '';
                if (newName) {
                    updateExerciseSlot(roundIdx, exIdx, setIdx, newName);
                    const headerDiv = document.getElementById(`details-${uniqueId}`)?.previousElementSibling;
                    const nameSpan = headerDiv?.querySelector('span[contenteditable]');
                    if (nameSpan) nameSpan.innerText = newName;
                    console.log(`Updated exercise name for ${uniqueId}:`, newName);
                }

                // Update Storage directly
                if (!customDetails[uniqueId]) customDetails[uniqueId] = {};
                customDetails[uniqueId].checkNum = checkNum;
                customDetails[uniqueId].desc = match.instructions || '';
                customDetails[uniqueId].mat = match.material_name || '';
                customDetails[uniqueId].matDesc = match.material_description || '';
                customDetails[uniqueId].thumbUrl = match.thumbnail || '';
                customDetails[uniqueId].videoUrl = match.video_search_url || '';
                saveToLocal();

                // Populate UI fields
                setTimeout(() => {
                    const descElem = document.getElementById(`desc-${uniqueId}`);
                    if (descElem) descElem.value = match.instructions || '';
                    const matElem = document.getElementById(`mat-${uniqueId}`);
                    if (matElem) matElem.value = match.material_name || '';
                    const matDescElem = document.getElementById(`matdesc-${uniqueId}`);
                    if (matDescElem) matDescElem.value = match.material_description || '';
                    const thumbUrl = match.thumbnail || '';
                    const thumbInput = document.getElementById(`thumb-url-${uniqueId}`);
                    if (thumbInput) thumbInput.value = thumbUrl;
                    const img = document.getElementById(`img-${uniqueId}`);
                    if (img) {
                        if (thumbUrl) {
                            img.src = thumbUrl;
                            img.style.display = 'block';
                            if (match.video_search_url) {
                                img.setAttribute('data-video-url', match.video_search_url);
                                img.title = "Klik om video te openen";
                            }
                        } else {
                            img.style.display = 'none';
                        }
                    }
                    console.log(`Populated fields for ${uniqueId}`);
                }, 0);
            }
        }

        // Update an exercise slot with smart propagation (same logic as before)
        function updateExerciseSlot(roundIdx, exIdx, setIdx, exerciseName) {
            // Initialize data structures if needed
            if (!roundExercises[roundIdx]) {
                roundExercises[roundIdx] = {};
            }
            if (!roundExercises[roundIdx][exIdx]) {
                roundExercises[roundIdx][exIdx] = {};
            }

            // AUTO-LOAD DETAILS LOGIC
            // Check if name matches DB
            const match = workoutDatabase ? workoutDatabase.find(e => e.exercise_name.toLowerCase() === exerciseName.toLowerCase()) : null;

            // Get total number of sets
            const roundCard = document.getElementById(`round-card-${roundIdx}`);
            const setsInput = roundCard ? roundCard.querySelector('input[onchange*="\'sets\'"]') : null;
            const totalSets = setsInput ? parseInt(setsInput.value) : 3;

            // Define keys to update depending on set logic
            const keysToUpdate = [];

            // Smart propagation logic
            if (setIdx === 0) {
                // Editing Set 1 - propagate to all sets
                for (let s = 0; s < totalSets; s++) {
                    roundExercises[roundIdx][exIdx][s] = exerciseName;
                    // Sync to customNames for Volledig Schema
                    const key = `r${roundIdx + 1}-e${exIdx + 1}-s${s + 1}`;
                    customNames[key] = exerciseName;
                    keysToUpdate.push(key);
                }
                console.log(`Updated Exercise ${exIdx + 1}, ALL SETS to: ${exerciseName}`);
            } else {
                // Editing Set 2+ - only update this specific set
                roundExercises[roundIdx][exIdx][setIdx] = exerciseName;
                // Sync to customNames for Volledig Schema
                const key = `r${roundIdx + 1}-e${exIdx + 1}-s${setIdx + 1}`;
                customNames[key] = exerciseName;
                keysToUpdate.push(key);
                console.log(`Updated Exercise ${exIdx + 1}, Set ${setIdx + 1} to: ${exerciseName}`);
            }

            // Apply Auto-Load Details
            if (match) {
                console.log("Auto-loading details for match:", match.exercise_name);
                keysToUpdate.forEach(uniqueId => {
                    if (!customDetails[uniqueId]) customDetails[uniqueId] = {};
                    customDetails[uniqueId].desc = match.instructions || '';
                    customDetails[uniqueId].mat = match.material_name || '';
                    customDetails[uniqueId].matDesc = match.material_description || ''; // Assuming field exists
                    customDetails[uniqueId].thumbUrl = match.thumbnail || '';
                    customDetails[uniqueId].videoUrl = match.video_search_url || '';
                    customDetails[uniqueId].checkNum = match.check_number || '';
                });
            }

            // Save to localStorage
            saveToLocal();

            // Re-render the exercise list for this round
            renderRoundExerciseList(roundIdx);
        }

        // Initialize exercise lists for all round cards when page loads
        function initializeRoundExerciseLists() {
            console.log('Initializing round exercise lists...');

            // SYNC: Copy customNames to roundExercises on page load
            // This ensures existing data from Volledig Schema appears in inline lists
            if (customNames && Object.keys(customNames).length > 0) {
                console.log('Syncing customNames to roundExercises...');
                for (let roundIdx = 0; roundIdx < workoutRounds.length; roundIdx++) {
                    const roundNum = roundIdx + 1;
                    const round = workoutRounds[roundIdx];
                    const numExercises = round.exercises || 5;
                    const numSets = round.sets || 3;

                    if (!roundExercises[roundIdx]) {
                        roundExercises[roundIdx] = {};
                    }

                    for (let ex = 0; ex < numExercises; ex++) {
                        const exNum = ex + 1;
                        if (!roundExercises[roundIdx][ex]) {
                            roundExercises[roundIdx][ex] = {};
                        }

                        for (let setIdx = 0; setIdx < numSets; setIdx++) {
                            const setNum = setIdx + 1;
                            const key = `r${roundNum}-e${exNum}-s${setNum}`;
                            if (customNames[key]) {
                                roundExercises[roundIdx][ex][setIdx] = customNames[key];
                            }
                        }
                    }
                }
                console.log('Sync complete:', roundExercises);
            }

            // Function to render all visible round cards
            function renderAllRounds() {
                const roundCards = document.querySelectorAll('[id^="round-card-"]');
                if (roundCards.length > 0) {
                    console.log(`Found ${roundCards.length} round cards, rendering exercise lists...`);
                    roundCards.forEach((card, index) => {
                        // Only render if not already rendered or needs update
                        const existingContainer = card.querySelector('.exercise-list-container');
                        if (!existingContainer || existingContainer.children.length === 0) {
                            renderRoundExerciseList(index);
                        }
                    });
                }
            }

            // Initial render
            renderAllRounds();

            // Re-render when inputs change
            document.addEventListener('input', function (e) {
                if (e.target.matches('[id^="round-card-"] input[onchange*="exercises"], [id^="round-card-"] input[onchange*="sets"]')) {
                    const roundCard = e.target.closest('[id^="round-card-"]');
                    if (roundCard) {
                        const roundIndex = parseInt(roundCard.id.replace('round-card-', ''));
                        if (!isNaN(roundIndex)) {
                            // Delay to allow the value to update
                            setTimeout(() => renderRoundExerciseList(roundIndex), 100);
                        }
                    }
                }
            });

            // Watch for DOM changes (when round blocks are rebuilt)
            const observer = new MutationObserver(function (mutations) {
                let shouldRender = false;
                mutations.forEach(mutation => {
                    // Check if round cards were added or modified
                    if (mutation.addedNodes.length > 0) {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1) { // Element node
                                if (node.id && node.id.startsWith('round-card-')) {
                                    shouldRender = true;
                                } else if (node.querySelector && node.querySelector('[id^="round-card-"]')) {
                                    shouldRender = true;
                                }
                            }
                        });
                    }
                });

                if (shouldRender) {
                    console.log('DOM changed - re-rendering exercise lists');
                    setTimeout(renderAllRounds, 50);
                }
            });

            // Observe the document body for changes
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });

            // Also periodically check and render (fallback in case observer misses something)
            setInterval(function () {
                const roundCards = document.querySelectorAll('[id^="round-card-"]');
                roundCards.forEach((card, index) => {
                    const container = card.querySelector('.exercise-list-container');
                    // Only re-render if container is missing
                    if (!container) {
                        renderRoundExerciseList(index);
                    }
                });
            }, 1000); // Check every second
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeRoundExerciseLists);
        } else {
            initializeRoundExerciseLists();
        }





        // --- MATERIAL SELECTOR LOGIC ---
        let allExercises = [];
        let uniqueMaterials = new Set();
        let selectedMaterials = new Set();
        let isDataLoaded = false;

        function openMaterialModal() {
            const modal = document.getElementById('material-modal');
            modal.classList.add('active');

            if (!isDataLoaded) {
                fetchWorkoutData();
            }
        }

        function closeMaterialModal() {
            document.getElementById('material-modal').classList.remove('active');
        }

        async function fetchWorkoutData() {
            // Already fetched earlier?
            if (workoutDatabase && workoutDatabase.length > 0) {
                console.log("Using existing workoutDatabase");
                allExercises = workoutDatabase;
                processData();
                return;
            }

            try {
                const response = await fetch('workoutdatabase.json');
                if (!response.ok) throw new Error("Failed to load database");

                const data = await response.json();
                allExercises = data;
                // Assign to global if needed by other legacy code
                if (typeof workoutDatabase === 'undefined' || !workoutDatabase) {
                    workoutDatabase = data;
                }

                processData();
            } catch (err) {
                console.error("Error loading workout data:", err);
                // Fallback attempt if variable exists but fetch failed (unlikely)
            }
        }

        function processData() {
            isDataLoaded = true;
            uniqueMaterials.clear();
            selectedMaterials.clear(); // Ensure clean start

            allExercises.forEach(ex => {
                if (ex.material_name) {
                    uniqueMaterials.add(ex.material_name);
                }
            });

            // Select ALL by default
            uniqueMaterials.forEach(mat => selectedMaterials.add(mat));

            renderMaterialFilters();
            renderMaterialExerciseList();
        }

        function renderMaterialFilters() {
            const container = document.getElementById('material-filters');
            container.innerHTML = '';

            const sortedMaterials = Array.from(uniqueMaterials).sort(); // Alphabetical

            // --- SELECT ALL / NONE BUTTON ---
            const allBtn = document.createElement('div');
            allBtn.className = 'material-tag';
            allBtn.style.cssText = "background: #fff; color: #000; font-weight: 800; border: 1px solid #fff;";

            // Check state
            const isAllSelected = (selectedMaterials.size === uniqueMaterials.size);

            if (isAllSelected) {
                allBtn.innerText = " NIETS";
                allBtn.onclick = () => {
                    selectedMaterials.clear();
                    renderMaterialFilters();
                    renderMaterialExerciseList();
                };
            } else {
                allBtn.innerText = " ALLES";
                allBtn.onclick = () => {
                    uniqueMaterials.forEach(m => selectedMaterials.add(m));
                    renderMaterialFilters();
                    renderMaterialExerciseList();
                };
            }
            container.appendChild(allBtn);

            // --- INDIVIDUAL TAGS ---
            sortedMaterials.forEach(mat => {
                const tag = document.createElement('div');
                tag.className = 'material-tag';
                tag.innerText = mat;
                if (selectedMaterials.has(mat)) {
                    tag.classList.add('selected');
                }
                tag.onclick = () => toggleMaterial(mat);
                container.appendChild(tag);
            });
        }

        function toggleMaterial(mat) {
            if (selectedMaterials.has(mat)) {
                selectedMaterials.delete(mat);
            } else {
                selectedMaterials.add(mat);
            }
            renderMaterialFilters(); // Update styles
            renderMaterialExerciseList();
        }

        function renderMaterialExerciseList() {
            const listContainer = document.getElementById('material-ex-list');
            listContainer.innerHTML = '';

            // Filter
            const filtered = allExercises.filter(ex => {
                if (selectedMaterials.size === 0) return true; // Show all if no filter
                return selectedMaterials.has(ex.material_name);
            });

            // Sort by name
            filtered.sort((a, b) => a.exercise_name.localeCompare(b.exercise_name));

            filtered.forEach(ex => {
                const item = document.createElement('div');
                item.className = 'exercise-item';
                item.onclick = () => showPreview(ex);

                const thumb = document.createElement('img');
                thumb.className = 'ex-list-thumb';
                thumb.src = ex.thumbnail || 'FNH logo.jpg';

                const info = document.createElement('div');
                info.className = 'ex-list-info';

                const name = document.createElement('div');
                name.className = 'ex-list-name';
                name.innerText = ex.exercise_name;

                const cat = document.createElement('div');
                cat.className = 'ex-list-cat';
                cat.innerText = ex.material_name || 'Geen materiaal';

                info.appendChild(name);
                info.appendChild(cat);

                item.appendChild(thumb);
                item.appendChild(info);

                listContainer.appendChild(item);
            });
        }

        function showPreview(ex) {
            const img = document.getElementById('prev-img');
            const title = document.getElementById('prev-title');
            const meta = document.getElementById('prev-meta');
            const desc = document.getElementById('prev-desc');

            // Reset video container if exists (remove old iframe if any)
            const parent = img.parentNode; // #preview-content (likely, or direct wrapper)
            // Actually, we just need to ensure the img is displayed and any iframe is removed?
            // The structure is likely static HTML, so we just toggle visibility.
            // Let's assume we append iframe to a container or replace img.
            // Better: Remove any existing iframes in the preview-image container area.
            // Looking at HTML structure (from memory/view), #prev-img is inside.
            // Let's rely on standard ID behavior.

            // Clear previous iframe if any
            const oldIframe = document.getElementById('preview-iframe');
            if (oldIframe) oldIframe.remove();

            if (ex.thumbnail) {
                img.src = ex.thumbnail;
                img.style.display = 'block';

                // Store video URL
                if (ex.video_search_url) {
                    img.setAttribute('data-video-url', ex.video_search_url);
                    img.style.cursor = 'pointer';
                    img.title = "Klik om video te starten";

                    // Click Handler for Video
                    img.onclick = () => {
                        const url = ex.video_search_url;
                        let videoId = null;

                        // Extract ID (Standard YouTube formats)
                        const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
                        const match = url.match(regExp);
                        if (match && match[2].length == 11) {
                            videoId = match[2];
                        }

                        if (videoId) {
                            // Create Iframe
                            const iframe = document.createElement('iframe');
                            iframe.id = 'preview-iframe';
                            iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1&rel=0`;
                            iframe.style.width = '100%';
                            iframe.style.aspectRatio = '16/9';
                            iframe.style.border = 'none';
                            iframe.style.borderRadius = '12px';
                            iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                            iframe.allowFullscreen = true;

                            // Swap
                            img.style.display = 'none';
                            img.parentNode.insertBefore(iframe, img);
                        } else {
                            window.open(url, '_blank');
                        }
                    };

                } else {
                    img.onclick = null;
                    img.style.cursor = 'default';
                    img.title = "";
                }

            } else {
                img.style.display = 'none';
            }

            title.innerText = ex.exercise_name;
            meta.innerText = `${ex.category}  ${ex.material_name}`;
            desc.innerText = ex.instructions || "Geen instructies beschikbaar.";

            // Highlight active item
            document.querySelectorAll('.exercise-item').forEach(el => el.classList.remove('active'));
        }


        // --- SMART EXERCISE MENU LOGIC ---
        function createExerciseMenu(uniqueId, roundIndex, exIdx, setIdx) {
            const container = document.createElement('div');
            container.className = 'exercise-menu-container';
            container.id = `menu-container-${uniqueId}`;

            const trigger = document.createElement('div');
            trigger.className = 'exercise-menu-trigger';
            trigger.innerHTML = ''; // Down arrow
            trigger.onclick = (e) => {
                e.stopPropagation();
                // REFRESH DATA ON OPEN
                const dropdown = document.getElementById(`menu-dropdown-${uniqueId}`);
                populateExerciseMenu(dropdown, uniqueId, roundIndex, exIdx, setIdx);
                toggleExerciseMenu(uniqueId);
            };

            const dropdown = document.createElement('div');
            dropdown.className = 'exercise-dropdown';
            dropdown.id = `menu-dropdown-${uniqueId}`;

            // Populate initially (or lazily on click to save perf, but eagerly is fine for now)
            populateExerciseMenu(dropdown, uniqueId, roundIndex, exIdx, setIdx);

            container.appendChild(trigger);
            container.appendChild(dropdown);
            return container;
        }

        function toggleExerciseMenu(uniqueId) {
            // Close all others first
            document.querySelectorAll('.exercise-dropdown.active').forEach(el => {
                if (el.id !== `menu-dropdown-${uniqueId}`) el.classList.remove('active');
            });

            const dropdown = document.getElementById(`menu-dropdown-${uniqueId}`);
            if (dropdown) {
                dropdown.classList.toggle('active');
            }
        }

        // Close menus when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.exercise-menu-container')) {
                document.querySelectorAll('.exercise-dropdown.active').forEach(el => el.classList.remove('active'));
            }
        });

        async function populateExerciseMenu(dropdown, uniqueId, roundIndex, exIdx, setIdx) {
            dropdown.innerHTML = '';

            // Auto-fetch if empty
            if (allExercises.length === 0) {
                dropdown.innerHTML = '<div style="padding:10px; color:#aaa;">Laden...</div>';
                await fetchWorkoutData();
            }

            console.log(`Populating Menu [${uniqueId}]. Total: ${allExercises.length}, SelectedFilters:`, Array.from(selectedMaterials));

            // Filter exercises based on global 'selectedMaterials'
            // If no materials selected, show all
            let filtered = allExercises;

            if (selectedMaterials.size > 0) {
                filtered = allExercises.filter(ex => selectedMaterials.has(ex.material_name));
            }

            // sort alpha
            filtered.sort((a, b) => a.exercise_name.localeCompare(b.exercise_name));

            if (filtered.length === 0) {
                const empty = document.createElement('div');
                empty.style.padding = '10px';
                empty.style.color = '#888';
                empty.style.fontSize = '12px';
                empty.innerText = 'Geen oefeningen gevonden voor geselecteerde filter.';
                dropdown.appendChild(empty);
                return;
            }

            filtered.forEach(ex => {
                const item = document.createElement('div');
                item.className = 'menu-item';
                item.onclick = (e) => {
                    e.stopPropagation();
                    selectExerciseFromMenu(ex, uniqueId, roundIndex, exIdx, setIdx);
                    toggleExerciseMenu(uniqueId); // Close
                };

                const img = document.createElement('img');
                img.src = ex.thumbnail || 'FNH logo.jpg';

                const div = document.createElement('div');
                div.className = 'menu-item-info';

                const name = document.createElement('div');
                name.className = 'menu-item-name';
                name.innerText = ex.exercise_name;

                const meta = document.createElement('div');
                meta.className = 'menu-item-meta';
                meta.innerText = ex.material_name || '';

                div.appendChild(name);
                div.appendChild(meta);

                item.appendChild(img);
                item.appendChild(div);
                dropdown.appendChild(item);
            });
        }

        function selectExerciseFromMenu(ex, uniqueId, roundIndex, exIdx, setIdx) {
            console.log("Selected:", ex.exercise_name);

            // 1. Update Name in Slot
            updateExerciseSlot(roundIndex, exIdx, setIdx, ex.exercise_name);
            const headerDiv = document.getElementById(`details-${uniqueId}`)?.previousElementSibling;
            const nameSpan = headerDiv?.querySelector('span[contenteditable]');
            if (nameSpan) nameSpan.innerText = ex.exercise_name;

            // 2. Update Details
            if (!customDetails[uniqueId]) customDetails[uniqueId] = {};
            customDetails[uniqueId].checkNum = ex.check_number; // Keep legacy ref
            customDetails[uniqueId].desc = ex.instructions || '';
            customDetails[uniqueId].mat = ex.material_name || '';
            customDetails[uniqueId].matDesc = ex.material_description || '';
            customDetails[uniqueId].thumbUrl = ex.thumbnail || '';
            customDetails[uniqueId].videoUrl = ex.video_search_url || '';
            saveToLocal();

            // 3. Update UI Inputs immediately
            const descElem = document.getElementById(`desc-${uniqueId}`);
            if (descElem) descElem.value = ex.instructions || '';

            const matElem = document.getElementById(`mat-${uniqueId}`);
            if (matElem) matElem.value = ex.material_name || '';

            const matDescElem = document.getElementById(`matdesc-${uniqueId}`);
            if (matDescElem) matDescElem.value = ex.material_description || '';

            /// Update Thumbnail Preview
            const img = document.getElementById(`img-${uniqueId}`);
            if (img) {
                if (ex.thumbnail) {
                    img.src = ex.thumbnail;
                    img.style.display = 'block';
                    if (ex.video_search_url) {
                        img.setAttribute('data-video-url', ex.video_search_url);
                        img.title = "Klik om video te openen";
                    }
                } else {
                    img.style.display = 'none';
                }
            }
        }
    </script>
</body>

/* --- STATION CARDS PDF LOGIC --- */
function openPrintMenu() {
const modal = document.getElementById('print-modal');
if(!modal) return;

// Populate Rounds
const roundSelect = document.getElementById('print-round-select');
roundSelect.innerHTML = '';
const totalRounds = parseInt(document.getElementById('rounds').value) || 1;

// All Option
const optAll = document.createElement('option');
optAll.value = 'all';
optAll.innerText = `Alle ${totalRounds} Rondes`;
roundSelect.appendChild(optAll);

// Individual Rounds
for(let r=1; r<=totalRounds; r++) { const opt=document.createElement('option'); opt.value=r; opt.innerText=`Ronde ${r}`;
    roundSelect.appendChild(opt); } modal.style.display='flex' ; } async function startPrintJob() { const
    roundVal=document.getElementById('print-round-select').value; const
    setMode=document.getElementById('print-set-mode').value; // 'first' or 'all' const
    totalRounds=parseInt(document.getElementById('rounds').value) || 1; // Mock Data Fallback (Self-Correction for
    testing) // If DB is empty, fill with mock data so the user can test immediately if((!WORKOUT_DB ||
    WORKOUT_DB.length===0)) { console.log("Database empty, using Mock Data for PDF Test"); WORKOUT_DB=[ {
    exercise_name: "Mock Squat" , material_name: "Kettlebell" , material_description: "16kg" ,
    instructions: "Diep zakken, rug recht." , video_search_url: "https://www.youtube.com/watch?v=dQw4w9WgXcQ" }, {
    exercise_name: "Mock Pushup" , material_name: "Eigen start" , material_description: "Geen" ,
    instructions: "Borst naar de vloer." , video_search_url: "" } ]; } await generateStationCards(roundVal, setMode);
    document.getElementById('print-modal').style.display='none' ; } async function generateStationCards(targetRound,
    setMode) { if (!window.jsPDF) { alert("jsPDF library niet geladen!"); return; } const doc=new window.jsPDF({
    orientation: 'landscape' , unit: 'mm' , format: 'a4' }); const roundsToProcess=targetRound==='all' ?
    Array.from({length: parseInt(document.getElementById('rounds').value)}, (_, i)=> i + 1)
    : [parseInt(targetRound)];

    let pageAdded = false;
    let cardCount = 0;

    // QR Code Generator Helper (Using qrcode.js)
    const generateQR = (url) => {
    if(!url) return null;
    const div = document.createElement('div');
    // qrcode.js renders synchronously usually
    try {
    new QRCode(div, { text: url, width: 256, height: 256 });
    const canvas = div.querySelector('canvas');
    if (canvas) return canvas.toDataURL('image/png');
    // Fallback for older browsers if img is used
    const img = div.querySelector('img');
    if (img) return img.src;
    } catch(e) {
    console.error("QR Gen Error:", e);
    }
    return null;
    };

    const exCount = parseInt(document.getElementById('exercises').value) || 1;
    const setsCount = parseInt(document.getElementById('sets').value) || 1;

    for (const r of roundsToProcess) {
    for (let e = 1; e <= exCount; e++) { const setsToProcess=setMode==='first' ? [1] : Array.from({length: setsCount},
        (_, i)=> i + 1);

        for (const s of setsToProcess) {
        // Get Name
        let exName = `Exercise ${e}`;
        if (typeof roundExercises !== 'undefined' && roundExercises[r] && roundExercises[r][e] &&
        roundExercises[r][e][s]) {
        exName = roundExercises[r][e][s];
        }

        // Get Details (Try customDetails first, then DB)
        const uniqueId = `r${r}-e${e}-s${s}`;
        let matName = "MATERIAAL ONBEKEND";
        let matDesc = "Geen beschrijving";
        let instructions = "Geen instructies beschikbaar.";
        let videoUrl = "";

        // 1. Try Custom Details (Live Edits)
        if (typeof customDetails !== 'undefined' && customDetails[uniqueId]) {
        if(customDetails[uniqueId].mat) matName = customDetails[uniqueId].mat;
        if(customDetails[uniqueId].matDesc) matDesc = customDetails[uniqueId].matDesc;
        if(customDetails[uniqueId].desc) instructions = customDetails[uniqueId].desc;
        if(customDetails[uniqueId].videoUrl) videoUrl = customDetails[uniqueId].videoUrl;
        }

        // 2. Try DB Lookup if we still look like default or if we just want to enhance
        // Note: If customDetails has data, we usually trust it. But if it lacks specific fields, we might fallback.
        // Here we prioritize customDetails fully if present for that field.

        const dbItem = WORKOUT_DB.find(item => item.exercise_name === exName);
        if (dbItem) {
        if (matName === "MATERIAAL ONBEKEND") matName = dbItem.material_name || matName;
        if (matDesc === "Geen beschrijving") matDesc = dbItem.material_description || matDesc;
        if (instructions === "Geen instructies beschikbaar.") instructions = dbItem.instructions || instructions;
        if (!videoUrl) videoUrl = dbItem.video_search_url || "";
        }

        // Add Page
        if (pageAdded) doc.addPage();
        pageAdded = true;
        cardCount++;

        // --- DESIGN (A4 Landscape: 297x210mm) ---
        const width = 297;
        const height = 210;

        // Top Left: Huge Exercise Number
        doc.setFont("helvetica", "bold");
        doc.setFontSize(80);
        doc.setTextColor(220, 220, 220); // Very Light Grey
        doc.text(`${e < 10 ? '0' +e : e}`, 15, 35); // Big Index // Top Right: QR Code if (videoUrl) { const
            qrData=generateQR(videoUrl); if (qrData) { doc.addImage(qrData, 'PNG' , width - 45, 10, 35, 35);
            doc.setFontSize(9); doc.setTextColor(0, 0, 0); doc.text("SCAN VIDEO", width - 45, 49, { align: 'left' }); }
            } // Center: Exercise Name doc.setFont("helvetica", "bold" ); doc.setFontSize(40); doc.setTextColor(0, 0,
            0); // Split long names const splitName=doc.splitTextToSize(exName, width - 60); // Vertical align
            calculation let textY=70; if (splitName.length> 1) textY = 60;

            doc.text(splitName, width / 2, textY, { align: 'center' });

            // Green Bar (Material)
            const barY = textY + (splitName.length * 15) + 5;
            doc.setFillColor(48, 209, 88); // #30D158 Green
            doc.rect(20, barY, width - 40, 20, 'F');

            doc.setFontSize(20);
            doc.setTextColor(0, 0, 0); // Black on Green
            doc.text((matName || "").toUpperCase(), width / 2, barY + 13, { align: 'center' });

            // Material Description
            doc.setFont("helvetica", "italic");
            doc.setFontSize(14);
            doc.setTextColor(80, 80, 80);
            doc.text(matDesc || "", width / 2, barY + 28, { align: 'center' });

            // Bottom: Instructions
            doc.setFont("helvetica", "normal");
            doc.setFontSize(16);
            doc.setTextColor(0, 0, 0);

            const instrY = barY + 45;
            const splitInstr = doc.splitTextToSize(instructions, width - 40);
            doc.text(splitInstr, 20, instrY);

            // Footer
            doc.setFontSize(10);
            doc.setTextColor(150, 150, 150);
            doc.text(`Ronde ${r} - Oefening ${e} - Set ${s} | Friday-night-hawk-s Station Card`, 20, height - 10);
            }
            }
            }

            if(cardCount > 0) {
            doc.save(`StationCards_${new Date().toISOString().slice(0,10)}.pdf`);
            } else {
            alert("Geen kaarten gegenereerd. Check selectie.");
            }
            }
            </script>
            </body>

</html>